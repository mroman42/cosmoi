<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-08-11 Sat 12:05 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mónadas</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Mario Román" />
<link rel="stylesheet" href="default.css" />
<link rel="stylesheet" href="mathjax_fonts.css" />
<link rel="stylesheet" href="syntax.css" />
<div id="header">
<div id="logo">
<a href="index.html">Cosmoi</a>
</div>
<div id="navigation">
<a href="index.html">Index</a>
<a href="about.html">About</a>
<a href="feed.xml">RSS</a>
</div>
</div>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Mónadas</h1>
<blockquote>
<p>
A monad is just a monoid in the category of endofunctors, what's the
problem?
</p>

<p>
&#x2013; <b>Philip Walder</b> (apócrifa) en <i><a href="http://james-iry.blogspot.com.es/2009/05/brief-incomplete-and-mostly-wrong.html">A Brief, Incomplete, and Mostly Wrong History of programming languages</a></i>
</p>
</blockquote>

<div id="outline-container-org75eae3b" class="outline-2">
<h2 id="org75eae3b">Prerrequisitos</h2>
<div class="outline-text-2" id="text-org75eae3b">
<p>
Este artículo requiere un conocimiento previo de Haskell, o al menos, de
otro lenguaje de programación funcional. Puedes consultar nuestra
<a href="http://tux.ugr.es/dgiim/blog/2014/10/01/intro-haskell/">introducción a Haskell</a> con recursos para iniciarte en el lenguaje.
</p>

<p>
Por otro lado, para la segunda parte del artículo es recomendable
conocimiento previo sobre teoría de categorías. Aun así, no es necesaria
para leer la primera parte del artículo, donde hablamos de mónadas sin
hacer ninguna referencia explícita a la teoría de categorías. Si quieres
leer sobre ese tema, puedes consultar nuestros apuntes de
<a href="http://tux.ugr.es/dgiim/blog/2014/10/04/intro-categorias/">introducción a teoría de categorías</a>.
</p>
</div>
</div>

<div id="outline-container-orgf979347" class="outline-2">
<h2 id="orgf979347">Motivación para las mónadas</h2>
<div class="outline-text-2" id="text-orgf979347">
</div>
<div id="outline-container-org839550a" class="outline-3">
<h3 id="mónadas-en-haskell"><a id="org839550a"></a>Mónadas en Haskell</h3>
<div class="outline-text-3" id="text-mónadas-en-haskell">
<p>
Imaginemos que necesitamos controlar cuando una función interna devuelve
un error, o cuando usa un estado que debe ser pasado al resto de
funciones. Cuando trabajamos con programación funcional pura, debemos
devolver explícitamente el error (señalar cómo va a tratarlo cada
función) o pasar el estado como argumento a cada una de las funciones;
así que una solución sería modificar cada una de las funciones que
usamos para que tenga en cuenta ese estado o ese caso de error, pero
esto añadiría mucha complejidad innecesaria a nuestro código. La
estructura de mónada simplifica esta escritura.
</p>

<p>
El siguiente ejemplo, en el que tratamos el manejo de errores
encapsulado en una mónada, está inspirado en los ejemplos de:
</p>

<ul class="org-ul">
<li><a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">Monads for functional programming</a> - <i>Philip Wadler</i></li>
</ul>

<p>
Que es una muy buena introducción al uso de las mónadas en programación
funcional.
</p>
</div>
</div>

<div id="outline-container-orga23fa8f" class="outline-3">
<h3 id="orga23fa8f">Calculando raíces cuadradas</h3>
<div class="outline-text-3" id="text-orga23fa8f">
<p>
Por ejemplo, supongamos que intentamos sacar raíces cuadradas en los
reales usando el <a href="https://en.wikipedia.org/wiki/Integer_square_root#Algorithm">método de Newton</a>. Si intentamos calcular <object type="image/svg+xml" data="ltximg/blog_c47676a7bcd7862a6033311a75b095ebb281950b.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>, 
podemos tomar a cada paso la aproximación:
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_eba2ff38a4e7fe125dcfd3cb0e45f21875d13a4c.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<p>
Y parar cuando estemos suficientemente cerca (más cerca que un ε dado):
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_161cfd13cd99c55ce77007beb4cf017a342a3c70.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<p>
Escribimos una implementación de ese concepto de convergencia para
listas infinitas en Haskell y del método de Newton, basado en la función
<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:iterate"><code>iterate</code></a>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #cae682;">limit</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #DCDCCC;">[</span><span style="color: #92a65e; font-weight: bold;">Float</span><span style="color: #DCDCCC;">]</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Float</span>
<span style="color: #cae682;">limit</span> epsilon <span style="color: #DCDCCC;">(</span>x<span style="color: #92a65e; font-weight: bold;">:</span>y<span style="color: #92a65e; font-weight: bold;">:</span>xs<span style="color: #DCDCCC;">)</span>
  <span style="color: #cae682;">|</span> abs <span style="color: #DCDCCC;">(</span>x<span style="color: #cae682;">-</span>y<span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">&lt;</span> epsilon <span style="color: #cae682;">=</span> y
  <span style="color: #cae682;">|</span> otherwise           <span style="color: #cae682;">=</span> limit epsilon <span style="color: #DCDCCC;">(</span>y<span style="color: #92a65e; font-weight: bold;">:</span>xs<span style="color: #DCDCCC;">)</span>

<span style="color: #cae682;">newtonaprox</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Float</span>
<span style="color: #cae682;">newtonaprox</span> n x <span style="color: #cae682;">=</span> <span style="color: #DCDCCC;">(</span>x <span style="color: #cae682;">+</span> n<span style="color: #cae682;">/</span>x<span style="color: #DCDCCC;">)</span><span style="color: #cae682;">/</span>2

<span style="color: #cae682;">sqroot</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Float</span>
<span style="color: #cae682;">sqroot</span> 0 <span style="color: #cae682;">=</span> 0
<span style="color: #cae682;">sqroot</span> x <span style="color: #cae682;">=</span> limit 0.03 <span style="color: #DCDCCC;">(</span>iterate <span style="color: #BFEBBF;">(</span>newtonaprox x<span style="color: #BFEBBF;">)</span> x<span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
Ahora imaginemos que usamos esta raíz cuadrada recién definida para
solucionar una ecuación de segundo grado <object type="image/svg+xml" data="ltximg/blog_8b01f59e13881718fc76db150af57366bd7853ab.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>:
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_d56879862bc6ab81a169fdd6af183bff44ea3d9d.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<p>
Podemos definir una estructura de datos <code>QPol</code> para el polinomio y una
función que lo resuelva obteniendo sus dos raíces:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8ac6f2; font-weight: bold;">data</span> <span style="color: #92a65e; font-weight: bold;">QPol</span> <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">QPol</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #92a65e; font-weight: bold;">Float</span>

<span style="color: #8ac6f2; font-weight: bold;">instance</span> <span style="color: #92a65e; font-weight: bold;">Show</span> <span style="color: #92a65e; font-weight: bold;">QPol</span> <span style="color: #8ac6f2; font-weight: bold;">where</span>
    show <span style="color: #DCDCCC;">(</span><span style="color: #92a65e; font-weight: bold;">Qpol</span> a b c<span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">=</span> show a <span style="color: #cae682;">++</span> <span style="color: #95e454;">"x&#178; + "</span> <span style="color: #cae682;">++</span> show b <span style="color: #cae682;">++</span> <span style="color: #95e454;">"x + "</span> show c

<span style="color: #cae682;">solve</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">QPol</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #DCDCCC;">(</span><span style="color: #92a65e; font-weight: bold;">Float</span>,<span style="color: #92a65e; font-weight: bold;">Float</span><span style="color: #DCDCCC;">)</span>
<span style="color: #cae682;">solve</span> <span style="color: #DCDCCC;">(</span><span style="color: #92a65e; font-weight: bold;">QPol</span> a b c<span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">=</span> <span style="color: #DCDCCC;">(</span>sol1 sol2<span style="color: #DCDCCC;">)</span>
    <span style="color: #8ac6f2; font-weight: bold;">where</span> sol1 <span style="color: #cae682;">=</span> <span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">(</span><span style="color: #cae682;">-</span>b<span style="color: #BFEBBF;">)</span> <span style="color: #cae682;">+</span> sqroot<span style="color: #BFEBBF;">(</span>b<span style="color: #cae682;">*</span>b<span style="color: #cae682;">-</span>4<span style="color: #cae682;">*</span>c<span style="color: #cae682;">*</span>a<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span><span style="color: #cae682;">/</span><span style="color: #DCDCCC;">(</span>2<span style="color: #cae682;">*</span>a<span style="color: #DCDCCC;">)</span>
          sol2 <span style="color: #cae682;">=</span> <span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">(</span><span style="color: #cae682;">-</span>b<span style="color: #BFEBBF;">)</span> <span style="color: #cae682;">-</span> sqroot<span style="color: #BFEBBF;">(</span>b<span style="color: #cae682;">*</span>b<span style="color: #cae682;">-</span>4<span style="color: #cae682;">*</span>c<span style="color: #cae682;">*</span>a<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span><span style="color: #cae682;">/</span><span style="color: #DCDCCC;">(</span>2<span style="color: #cae682;">*</span>a<span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
Y podemos comprobar que funciona:
</p>

<pre class="example">
λ&gt; pol = QPol 1 (-5) 6
λ&gt; putStrLn $ "Las soluciones de " ++ show pol ++ " son " ++ solve pol
Las soluciones de 1.0x² + -5.0x + 6.0 son (3.0,2.0)
</pre>
</div>
</div>

<div id="outline-container-orgf6b9b56" class="outline-3">
<h3 id="orgf6b9b56">Controlando los errores</h3>
<div class="outline-text-3" id="text-orgf6b9b56">
<p>
Pero ¿qué ocurre cuando intentamos calcular la raíz cuadrada de un
número no positivo? Este método no la encuentra, por lo que debería
devolver un error antes de intentar empezar a calcularla. La solución
obvia es reflejar este error con un <code>Maybe</code> en el cálculo de la raíz
cuadrada.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #cae682;">sqroot'</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Maybe</span> <span style="color: #92a65e; font-weight: bold;">Float</span>
<span style="color: #cae682;">sqroot'</span> x
  <span style="color: #cae682;">|</span> x <span style="color: #cae682;">&lt;</span> 0     <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Nothing</span>
  <span style="color: #cae682;">|</span> x <span style="color: #cae682;">==</span> 0    <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Just</span> 0.0
  <span style="color: #cae682;">|</span> otherwise <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Just</span> <span style="color: #DCDCCC;">(</span> limit 0.03 <span style="color: #BFEBBF;">(</span>iterate <span style="color: #D0BF8F;">(</span>newtonsqrt x<span style="color: #D0BF8F;">)</span> x<span style="color: #BFEBBF;">)</span> <span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
Esto lo soluciona, pero nos crea un problema mayor. La función <code>solve</code>
está usando la raíz cuadrada y se espera de ella que devuelva un número,
no un posible error. Si queremos conseguir que funcione con la nueva
<code>sqroot'</code>, necesitaríamos implementar todas sus componentes internas
teniendo en cuenta ese error. Por ejemplo, deberíamos reescribir el
<code>(+)</code>, para tener en cuenta errores y propagarlos por todos los cálculos
involucrando a <code>sqroot'</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #DCDCCC;">(</span><span style="color: #cae682;">+.</span><span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Maybe</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Maybe</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Maybe</span> <span style="color: #92a65e; font-weight: bold;">Float</span>
<span style="color: #DCDCCC;">(</span><span style="color: #cae682;">+.</span><span style="color: #DCDCCC;">)</span> <span style="color: #92a65e; font-weight: bold;">Nothing</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Nothing</span>
<span style="color: #DCDCCC;">(</span><span style="color: #cae682;">+.</span><span style="color: #DCDCCC;">)</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #92a65e; font-weight: bold;">Nothing</span> <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Nothing</span>
<span style="color: #DCDCCC;">(</span><span style="color: #cae682;">+.</span><span style="color: #DCDCCC;">)</span> <span style="color: #DCDCCC;">(</span><span style="color: #92a65e; font-weight: bold;">Just</span> a<span style="color: #DCDCCC;">)</span> <span style="color: #DCDCCC;">(</span><span style="color: #92a65e; font-weight: bold;">Just</span> b<span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Just</span> <span style="color: #DCDCCC;">(</span>a <span style="color: #cae682;">+</span> b<span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
Pero esto es muy pesado de implementar; deberíamos implementarlo ¡para
cada una de las operaciones que usen la raíz cuadrada en algún punto!
Esto obliga a cada una de nuestras operaciones intermedias a ser
conscientes de la posibilidad de error, dándonos código mucho menos
modular y reusable.
</p>

<p>
Una solución ligeramente mejor es la de abstraer este proceso de hacer a
una función consciente de la posibilidad de error en una función aparte
y definir las demás en función suya:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #cae682;">errorAware</span> <span style="color: #cae682;">::</span> <span style="color: #DCDCCC;">(</span>a <span style="color: #cae682;">-&gt;</span> b <span style="color: #cae682;">-&gt;</span> c<span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Maybe</span> a <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Maybe</span> b <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Maybe</span> c
<span style="color: #cae682;">errorAware</span> op <span style="color: #92a65e; font-weight: bold;">Nothing</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Nothing</span>
<span style="color: #cae682;">errorAware</span> op <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #92a65e; font-weight: bold;">Nothing</span> <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Nothing</span>
<span style="color: #cae682;">errorAware</span> op <span style="color: #DCDCCC;">(</span><span style="color: #92a65e; font-weight: bold;">Just</span> a<span style="color: #DCDCCC;">)</span> <span style="color: #DCDCCC;">(</span><span style="color: #92a65e; font-weight: bold;">Just</span> b<span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Just</span> <span style="color: #DCDCCC;">(</span>op a b<span style="color: #DCDCCC;">)</span>

<span style="color: #DCDCCC;">(</span><span style="color: #cae682;">+.</span><span style="color: #DCDCCC;">)</span>, <span style="color: #DCDCCC;">(</span><span style="color: #cae682;">*.</span><span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Maybe</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Maybe</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Maybe</span> <span style="color: #92a65e; font-weight: bold;">Float</span>
<span style="color: #DCDCCC;">(</span><span style="color: #cae682;">+.</span><span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">=</span> errorAware <span style="color: #DCDCCC;">(</span><span style="color: #cae682;">+</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span><span style="color: #cae682;">*.</span><span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">=</span> errorAware <span style="color: #DCDCCC;">(</span><span style="color: #cae682;">*</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
Esto nos permite hacer cálculos con ellas:
</p>

<pre class="example">
λ&gt; sqroot' (-3) +. Just 4
Nothing
λ&gt; sqroot' 3 +. Just 4
Just 5.732143
</pre>
</div>
</div>

<div id="outline-container-orgf15e44d" class="outline-3">
<h3 id="orgf15e44d">La mónada Maybe</h3>
<div class="outline-text-3" id="text-orgf15e44d">
<p>
Esta idea para simplificar el tratamiento de errores, realizada
correctamente, es lo que nos va a proporcionar la estructura de mónada.
En Haskell, podemos definir una mónada como:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">Monad</span> m <span style="color: #8ac6f2; font-weight: bold;">where</span>
  <span style="color: #DCDCCC;">(</span><span style="color: #cae682;">&gt;&gt;=</span><span style="color: #DCDCCC;">)</span>  <span style="color: #cae682;">::</span> m a <span style="color: #cae682;">-&gt;</span> <span style="color: #DCDCCC;">(</span>a <span style="color: #cae682;">-&gt;</span> m b<span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">-&gt;</span> m b
  return <span style="color: #cae682;">::</span> a <span style="color: #cae682;">-&gt;</span> m a
</pre>
</div>

<p>
La idea intuitiva es que <code>(&gt;&gt;</code>)= nos permite tomar una función que puede
devolver errores pero que no comprueba a la entrada si ha recibido un
error, es decir, de tipo <code>(a -&gt; Maybe b)</code> ; y aplicarla sobre una
función que puede contener un error. La podríamos usar por ejemplo para
componer varias <code>sqroot'</code>, que era algo que hasta ahora no podíamos
hacer sin tratar cada posible caso de error. Y la función <code>return</code>, que
en este caso es simplemente <code>Just</code>, nos permite considerar una constante
como un posible error. Podemos calcular fácilmente así
<object type="image/svg+xml" data="ltximg/blog_f30a3f4f8c41427a1679b4783e4f1744a248b35d.svg" class="org-svg">
Sorry, your browser does not support SVG.</object> teniendo en cuenta los casos de error:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #cae682;">sqroot'</span> <span style="color: #DCDCCC;">(</span>sqroot' 3<span style="color: #DCDCCC;">)</span>              <span style="color: #5F7F5F;">-- </span><span style="color: #99968b;">&#161;Error de tipos!</span>
<span style="color: #cae682;">sqroot'</span> 3 <span style="color: #cae682;">&gt;&gt;=</span> sqroot'            <span style="color: #5F7F5F;">-- </span><span style="color: #99968b;">Usando m&#243;nadas</span>
<span style="color: #92a65e; font-weight: bold;">Just</span>   3 <span style="color: #cae682;">&gt;&gt;=</span> sqroot' <span style="color: #cae682;">&gt;&gt;=</span> sqroot' <span style="color: #5F7F5F;">-- </span><span style="color: #99968b;">Usando Just</span>
<span style="color: #cae682;">return</span> 3 <span style="color: #cae682;">&gt;&gt;=</span> sqroot' <span style="color: #cae682;">&gt;&gt;=</span> sqroot' <span style="color: #5F7F5F;">-- </span><span style="color: #99968b;">Equivalente a lo anterior</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdbfff86" class="outline-3">
<h3 id="orgdbfff86">Notación do</h3>
<div class="outline-text-3" id="text-orgdbfff86">
<p>
Las mónadas definen las funciones anteriores y muchas más que no vamos a
tratar ahora mismo, pero como resultado, nos acaban ofreciendo la
<b><a href="https://en.wikibooks.org/wiki/Haskell/do_notation">notación do</a></b>,
que es la que podemos usar para acabar escribiendo nuestra función
<code>solve</code> como:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #cae682;">solve</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">QPol</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Maybe</span> <span style="color: #DCDCCC;">(</span><span style="color: #92a65e; font-weight: bold;">Float</span>,<span style="color: #92a65e; font-weight: bold;">Float</span><span style="color: #DCDCCC;">)</span>
<span style="color: #cae682;">solve</span> <span style="color: #DCDCCC;">(</span><span style="color: #92a65e; font-weight: bold;">QPol</span> a b c<span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">=</span> <span style="color: #8ac6f2; font-weight: bold;">do</span>
  discriminant <span style="color: #cae682;">&lt;-</span> sqroot' <span style="color: #DCDCCC;">(</span>b<span style="color: #cae682;">*</span>b <span style="color: #cae682;">-</span> 4<span style="color: #cae682;">*</span>c<span style="color: #cae682;">*</span>a<span style="color: #DCDCCC;">)</span>
  return <span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">(</span><span style="color: #cae682;">-</span>b<span style="color: #D0BF8F;">)</span> <span style="color: #cae682;">+</span> discriminant<span style="color: #BFEBBF;">)</span><span style="color: #cae682;">/</span><span style="color: #BFEBBF;">(</span>2<span style="color: #cae682;">*</span>a<span style="color: #BFEBBF;">)</span>, <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">(</span><span style="color: #cae682;">-</span>b<span style="color: #D0BF8F;">)</span> <span style="color: #cae682;">-</span> discriminant<span style="color: #BFEBBF;">)</span><span style="color: #cae682;">/</span><span style="color: #BFEBBF;">(</span>2<span style="color: #cae682;">*</span>a<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
En la primera línea tenemos en cuenta que la función <code>sqroot</code> puede
producir error, y en la segunda simplemente usamos el <i>posible</i>
resultado de ella sin tener que preocuparnos por el resto de funciones.
</p>

<p>
Nótese que la notación <b>do</b> es sólo una notación diseñada para aliviar
la escritura de operaciones con mónadas en algunos casos particulares;
es sólo <i>azúcar sintáctico</i> para operaciones que no dejan de ser
puramente funcionales. Existen críticas al uso de esta notación. [1]
</p>
</div>
</div>
</div>

<div id="outline-container-org83eec4b" class="outline-2">
<h2 id="org83eec4b">Mónadas en programación funcional</h2>
<div class="outline-text-2" id="text-org83eec4b">
</div>
<div id="outline-container-org4e0ffc6" class="outline-3">
<h3 id="org4e0ffc6">Mónadas como clase de tipos</h3>
<div class="outline-text-3" id="text-org4e0ffc6">
<p>
Las mónadas en Haskell están definidas como una clase de tipos teniendo:
</p>

<ul class="org-ul">
<li>Un <b>constructor</b> de tipos <code>m ∷ * -&gt; *</code>, que para cada tipo <code>a</code>,
devuelve una mónada conteniéndolo, <code>m a</code>.</li>
<li>Una <b>función</b> <code>return ∷ a -&gt; m a</code>, que para todo elemento de tipo
<code>a</code>, devuelve una mónada que lo contiene.</li>
<li>Una <b>función</b> <code>(&gt;&gt;=) ∷ m a -&gt; (a -&gt; m b) -&gt; m b</code>, que dada una
mónada y una función que se aplique sobre su interior y devuelva otra
mónada, devuelve la mónada resultante. Sirve como composición de
funciones monádicas.</li>
</ul>

<p>
La existencia de la última función equivale a la existencia de otras dos
funciones <code>fmap ∷ (a -&gt; b) -&gt; m a -&gt; m b</code> y <code>join ∷ m (m a) -&gt; m a</code>.
</p>

<p>
Nótese entonces que para ser mónada, una clase de tipos debe ser primero
un funtor. Dentro de los funtores que conocemos, podemos reconocer
algunas mónadas, incluyendo la mónada <code>Maybe</code> que hemos usado hasta
ahora:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #5F7F5F;">-- </span><span style="color: #99968b;">Return de la m&#243;nada Maybe</span>
<span style="color: #cae682;">return</span> x <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Just</span> x

<span style="color: #5F7F5F;">-- </span><span style="color: #99968b;">Bind de la m&#243;nada Maybe</span>
<span style="color: #DCDCCC;">(</span><span style="color: #92a65e; font-weight: bold;">Just</span> x<span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">&gt;&gt;=</span> k <span style="color: #cae682;">=</span> k x
<span style="color: #92a65e; font-weight: bold;">Nothing</span>  <span style="color: #cae682;">&gt;&gt;=</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Nothing</span>

<span style="color: #5F7F5F;">-- </span><span style="color: #99968b;">Return de la m&#243;nada List</span>
<span style="color: #cae682;">return</span> x <span style="color: #cae682;">=</span> <span style="color: #DCDCCC;">[</span>x<span style="color: #DCDCCC;">]</span>

<span style="color: #5F7F5F;">-- </span><span style="color: #99968b;">Bind de la m&#243;nada List</span>
xs <span style="color: #cae682;">&gt;&gt;=</span> f <span style="color: #cae682;">=</span> <span style="color: #DCDCCC;">[</span>y <span style="color: #cae682;">|</span> x <span style="color: #cae682;">&lt;-</span> xs, y <span style="color: #cae682;">&lt;-</span> f x<span style="color: #DCDCCC;">]</span>
</pre>
</div>

<p>
Puedes empezar a leer tutoriales sobre el uso de las mónadas en Haskell
en:
</p>

<ul class="org-ul">
<li><a href="http://learnyouahaskell.com/a-fistful-of-monads">A fistful of monads - Learn you a Haskell</a></li>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Understanding_monads">Understanding monads - Wikibooks</a></li>
</ul>
</div>
</div>

<div id="outline-container-org459e4e3" class="outline-3">
<h3 id="org459e4e3">Mónada lista</h3>
<div class="outline-text-3" id="text-org459e4e3">
<p>
En las listas, por ejemplo, tenemos como candidato para
<code>join :: [[a]] -&gt; [a]</code> la concatenación de listas, <code>concat</code>. Nuestro
<code>return :: a -&gt; [a]</code> será simplemente incluir un elemento en una lista
que sólo lo contenga a él.
</p>

<p>
En esta mónada, <code>(&gt;&gt;</code>)= mapea una función <code>a -&gt; [a]</code> sobre cada elemento
de la lista y concatena todos los resultados:
</p>

<pre class="example">
λ&gt; [1,2,3] &gt;&gt;= (replicate 3)
[1,1,1,2,2,2,3,3,3]
</pre>

<p>
Nótese que, de la misma manera en la que podemos usar <code>(&gt;&gt;</code>)=, podemos
usar una versión con sus parámetros cambiados de orden, <code>(=&lt;&lt;)</code>. Aquí
usamos la mónada lista para enumerar los racionales repitiendo
elementos:[2]
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8ac6f2; font-weight: bold;">import</span> <span style="color: #92a65e; font-weight: bold;">Data.List</span>
<span style="color: #8ac6f2; font-weight: bold;">import</span> <span style="color: #92a65e; font-weight: bold;">Data.Ratio</span>

<span style="color: #5F7F5F;">-- </span><span style="color: #99968b;">Crea los racionales con denominador n</span>
<span style="color: #cae682;">withDenom</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Integral</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #DCDCCC;">[</span><span style="color: #92a65e; font-weight: bold;">Rational</span><span style="color: #DCDCCC;">]</span>
<span style="color: #cae682;">withDenom</span> n <span style="color: #cae682;">=</span> map <span style="color: #DCDCCC;">(</span><span style="color: #cae682;">%</span>n<span style="color: #DCDCCC;">)</span> <span style="color: #DCDCCC;">[</span>1<span style="color: #cae682;">..</span><span style="color: #DCDCCC;">]</span>

<span style="color: #5F7F5F;">-- </span><span style="color: #99968b;">Para cada entero, crea los racionales que lo</span>
<span style="color: #5F7F5F;">-- </span><span style="color: #99968b;">tienen como denominador</span>
<span style="color: #cae682;">rationalsDup</span> <span style="color: #cae682;">::</span> <span style="color: #DCDCCC;">[</span><span style="color: #92a65e; font-weight: bold;">Rational</span><span style="color: #DCDCCC;">]</span>
<span style="color: #cae682;">rationalsDup</span> <span style="color: #cae682;">=</span> withDenom <span style="color: #cae682;">=&lt;&lt;</span> <span style="color: #DCDCCC;">[</span>1<span style="color: #cae682;">..</span><span style="color: #DCDCCC;">]</span>

<span style="color: #5F7F5F;">-- </span><span style="color: #99968b;">Evita duplicados con 'nub'</span>
<span style="color: #cae682;">rationals</span> <span style="color: #cae682;">::</span> <span style="color: #DCDCCC;">[</span><span style="color: #92a65e; font-weight: bold;">Rational</span><span style="color: #DCDCCC;">]</span>
<span style="color: #cae682;">rationals</span> <span style="color: #cae682;">=</span> nub rationalsDup
</pre>
</div>
</div>
</div>

<div id="outline-container-org9f1d6fb" class="outline-3">
<h3 id="org9f1d6fb">Mónada IO</h3>
<div class="outline-text-3" id="text-org9f1d6fb">
<p>
La mónada IO surge como una solución al problema de implementar efectos
secundarios (como la lectura o escritura) en un lenguaje puro y de forma
extensible, sin tener que alterar el sistema de tipos y respetando el
orden en el que queremos que se ejecuten.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #cae682;">greeting</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">IO</span> <span style="color: #DCDCCC; font-weight: bold;">()</span>
<span style="color: #cae682;">greeting</span> <span style="color: #cae682;">=</span> fmap <span style="color: #DCDCCC;">(</span><span style="color: #95e454;">"Hola, "</span><span style="color: #cae682;">++</span><span style="color: #DCDCCC;">)</span> getLine <span style="color: #cae682;">&gt;&gt;=</span> print
</pre>
</div>

<p>
Pueden leerse más detalles sobre mónada IO y su implementación en:
</p>

<ul class="org-ul">
<li><a href="http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/">IO is pure</a> - Chris Taylor</li>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/1993/01/imperative.pdf">Imperative functional programming</a> - Simon L. Peyton Jones, Philip Wadler</li>
<li><a href="https://blog.jle.im/entry/first-class-statements">First-Class “Statements”</a> - Justin Le</li>
</ul>
</div>
</div>

<div id="outline-container-org19dc04a" class="outline-3">
<h3 id="org19dc04a">Mónada estado</h3>
<div class="outline-text-3" id="text-org19dc04a">
<p>
En ocasiones necesitamos que nuestras funciones conserven un estado
además de realizar sus operaciones. Para esos casos existe la mónada
estado <code>State s</code>, que guarda un valor de estado de tipo <code>s</code>. Podemos
pensar en <code>State s a</code> como <code>s -&gt; (a,s)</code>; es decir, un elemento dentro de
la mónada es una función dispuesta a tomar un estado inicial y a
devolver algún elemento junto a un estado final.
</p>

<p>
Existen tutoriales sobre la mónada estado en:
</p>

<ul class="org-ul">
<li><a href="https://wiki.haskell.org/State_Monad">State Monad - Haskell wiki</a></li>
<li><a href="http://learnyouahaskell.com/for-a-few-monads-more">For a few monads more - Learn you a Haskell</a></li>
<li><a href="http://brandon.si/code/the-state-monad-a-tutorial-for-the-confused/">The State Monad: a tutorial for the confused - Brandon Simmons</a></li>
<li><a href="http://adit.io/posts/2013-06-10-three-useful-monads.html">Three useful monads - Aditya Bhargava</a></li>
</ul>

<p>
Un uso de la mónada estado puede ser el guardar la semilla de una
generación pseudoaleatoria de números usando
<a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">generadores lineales congruenciales</a>. En concreto, usaremos la fórmula iterativa
<object type="image/svg+xml" data="ltximg/blog_90f45ab9fa569634c21521061bff7463e273ab09.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>, que se expone <a href="https://math.dartmouth.edu/archive/m20f11/public_html/RANDOMNESS_LCG.pdf">aquí</a>.
Con este generador podremos escribir dados de un número dado de caras y
llamarlos varias veces. El estado interno pasará la semilla aleatoria de
un dado al siguiente:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8ac6f2; font-weight: bold;">import</span> <span style="color: #92a65e; font-weight: bold;">Control.Monad.State</span>
<span style="color: #8ac6f2; font-weight: bold;">type</span> <span style="color: #92a65e; font-weight: bold;">Seed</span> <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Int</span>

<span style="color: #cae682;">dice</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Int</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">State</span> <span style="color: #92a65e; font-weight: bold;">Seed</span> <span style="color: #92a65e; font-weight: bold;">Int</span>
<span style="color: #cae682;">dice</span> n <span style="color: #cae682;">=</span> state <span style="color: #DCDCCC;">(</span><span style="color: #cae682;">\</span>s <span style="color: #cae682;">-&gt;</span> <span style="color: #BFEBBF;">(</span>s <span style="color: #cae682;">`mod`</span> n <span style="color: #cae682;">+</span> 1, 16807<span style="color: #cae682;">*</span>s <span style="color: #cae682;">`mod`</span> 2147483647<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
Y podríamos llamarlo con la semilla <code>1000</code> de la forma siguiente; que
nos devolverá por un lado el resultado de la tirada y por otro lado la
nueva semilla:
</p>

<pre class="example">
λ&gt; runState (dice 6) 1000
(5,1660)
</pre>

<p>
Si queremos hacer varias tiradas seguidas, podemos usar
<code>replicateM :: Int -&gt; m a -&gt; m [a]</code>, que se encarga de pasar
internamente la semilla de cada tirada a la siguiente tirada:
</p>

<pre class="example">
λ&gt; fst (runState (replicateM 100 (dice 6)) 1037)

[6,6,2,5,4,3,6,1,4,6,3,6,4,4,6,3,5,1,5,2,6,4,2,6,4,2,4,
5,1,6,5,4,1,3,5,4,6,4,2,3,4,2,1,1,6,5,5,4,1,1,4,6,5,3,6,
3,1,1,5,1,4,1,2,3,5,5,4,5,3,3,2,6,4,1,1,1,2,5,4,5,2,4,5,
6,1,2,4,3,3,6,4,6,3,4,5,1,4,2,2,2]
</pre>

<p>
Incluso podemos crear nuevos generadores aleatorios a partir de los
anteriores con las operaciones usuales:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #cae682;">twodices</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">State</span> <span style="color: #92a65e; font-weight: bold;">Seed</span> <span style="color: #92a65e; font-weight: bold;">Int</span>
<span style="color: #cae682;">twodices</span> <span style="color: #cae682;">=</span> <span style="color: #8ac6f2; font-weight: bold;">do</span>
    a <span style="color: #cae682;">&lt;-</span> dice 6
    b <span style="color: #cae682;">&lt;-</span> dice 6
    return <span style="color: #DCDCCC;">(</span>a<span style="color: #cae682;">+</span>b<span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
Cuando lo llamemos, tomará la distribución suma de las dos
distribuciones de dados:
</p>

<pre class="example">
λ&gt; fst (runState (replicateM 100 twodices) 1032)

[8,11,8,8,5,3,7,8,9,5,2,6,7,9,8,7,5,9,3,9,10,7,7,10,
8,2,5,6,4,10,8,6,4,6,4,8,9,7,12,11,9,3,2,7,5,5,6,10,
6,6,3,11,4,7,3,6,3,7,10,4,4,11,4,10,3,5,2,8,4,10,12,
8,9,5,9,11,6,4,10,6,6,12,5,2,7,8,7,4,4,4,9,6,6,6,3,
11,11,9,7,6]
</pre>
</div>
</div>
</div>

<div id="outline-container-org8a028eb" class="outline-2">
<h2 id="org8a028eb">Mónadas en teoría de categorías</h2>
<div class="outline-text-2" id="text-org8a028eb">
<p>
Para entender cómo funcionan las <a href="https://es.wikipedia.org/wiki/M%C3%B3nada_(teor%C3%ADa_de_categor%C3%ADas)">mónadas</a>
en teoría de categorías tenemos que entender dos conceptos: los
<i>productos en una <a href="https://es.wikipedia.org/wiki/Categor%C3%ADa_monoidal">categoría monoidal</a></i> y <i>los endofuntores de una categoría</i>. 
La unión de ambos conceptos es lo que nos dará las mónadas como una 
construcción en teoría de categorías.
</p>
</div>

<div id="outline-container-org5a5b3e9" class="outline-3">
<h3 id="org5a5b3e9">Categorías monoidales</h3>
<div class="outline-text-3" id="text-org5a5b3e9">
<p>
Simplificando, una categoría monoidal es aquella donde, dados dos
objetos <object type="image/svg+xml" data="ltximg/blog_a01269075d90dce237e31285ae88426ba0677115.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>, tenemos un objeto <i>"producto tensor"</i> de ambos,
<object type="image/svg+xml" data="ltximg/blog_8d17961032dc1a3881c2602b066e2b290f01f42f.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>, donde además existe un objeto identidad <object type="image/svg+xml" data="ltximg/blog_4b0d568b291c427030e103d3984e36cdd99dd2da.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
cumpliendo propiedades como:
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_ee69ffa08697825fb4cacd05965751a00ab16435.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_31cb068f9dd4e118a230fa3d91afc81604aceb8e.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_eca81a277fd6133b46309f2cf57a1fb662a8075d.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>

<div id="outline-container-org605f729" class="outline-3">
<h3 id="org605f729">Ejemplos de categorías monoidales</h3>
<div class="outline-text-3" id="text-org605f729">
<p>
Los <b>conjuntos</b> con el producto cartesiano y el conjunto de un elemento
forman ya una categoría monoidal. Puede comprobarse sobre ellos que
existen los isomorfismos:
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_a89fef5526eb908192438c8979c1d814f54d14e9.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_c14962ab886de6d033f92a8e1dc7fe2624fc32d2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_11b9441f9f8f5f2c43f9350001558cebbeb1b41e.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<p>
Pero además, podemos darles <i>otra</i> estructura de categoría monoidal,
esta vez con la <a href="https://es.wikipedia.org/wiki/Uni%C3%B3n_disjunta">unión disjunta</a> y el conjunto vacío:
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_83666981f52a4c2856bce7e96ba2d0152f33b3fb.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_124b4b0d821fade7175eddcd46958c4261595388.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_6f3c0a282991ded7d0ba17aaf1d174f769bfd8ae.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<p>
En general, <b>todas las categorías con productos finitos son categorías
monoidales</b> con el producto categórico y el objeto terminal como unidad.
Todas las categorías con coproductos finitos son categorías monoidales
con el coproducto categórico y el objeto inicial como unidad.
</p>

<p>
Otro ejemplo distinto lo forman los <b>espacios vectoriales</b> sobre un
cuerpo <object type="image/svg+xml" data="ltximg/blog_59ec631c3bfe0a0ae9a98d858abd9a2ab62d3250.svg" class="org-svg">
Sorry, your browser does not support SVG.</object> con el producto tensor y el propio cuerpo sirviendo como
unidad; o los <b>grupos abelianos</b> con el producto tensor y <object type="image/svg+xml" data="ltximg/blog_9c4152584560b3c62a78252d0bbe2c6612470f3b.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
siendo la unidad.
</p>
</div>
</div>

<div id="outline-container-orgd68d3d1" class="outline-3">
<h3 id="orgd68d3d1">Objetos monoide</h3>
<div class="outline-text-3" id="text-orgd68d3d1">
<p>
Un objeto <object type="image/svg+xml" data="ltximg/blog_8c5c7b238da7a1cfc3df49d7bd6409b6bd865040.svg" class="org-svg">
Sorry, your browser does not support SVG.</object> de una categoría monoidal es objeto monoide cuando puedo
definir un morfismo desde el objeto identidad hacia él y un morfismo
desde el producto tensor <object type="image/svg+xml" data="ltximg/blog_be94d5e6e7475a5ef4249be332e604819baac630.svg" class="org-svg">
Sorry, your browser does not support SVG.</object> hacia él. Es decir, hay un
morfismo <i>unidad</i>, <object type="image/svg+xml" data="ltximg/blog_b10b6bb20388a132325cc20b898be4de63a2a3da.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>; y hay un morfismo <i>multiplicación</i>,
<object type="image/svg+xml" data="ltximg/blog_6cd58b727261b7bec4ac04aad9e154789c0a0dc3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>.
</p>

<p>
Cumpliendo ciertas propiedades similares a las que exigimos a un
monoide. De hecho, un objeto monoide en la categoría de los conjuntos
con el producto cartesiano es simplemente un <b>monoide</b> normal y
corriente.
</p>
</div>
</div>

<div id="outline-container-orgdb34792" class="outline-3">
<h3 id="orgdb34792">Categorías de endofuntores</h3>
<div class="outline-text-3" id="text-orgdb34792">
<p>
El ejemplo que nos interesa ahora, sin embargo, es el de los
<b>endofuntores</b> de una categoría. Un <b>funtor</b>, de forma simplificada, es
una <i>aplicación entre categorías</i>; que lleva objetos en objetos y
morfismos en morfismos, respetando además el punto de inicio y fin de
cada morfismo.
</p>

<p>
Si consideramos los funtores de una categoría a sí misma, tenemos los
<b>endofuntores</b> de la categoría. Y entre ellos existen transformaciones
naturales que actúan como morfismos en el sentido de que se componen
para dar otras transformaciones naturales. Teniendo unos objetos (los
endofuntores), y unos morfismos (las transformaciones naturales),
tenemos una categoría. Nótese que hemos abstraído mucho, estamos
trabajando con una categoría en la que cada objeto es en sí mismo un
endofuntor y cada morfismo es toda una transformación natural entre dos
funtores.
</p>

<p>
Esta es además una categoría monoidal. El producto tensor de esta
categoría monoidal será la composición <object type="image/svg+xml" data="ltximg/blog_91d39062fc87cf599cc62e6534a7a22583a3be5f.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>, y el objeto identidad
el endofuntor identidad, que actúa dejando fijo cada objeto y cada
morfismo.
</p>
</div>
</div>

<div id="outline-container-org93074e3" class="outline-3">
<h3 id="org93074e3">Mónadas</h3>
<div class="outline-text-3" id="text-org93074e3">
<p>
Pues bien, una mónada es un objeto monoide en la categoría de los
endofuntores con la composición como producto tensor. Esto quiere decir
que es un endofuntor <object type="image/svg+xml" data="ltximg/blog_260cb28a7ffd1e67e4783000df3f911c669b0f06.svg" class="org-svg">
Sorry, your browser does not support SVG.</object> con transformaciones naturales:
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_eedcac8f0cea3ebbefa0762da3bf7814c47efc6e.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_8ed3e38519a607eb9b038a1a865d8622be0d982e.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<p>
Como una transformación natural nos da un morfismo por cada objeto en el
que se aplica el funtor, lo que tenemos son familias de morfismos:
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_a27e056c623e964a8ffa6e5d8d6b63fc273db68f.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<p>
<object type="image/svg+xml" data="ltximg/blog_b18b4f5c1a0e5bf7808083217bbf7d501dd97dc9.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>

<div id="outline-container-org9d891ed" class="outline-3">
<h3 id="org9d891ed">Una categoría para la programación funcional</h3>
<div class="outline-text-3" id="text-org9d891ed">
<p>
Algunos sistemas de tipos, con las funciones entre ellos <code>A -&gt; B</code> como
morfismos, forman una categoría[3]. No es el caso de Haskell, en el que,
por varios motivos, sus tipos no forman una categoría[4]; pero las
construcciones con inspiración en la teoría de categorías toman el
nombre de sus homólogas.[5]
</p>

<p>
El primer ejemplo de esto son los <b>funtores</b>. En Haskell, un funtor se
define como:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">Functor</span> f <span style="color: #8ac6f2; font-weight: bold;">where</span> 
  fmap <span style="color: #cae682;">::</span> <span style="color: #DCDCCC;">(</span>a <span style="color: #cae682;">-&gt;</span> b<span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">-&gt;</span> f a <span style="color: #cae682;">-&gt;</span> f b 
</pre>
</div>

<p>
Es decir un funtor toma un tipo <code>a</code> (un objeto de la categoría), y nos
devuelve otro tipo <code>f a</code> (otro objeto de la <i>misma</i> categoría). Por otro
lado, el funtor toma un morfismo <code>a -&gt; b</code> y nos devuelve otro morfismo
<code>f a -&gt; f b</code>. Es decir, los funtores de la programación funcional son
<b>endofuntores en la categoría de los tipos</b>, siempre que conserven
ciertas reglas que tienen su reflejo en las reglas de funtores en
Haskell.
</p>
</div>
</div>

<div id="outline-container-orgeafe059" class="outline-3">
<h3 id="orgeafe059">Monoides en la categoría de los endofuntores</h3>
<div class="outline-text-3" id="text-orgeafe059">
<p>
Entonces, si los funtores <code>f :: * -&gt; *</code> son endofuntores en alguna
categoría, tiene sentido cuestionarse cuáles de ellos son monoides.
Esto, junto con ciertas restricciones que se le imponen como leyes a las
mónadas, equivale a decir que existen los morfismos dados por las
transformaciones naturales que pedíamos antes, es decir, deben existir
morfismos de tipos <code>a -&gt; m a</code> y <code>m (m a) -&gt; m a</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #cae682;">return</span> <span style="color: #cae682;">::</span> a <span style="color: #cae682;">-&gt;</span> m a
<span style="color: #cae682;">join</span> <span style="color: #cae682;">::</span> m <span style="color: #DCDCCC;">(</span>m a<span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">-&gt;</span> m a
</pre>
</div>

<p>
Así, a cualquier funtor que tiene estos dos morfismos, además del <code>fmap</code>
que tenía por ser funtor, lo llamamos <b>mónada</b>. Nótese que <code>&gt;&gt;=</code> puede
implementarse desde <code>join</code> y viceversa, como:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #DCDCCC;">(</span><span style="color: #cae682;">&gt;&gt;=</span><span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">::</span> m a <span style="color: #cae682;">-&gt;</span> <span style="color: #DCDCCC;">(</span>a <span style="color: #cae682;">-&gt;</span> m b<span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">-&gt;</span> m b
<span style="color: #DCDCCC;">(</span><span style="color: #cae682;">&gt;&gt;=</span><span style="color: #DCDCCC;">)</span> x f <span style="color: #cae682;">=</span> join <span style="color: #DCDCCC;">(</span>fmap f a<span style="color: #DCDCCC;">)</span>

<span style="color: #cae682;">join</span> <span style="color: #cae682;">::</span> m <span style="color: #DCDCCC;">(</span>m a<span style="color: #DCDCCC;">)</span> <span style="color: #cae682;">-&gt;</span> m a
<span style="color: #cae682;">join</span> x <span style="color: #cae682;">=</span> x <span style="color: #cae682;">&gt;&gt;=</span> id
</pre>
</div>

<p>
Tenemos entonces dos definiciones equivalentes de lo que es una mónada.
Una desde la teoría de categorías y otra desde la teoría de tipos y los
lenguajes de programación funcional. Una visión desde las mónadas como
monoides en la categoría de los endofuntores desde dentro de Haskell
puede verse <a href="http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html">aquí</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-org3977d73" class="outline-2">
<h2 id="org3977d73">Y más</h2>
<div class="outline-text-2" id="text-org3977d73">
<p>
Además de las enunciadas en este post, existen más otros temas
relevantes en relación a las mónadas, tanto en programación funcional
como en teoría de categorías:
</p>

<ul class="org-ul">
<li><a href="http://book.realworldhaskell.org/read/monad-transformers.html">Transformadores de mónadas</a>, usadas para componer mónadas.</li>
<li><a href="http://stackoverflow.com/questions/8428554/what-is-the-comonad-typeclass-in-haskell">Comónadas</a>, la noción dual de una mónada.</li>
<li><a href="https://en.wikipedia.org/wiki/Kleisli_category">Categorías de Kleisli</a>, cada mónada da lugar a una categoría de Kleisli.</li>
<li><a href="https://en.wikipedia.org/wiki/Adjoint_functors">Funtores adjuntos</a>, cada par de funtores adjuntos da lugar a una mónada.</li>
<li><a href="http://www.cs.tufts.edu/comp/150FP/archive/brent-yorgey/tc.pdf">Typeclassopedia</a>, una revisión de otras clases de tipos relevantes en Haskell y
relacionadas con la teoría de categorías.</li>
</ul>
</div>
</div>

<div id="outline-container-org72c0d00" class="outline-2">
<h2 id="org72c0d00">Referencias</h2>
<div class="outline-text-2" id="text-org72c0d00">
<p>
[1] Peligros de la notación do.
    <a href="https://wiki.haskell.org/Do_notation_considered_harmful">Do notation considered harmful</a>
</p>

<p>
[2] Enumerando los racionales.
    <a href="http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/rationals.pdf">Enumerating the rationals - J. Gibbons, D. Lester, R. Bird</a>
</p>

<p>
[3] La correspondencia entre tipos, lógica y categorías.
    <a href="https://ncatlab.org/nlab/show/computational+trinitarianism">Computational Trinitarianism - NLab</a>
</p>

<p>
[4] Por qué los tipos de Haskell no son una categoría.
    <a href="http://math.andrej.com/2016/08/06/hask-is-not-a-category/">Hask is not a category - Andrej Bauer</a>
</p>

<p>
[5] Por qué en ocasiones puede ser útil pensar en ellos como una
    categoría.
    <a href="https://ro-che.info/articles/2016-08-07-hask-category">Does it matter if Hask is (not) a category?</a></p>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="footer"><p class="postamble">Last edited 2016-12-24 Sat 15:09. Written by <a href="https://mroman42.github.com">@mroman42</a>.</p></div>
</div>
</body>
</html>
