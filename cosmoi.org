#+Title: Cosmoi
#+Author: Mario Román
#+Email: mromang08@gmail.com
#+Creator: <a href="https://mroman42.github.com">@mroman42</a>.

#+Options: toc:nil date:t num:nil
#+Options: html-style:nil
#+Options: html-postamble:t
#+Options: tex:dvisvgm

* Header                                                                                    :ignore:
** html-header                                                                             :ignore:
#+HTML_HEAD: <link rel="stylesheet" href="default.css" />
#+HTML_HEAD: <link rel="stylesheet" href="mathjax_fonts.css" />
#+HTML_HEAD: <link rel="stylesheet" href="syntax.css" />

#+HTML_HEAD: <div id="header">
#+HTML_HEAD:     <div id="logo">
#+HTML_HEAD:         <a hrwef="index.html">Cosmoi</a>
#+HTML_HEAD:     </div>
#+HTML_HEAD:     <div id="navigation">
#+HTML_HEAD:         <a href="index.html">Index</a>
#+HTML_HEAD:         <a href="about.html">About</a>
#+HTML_HEAD:         <a href="feed.xml">RSS</a>
#+HTML_HEAD:     </div>
#+HTML_HEAD: </div>

** latex-header                                                                            :ignore:
#+latex_header: \usepackage{libertine}
#+latex_header: \usepackage[scale=0.85]{FiraMono}
#+latex_header: \usepackage{unicode-math}

#+latex_class_options: [11pt]
#+latex_header_extra: %\usepackage[top=1in, bottom=1.5in, left=1.4in, right=1.5in]{geometry}

#+latex_header_extra: \usepackage{minted} \usemintedstyle{colorful}
#+latex_header_extra: \setminted{fontsize=\small}
#+latex_header_extra: \setminted[haskell]{linenos=false,fontsize=\small}
#+latex_header_extra: \renewcommand{\theFancyVerbLine}{\sffamily\textcolor[rgb]{0.5,0.5,1.0}{\oldstylenums{\arabic{FancyVerbLine}}}}

#+latex_header: \BeforeBeginEnvironment{minted}{\vspace{-0.5cm}}
#+latex_header: \AfterEndEnvironment{minted}{\vspace{-0.2cm}}

#+latex_header: \usepackage{CJKutf8}\usepackage[utf8]{inputenc} 
#+latex_header: \newcommand{\hirayo}{\text{\usefont{U}{min}{m}{n}\symbol{'210}}} \DeclareFontFamily{U}{min}{} \DeclareFontShape{U}{min}{m}{n}{<-> udmj30}{}
#+latex_header: \setcounter{secnumdepth}{0}
#+latex_header: %\setlength{\parindent}{0pt}
#+latex_header: \usepackage{physics}
#+latex_header: \usepackage{amsthm}
#+latex_header: \usepackage{amsmath}
#+latex_header: \usepackage{amssymb}\usepackage{bbm}
#+latex_header: \usepackage{amsbsy}
#+latex_header: \usepackage{bm}
#+latex_header: \usepackage{stmaryrd}
#+latex_header: \usepackage{mathtools}
#+latex_header: \usepackage{mathabx}
#+latex_header: \usepackage{color}
#+latex_header: \usepackage{bussproofs}\EnableBpAbbreviations{}
#+latex_header: \usepackage{tikz}
#+latex_header: \usepackage{tikz-cd}
#+latex_header: \usepackage{bussproofs} \EnableBpAbbreviations{}
#+latex_header: \usepackage[makeroom]{cancel}
#+latex_header: \usepackage{multicol}
#+latex_header: \usepackage{pmboxdraw}\usepackage{ucs}
#+latex_header: \usepackage{pdfpages} \usepackage[export]{adjustbox}
#+latex_header: \usepackage{wrapfig}

#+latex_header: \DeclareMathOperator{\im}{Im}
#+latex_header: \DeclareMathOperator{\coker}{Coker}
#+latex_header: \DeclareMathOperator{\spec}{Spec}
#+latex_header: \DeclarePairedDelimiter\bbk{\llbracket}{\rrbracket}
#+latex_header: \newcommand{\vertiii}[1]{{\left\vert\kern-0.25ex\left\vert\kern-0.25ex\left\vert #1 \right\vert\kern-0.25ex\right\vert\kern-0.25ex\right\vert}}
#+latex_header: \newcommand{\nnorm}[1]{{\left\vert\kern-0.25ex\left\vert\kern-0.25ex\left\vert #1 \right\vert\kern-0.25ex\right\vert\kern-0.25ex\right\vert}}

#+latex_header: \newcommand\id{\mathrm{id}}
#+latex_header: \newcommand\Id{\mathrm{Id}}
#+latex_header: \newcommand\hom{\mathrm{hom}}
#+latex_header: \newcommand\Nat{\mathrm{Nat}}
#+latex_header: \newcommand\Grp{\mathsf{Grp}}
#+latex_header: \newcommand\Set{\mathsf{Set}}
#+latex_header: \newcommand\zet{\mathbb{Z}}
#+latex_header: \newcommand\nat{\mathbb{N}}
#+latex_header: \newcommand\rat{\mathbb{Q}}
#+latex_header: \newcommand\reals{\mathbb{R}}
#+latex_header: \newcommand\com{\mathbb{C}}
#+latex_header: \newcommand\hC{\widehat{\cal C}}
#+latex_header: \newcommand\todot{\xrightarrow{.}}
#+latex_header: \newcommand\tonat{\Rightarrow}
#+latex_header: \usepackage{mathtools}
#+latex_header: \DeclarePairedDelimiter\pair{\langle}{\rangle}

#+latex_header: \DeclarePairedDelimiter\abs{\lvert}{\rvert}%
#+latex_header: \DeclarePairedDelimiter\norm{\lVert}{\rVert}%
#+latex_header: \DeclarePairedDelimiter\brck{\llbracket}{\rrbracket}%

#+latex_header: \newcommand\twoheaduparrow{\mathrel{\rotatebox{90}{$\twoheadrightarrow$}}}
#+latex_header: \newcommand\twoheaddownarrow{\mathrel{\rotatebox{90}{$\twoheadleftarrow$}}}

#+latex_header: \usepackage{amsthm}
#+latex_header: \newtheorem*{statement}{Statement}

*** Theorem styles                                                                        :ignore:
#+latex_header_extra: \theoremstyle{plain}
#+latex_header_extra: \newtheorem{theorem}{Theorem}
#+latex_header_extra: \newtheorem{proposition}[theorem]{Proposition}
#+latex_header_extra: \newtheorem{lemma}[theorem]{Lemma}
#+latex_header_extra: \newtheorem{corollary}[theorem]{Corollary}
#+latex_header_extra: \theoremstyle{definition}
#+latex_header_extra: \newtheorem{definition}[theorem]{Definition}
#+latex_header_extra: \newtheorem{definicion}[theorem]{Definición}
#+latex_header_extra: \newtheorem{axiom}[theorem]{Axiom}
#+latex_header_extra: \newtheorem{proofs}{Proof}
#+latex_header_extra: \theoremstyle{remark}
#+latex_header_extra: \newtheorem{remark}[theorem]{Remark}
#+latex_header_extra: \newtheorem{exampleth}[theorem]{Example}
#+latex_header_extra: \newtheorem{ejemplo}[theorem]{Ejemplo}
#+latex_header_extra: \begingroup\makeatletter\@for\theoremstyle:=definition,remark,plain\do{\expandafter\g@addto@macro\csname th@\theoremstyle\endcsname{\addtolength\thm@preskip\parskip}}\endgroup

#+latex_header_extra: \definecolor{greenPRL}{HTML}{078f60}
#+latex_header_extra: \hypersetup{colorlinks=true, linktocpage=true, pdfstartpage=3, pdfstartview=FitV,breaklinks=true, pdfpagemode=UseNone, pageanchor=true, pdfpagemode=UseOutlines,plainpages=false, bookmarksnumbered, bookmarksopen=true, bookmarksopenlevel=1,hypertexnames=true, pdfhighlight=/O,urlcolor=greenPRL,linkcolor=greenPRL,citecolor=greenPRL}

*** Macros on HoTT                                                                        :ignore:
#+latex_header: \newcommand\ap{\mathsf{ap}}
#+latex_header: \newcommand\apd{\mathsf{apd}}
#+latex_header: \newcommand\refl{\mathsf{refl}}
#+latex_header: \newcommand\id{\mathsf{id}}
#+latex_header: \newcommand\transport{\mathsf{transport}}
#+latex_header: \newcommand\happly{\mathsf{happly}}
#+latex_header: \newcommand\funext{\mathsf{funext}}
#+latex_header: \newcommand\proj{\mathsf{pr}}
#+latex_header: \newcommand\rec{\mathsf{rec}}
#+latex_header: \newcommand\pr{\mathsf{pr}}
#+latex_header: \newcommand\idtoeqv{\mathsf{idtoeqv}}
#+latex_header: \newcommand\ua{\mathsf{ua}}
#+latex_header: \newcommand\isSet{\mathsf{isSet}}
#+latex_header: \newcommand\isProp{\mathsf{isProp}}
#+latex_header: \newcommand\Set{\mathsf{Set}}
#+latex_header: \newcommand\Prop{\mathsf{Prop}}
#+latex_header: \newcommand\fnot{\mathsf{not}}
#+latex_header: \newcommand\LEM{\mathsf{LEM}}
#+latex_header: \newcommand\trunc[1]{\left\lVert#1\right\rVert}
#+latex_header: \newcommand\isContr{\mathsf{isContr}}
#+latex_header: \newcommand\ishae{\mathsf{ishae}}
#+latex_header: \newcommand\qinv{\mathsf{qinv}}
#+latex_header: \newcommand\fib{\mathsf{fib}}
#+latex_header: \newcommand\biinv{\mathsf{biinv}}
#+latex_header: \newcommand\linv{\mathsf{linv}}
#+latex_header: \newcommand\rinv{\mathsf{rinv}}
#+latex_header: \renewcommand\succ{\mathsf{succ}}
#+latex_header: \newcommand\isequiv{\mathsf{isequiv}}
#+latex_header: \newcommand\isHinit{\mathsf{isHinit}}
#+latex_header: \newcommand\isEmbedding{\mathsf{isEmbedding}}
#+latex_header: \newcommand\isSurjective{\mathsf{isSurjective}}
#+latex_header: \newcommand\pair{\mathsf{pair}}
#+latex_header: \newcommand\inl{\mathsf{inl}}
#+latex_header: \newcommand\inr{\mathsf{inr}}
#+latex_header: \newcommand\seg{\mathsf{seg}}
#+latex_header: \newcommand\base{\mathsf{base}}
#+latex_header: \newcommand\N{\mathsf{N}}
#+latex_header: \newcommand\conn{\mathsf{conn}}
#+latex_header: \newcommand\code{\mathsf{code}}
#+latex_header: \newcommand\encode{\mathsf{encode}}
#+latex_header: \newcommand\decode{\mathsf{decode}}
#+latex_header: \newcommand\merid{\mathsf{merid}}
#+latex_header: \newcommand\isCut{\mathsf{isCut}}
#+latex_header: \newcommand\apart{\mathbin{\#}}
#+latex_header: \newcommand\istype[1]{\mathop{\mbox{$\mathsf{is}$-$#1$-$\mathsf{type}$}}}

*** Logic macros                                                                          :ignore:
#+latex_header: \newcommand\land{\wedge}
#+latex_header: \newcommand\lor{\vee}
#+latex_header: \newcommand\model{\mathfrak{M}}
#+latex_header: \newcommand\entail{\models}
#+latex_header: \newcommand\seq{\Rightarrow}

*** Analysis                                                                              :ignore:
#+latex_header: \newcommand\oy{\overline{y}}
#+latex_header: \newcommand\tf{\tilde{f}}
#+latex_header: %\newcommand\bV{\overset{\bullet}{V}}
#+latex_header: \newcommand\bV{\dot{V}}

*** Type theory macros                                                                    :ignore:
#+latex_header: \newcommand\ap{\mathsf{ap}}
#+latex_header: \newcommand\apd{\mathsf{apd}}
#+latex_header: \newcommand\refl{\mathsf{refl}}
#+latex_header: \newcommand\id{\mathsf{id}}
#+latex_header: \newcommand\transport{\mathsf{transport}}
#+latex_header: \newcommand\happly{\mathsf{happly}}
#+latex_header: \newcommand\funext{\mathsf{funext}}
#+latex_header: \newcommand\proj{\mathsf{pr}}
#+latex_header: \newcommand\rec{\mathsf{rec}}
#+latex_header: \newcommand\pr{\mathsf{pr}}
#+latex_header: \newcommand\idtoeqv{\mathsf{idtoeqv}}
#+latex_header: \newcommand\ua{\mathsf{ua}}
#+latex_header: \newcommand\isSet{\mathsf{isSet}}
#+latex_header: \newcommand\isProp{\mathsf{isProp}}
#+latex_header: \newcommand\Set{\mathsf{Set}}
#+latex_header: \newcommand\Prop{\mathsf{Prop}}
#+latex_header: \newcommand\fnot{\mathsf{not}}
#+latex_header: \newcommand\LEM{\mathsf{LEM}}
#+latex_header: \newcommand\trunc[1]{\left\lVert#1\right\rVert}
#+latex_header: \newcommand\isContr{\mathsf{isContr}}
#+latex_header: \newcommand\ishae{\mathsf{ishae}}
#+latex_header: \newcommand\qinv{\mathsf{qinv}}
#+latex_header: \newcommand\fib{\mathsf{fib}}
#+latex_header: \newcommand\biinv{\mathsf{biinv}}
#+latex_header: \newcommand\linv{\mathsf{linv}}
#+latex_header: \newcommand\rinv{\mathsf{rinv}}
#+latex_header: \renewcommand\succ{\mathsf{succ}}
#+latex_header: \newcommand\isequiv{\mathsf{isequiv}}
#+latex_header: \newcommand\isHinit{\mathsf{isHinit}}
#+latex_header: \newcommand\isEmbedding{\mathsf{isEmbedding}}
#+latex_header: \newcommand\isSurjective{\mathsf{isSurjective}}
#+latex_header: \newcommand\pair{\mathsf{pair}}
#+latex_header: \newcommand\inl{\mathsf{inl}}
#+latex_header: \newcommand\inr{\mathsf{inr}}
#+latex_header: \newcommand\seg{\mathsf{seg}}
#+latex_header: \newcommand\base{\mathsf{base}}
#+latex_header: \newcommand\N{\mathsf{N}}
#+latex_header: \newcommand\merid{\mathsf{merid}}
#+latex_header: \newcommand\istype[1]{\mathop{\mbox{$\mathsf{is}$-$#1$-$\mathsf{type}$}}}

*** Category theory macros                                                                :ignore:
#+latex_header: \newcommand\hom{\mathrm{hom}}
#+latex_header: \newcommand\Sets{\mathsf{Sets}}
#+latex_header: \newcommand\Set{\mathsf{Set}}
#+latex_header: \newcommand\todot{\xrightarrow{.}}

*** tikz-pictures                                                                         :ignore:
# I am using Spivak-Schultz's string diagrams library! It is really
# cool and the results look very nice.

# Creative commons Attribution CC BY Work by David I. Spivak and Patrick Schultz
#
#  You are free to:
#    Share Ñ copy and redistribute the material in any medium or format
#    Adapt Ñ remix, transform, and build upon the material for any purpose, even commercially.
#
#  Under the following terms:
#    Attribution Ñ You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.
#    No additional restrictions Ñ You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.
#
#  Use at your own risk. 

#+latex_header: \usetikzlibrary{
#+latex_header:   cd,
#+latex_header:   math,
#+latex_header:   decorations.markings,
#+latex_header:   decorations.pathreplacing,
#+latex_header:   positioning,
#+latex_header:   arrows.meta,
#+latex_header:   circuits.logic.US,
#+latex_header:   shapes,
#+latex_header:   calc,
#+latex_header:   fit,
#+latex_header:   quotes}

#+latex_header: \newcommand{\tn}{\textnormal}
#+latex_header: \newcommand{\inp}[1]{#1^{\tn{in}}}
#+latex_header: \newcommand{\outp}[1]{#1^{\tn{out}}}
#+latex_header: \newcommand{\upd}[1]{#1^{\tn{upd}}}
#+latex_header: \newcommand{\rdt}[1]{#1^{\tn{rdt}}}


#+latex_header:   \tikzset{
#+latex_header:      oriented WD/.style={%everything after equals replaces "oriented WD" in key.
#+latex_header:         every to/.style={out=0,in=180,draw},
#+latex_header:         label/.style={
#+latex_header:            font=\everymath\expandafter{\the\everymath\scriptstyle},
#+latex_header:            inner sep=0pt,
#+latex_header:            node distance=2pt and -2pt},
#+latex_header:         semithick,
#+latex_header:         node distance=1 and 1,
#+latex_header:         decoration={markings, mark=at position \stringdecpos with \stringdec},
#+latex_header:         ar/.style={postaction={decorate}},
#+latex_header:         execute at begin picture={\tikzset{
#+latex_header:            x=\bbx, y=\bby,
#+latex_header:            every fit/.style={inner xsep=\bbx, inner ysep=\bby}}}
#+latex_header:         },
#+latex_header:      string decoration/.store in=\stringdec,
#+latex_header:      string decoration={\arrow{stealth};},
#+latex_header:      string decoration pos/.store in=\stringdecpos,
#+latex_header:      string decoration pos=.7,
#+latex_header:      bbx/.store in=\bbx,
#+latex_header:      bbx = 1.5cm,
#+latex_header:      bby/.store in=\bby,
#+latex_header:      bby = 1.5ex,
#+latex_header:      bb port sep/.store in=\bbportsep,
#+latex_header:      bb port sep=1.5,
#+latex_header:      % bb wire sep/.store in=\bbwiresep,
#+latex_header:      % bb wire sep=1.75ex,
#+latex_header:      bb port length/.store in=\bbportlen,
#+latex_header:      bb port length=4pt,
#+latex_header:      bb penetrate/.store in=\bbpenetrate,
#+latex_header:      bb penetrate=0,
#+latex_header:      bb min width/.store in=\bbminwidth,
#+latex_header:      bb min width=1cm,
#+latex_header:      bb rounded corners/.store in=\bbcorners,
#+latex_header:      bb rounded corners=2pt,
#+latex_header:      bb small/.style={bb port sep=1, bb port length=2.5pt, bbx=.4cm, bb min width=.4cm, 
#+latex_header: bby=.7ex},
#+latex_header: 		 bb medium/.style={bb port sep=1, bb port length=2.5pt, bbx=.4cm, bb min width=.4cm, 
#+latex_header: bby=.9ex},
#+latex_header:      bb/.code 2 args={%When you see this key, run the code below:
#+latex_header:         \pgfmathsetlengthmacro{\bbheight}{\bbportsep * (max(#1,#2)+1) * \bby}
#+latex_header:         \pgfkeysalso{draw,minimum height=\bbheight,minimum width=\bbminwidth,outer 
#+latex_header: sep=0pt,
#+latex_header:            rounded corners=\bbcorners,thick,
#+latex_header:            prefix after command={\pgfextra{\let\fixname\tikzlastnode}},
#+latex_header:            append after command={\pgfextra{\draw
#+latex_header:               \ifnum #1=0{} \else foreach \i in {1,...,#1} {
#+latex_header:                  ($(\fixname.north west)!{\i/(#1+1)}!(\fixname.south west)$) +(-
#+latex_header: \bbportlen,0) 
#+latex_header:   coordinate (\fixname_in\i) -- +(\bbpenetrate,0) coordinate (\fixname_in\i')}\fi 
#+latex_header:   %Define the endpoints of tickmarks
#+latex_header:               \ifnum #2=0{} \else foreach \i in {1,...,#2} {
#+latex_header:                  ($(\fixname.north east)!{\i/(#2+1)}!(\fixname.south east)$) +(-
#+latex_header: \bbpenetrate,0) 
#+latex_header:   coordinate (\fixname_out\i') -- +(\bbportlen,0) coordinate (\fixname_out\i)}\fi;
#+latex_header:            }}}
#+latex_header:      },
#+latex_header:      bb name/.style={append after command={\pgfextra{\node[anchor=north] at 
#+latex_header: (\fixname.north) {#1};}}}
#+latex_header:   }
#+latex_header: 
#+latex_header: 
#+latex_header:   \tikzset{
#+latex_header:   	unoriented WD/.style={
#+latex_header:   		every to/.style={draw},
#+latex_header:   		shorten <=-\penetration, shorten >=-\penetration,
#+latex_header:   		label distance=-2pt,
#+latex_header:   		thick,
#+latex_header:   		node distance=\spacing,
#+latex_header:   		execute at begin picture={\tikzset{
#+latex_header:   			x=\spacing, y=\spacing}}
#+latex_header:   		},
#+latex_header:   	pack size/.store in=\psize,
#+latex_header:   	pack size = 8pt,
#+latex_header:   	spacing/.store in=\spacing,
#+latex_header:   	spacing = 8pt,
#+latex_header:   	link size/.store in=\lsize,
#+latex_header:   	link size = 2pt,
#+latex_header: 		penetration/.store in=\penetration,
#+latex_header: 		penetration = 2pt,
#+latex_header:   	pack color/.store in=\pcolor,
#+latex_header:   	pack color = blue,
#+latex_header:   	pack inside color/.store in=\picolor,
#+latex_header:   	pack inside color=blue!20,
#+latex_header:   	pack outside color/.store in=\pocolor,
#+latex_header:   	pack outside color=blue!50!black,
#+latex_header:   	surround sep/.store in=\ssep,
#+latex_header:   	surround sep=8pt,
#+latex_header:   	link/.style={
#+latex_header:   		circle, 
#+latex_header:   		draw=black, 
#+latex_header:   		fill=black,
#+latex_header:   		inner sep=0pt, 
#+latex_header:   		minimum size=\lsize
#+latex_header:   	},
#+latex_header:   	pack/.style={
#+latex_header:   		circle, 
#+latex_header:   		draw = \pocolor, 
#+latex_header:   		fill = \picolor,
#+latex_header:   		inner sep = .25*\psize,
#+latex_header:   		minimum size = \psize
#+latex_header:   	},
#+latex_header:   	outer pack/.style={
#+latex_header:   		ellipse, 
#+latex_header:   		draw,
#+latex_header:   		inner sep=\ssep,
#+latex_header:   		color=\pocolor,
#+latex_header:   	},
#+latex_header:   	intermediate pack/.style={
#+latex_header:   		ellipse,
#+latex_header:   		dashed, 
#+latex_header:   		draw,
#+latex_header:   		inner sep=\ssep,
#+latex_header:   		color=\pocolor,
#+latex_header:   	},
#+latex_header:   }

*** Marsden's diagrams                                                                    :ignore:
# I am using Marsden's diagrams!
#+latex_header: \usepackage{macros}
#+latex_header: \usepackage{diag}
#+latex_header: \usepackage{eqproof}

#+latex_header: \newcommand{\leftop}{\ensuremath{\operatorname{\lhd}}}
#+latex_header: \newcommand{\rightop}{\ensuremath{\operatorname{\rhd}}}

#+latex_header: \newcommand{\mvright}[1]{\ensuremath{#1^{\rhd}}}
#+latex_header: \newcommand{\mvrightright}[1]{\ensuremath{#1^{\rhd\rhd}}}
#+latex_header: \newcommand{\mvleft}[1]{\ensuremath{#1^{\lhd}}}
#+latex_header: \newcommand{\mvleftleft}[1]{\ensuremath{#1^{\lhd\lhd}}}

#+latex_header: \newcommand{\adjsql}[1]{\ensuremath{#1_l}}
#+latex_header: \newcommand{\adjsqr}[1]{\ensuremath{#1_r}}

#+latex_header: \newcommand{\repcontrato}[4]{
#+latex_header: \path (#1.center) ++(0,-0.5) coordinate (#1-r)
#+latex_header:      +(-1,1) coordinate (#1-rl)
#+latex_header:      +(1,1) coordinate (#1-rr);
#+latex_header: \coordinate (#1-a) at (#1.south);
#+latex_header: \path
#+latex_header:  let \p1 = (#1.north) in
#+latex_header:  let \p2 = (#1-rl) in
#+latex_header:  let \p3 = (#1-rr) in
#+latex_header:  coordinate (#1-b) at (\x2, \y1)
#+latex_header:  coordinate (#1-c) at (\x3, \y1);
#+latex_header: \fill[catset] (#1.south) -- (#1-r) to[out=0, in=270] (#1-rr) -- (#1-c) -- (#1.north east) -- (#1.south east) -- cycle;
#+latex_header: \fill[catcop] (#1-b) -- (#1-rl) to[out=270,in=180] (#1-r) to[out=0,in=270] (#1-rr) -- (#1-c) -- cycle;
#+latex_header: \fill[catterm] (#1.south) -- (#1-r) to[out=180, in=270] (#1-rl) -- (#1-b) -- (#1.north west) -- (#1.south west) -- cycle;
#+latex_header: \draw (#1-r) to[out=180,in=270] (#1-rl) to node[swap]{#2} (#1-b);
#+latex_header: \draw (#1-r) to[out=0, in=270] (#1-rr) to node[swap]{#3} (#1-c);
#+latex_header: \draw (#1-a) to node[swap]{$*$} (#1-r);
#+latex_header: \strnat{#1-r};
#+latex_header: \strlabu{#1-r}{#4}
#+latex_header: }
#+latex_header: \newcommand{\repcontratoex}[5]{
#+latex_header: \coordinate[label=below:#2] (#1-b) at (#1.south);
#+latex_header: \coordinate[label=above:#5] (#1-t) at (#1.north);
#+latex_header:  \draw (#1-b) -- ++(0,1.5)
#+latex_header:        (#1-t) -- ++(0,-1.5);
#+latex_header:  \path (#1.south west) -- ++(0.5,1) coordinate (#1-bl)
#+latex_header:        (#1.north east) -- ++(-0.5,-1) coordinate (#1-tr);
#+latex_header:  \node[rectangle, fit=(#1-bl)(#1-tr)] (#1-subdiag) {};
#+latex_header:  \repcontrato{#1-subdiag}{#2}{#3}{#4};
#+latex_header:  \draw[very thick] (#1-subdiag.south west) rectangle (#1-subdiag.north east);
#+latex_header: \begin{pgfonlayer}{background}
#+latex_header:  \fill[catterm] (#1.south west) rectangle (#1.north);
#+latex_header:  \fill[catc] (#1.south east) rectangle (#1.north);
#+latex_header: \end{pgfonlayer}
#+latex_header: }
* Posts
** TODO Diagonal arguments since Epimenides
*** Epimenides
#+begin_quote
Epimenides the Cretan said that all Cretans were liars, and all other
statements made by Cretans were certainly lies. Was this a lie?
  -- /Mathematical logic as based on the theory of types/, Bertrand Russell.
#+end_quote

The first historical example of a diagonal argument is, in fact, not
an example. The negation of a universal quantifier is not an universal
quantifier; "not all Cretans are liars" is not the same as "all
Cretans are honest", and we can make the whole situation consistent by
simply assuming that *Epimenides* (a Cretan) is a liar, but not all
Cretans are.

A correct example would be the simpler "I am lying", which cannot be
neither true nor false without leading to contradiction. The example
presented by *Russell* is known as the [[https://en.wikipedia.org/wiki/Barber_paradox][Barber's paradox]].

*** TODO Cantor's theorem
# http://www.goodmath.org/blog/category/bad-math/cantor-crankery/

*** TODO Tarski-Gödel's theorem
#+BEGIN_corollary
A consistent theory cannot express its own truth. In particular, no
consistent formal system of arithmetic can encode the truth of
arithmetic statements.
#+END_corollary

*** Lawvere
So, what is a diagonal argument? My intention here is to introduce you
to the *Lawvere's fixed-point theorem*, a result that captures all
these diagonal arguments.

First, let's consider some preliminary definitions.  Let $\mathbb{C}$
be a category with a terminal object. We say that any morphism
$a \colon 1 \to A$ from the terminal object to an arbitrary
object $A \in\mathbb{C}$ is an *element* of $A$, and we write this as $a : A$.
A morphism $g \colon A \to B$ is *point-surjective* if, for every element
$b : B$, there exists an element $a : A$ such that $g\ a = b$ (composition
of morphism is yuxtaposition here).  The name for these two definitions comes from their interpretation
in $\mathsf{Sets}$, where $1 \to A$ corresponds to an element of the set $A$ and
a point-surjective function is precisely a surjection. With these
definitions, the theorem can be stated in any [[id:3d52d110-822a-4f85-a1c4-57d868b527d5][cartesian closed
category]].

#+begin_theorem
(Lawvere's fixed point theorem). In any cartesian closed category, if
there exists a point-surjective morphism $d : A \to B^A$, then each
morphism $f : B \to B$ has a fixed point $b : B$, such that $f\ b = b$.
#+end_theorem
#+BEGIN_proof
As $d$ is point-surjective, there exists $x : A$ such that $d\ x \equiv \lambda a. f\ (d\ a\ a)$,
but then, $d\ x\ x \equiv (\lambda a.f\ (d\ a\ a))\ x \equiv f\ (d\ x\ x)$ is a fixed point.
#+END_proof

*** Fixed points in untyped lambda calculus
#+BEGIN_corollary
Every term in untyped \lambda-calculus has a fixed point.
#+END_corollary

*** References

 * http://math.andrej.com/2007/04/08/on-a-proof-of-cantors-theorem/
 * http://tac.mta.ca/tac/reprints/articles/15/tr15abs.html
** TODO A nice definition of "model of computation"
# Bauer's thesis
# Partial functions must appear in the definition anyway
# SKI happen to correspond to logical tautologies

** TODO The type-theoretic axiom of choice
** TODO Bach sonata
** TODO The natural example of natural transformation
Double dual of a vector space.
** TODO Categorical programming with CAP
** TODO A geodesic to Freyd-Mitchell
** TODO Etimología para Mikrokosmos
# Bartok
# Cosmoi -> Benabou

** TODO Monoides, grupos, grupoides, categorías
# Definiciones
# Motivación
# Estructura coloreada
# Topología y topología dirigida

*** Monoides
Un *monoide* es una estructura $A$ en la que (1) podemos /componer/
cualesquiera dos elementos en uno nuevo con una operación 
$\circ \colon A \times A \to A$ y en la que (2) existe un elemento neutro $e$
que no afecta al componerse con otro, $a \circ e = e \circ a = a$ para
cualquier $a : A$, y (3) la composición es asociativa, siendo
$a \circ (b \circ c) = (a \circ b) \circ c$ para cualesquiera $a,b,c : A$.

Ejemplos son:

 1. Los números naturales con la suma como operación y el cero
    como elemento neutro. $n + 0 = 0 + n = n$
 2. Las cadenas de texto, con la concatenación como operación y
    la cadena vacía como elemento neutro. $a \circ "" = "" \circ a = a$

*** Grupo
Un *grupo* es un monoide donde cada elemento $a : A$ tiene una
inversa $a^{-1} : A$ tal que $a \circ a^{-1} = a^{-1} \circ a = e$.

Ejemplos son:

 1. Los números enteros con la suma como operación, el cero como
    elemento neutro y el elemento opuesto como negación.

*** Categoría
Una *categoría* es un monoide coloreado. Eso significa que no podemos
componer elementos libremente, sino que cada elemento $a : A$ tiene un
dominio $\mathrm{dom}(a)$ y un codominio $\mathrm{cod}(a)$. Sólo podemos componer $a \circ b$ 
si $\mathrm{cod}(b) = \mathrm{dom}(a)$, y la composición tendrá dominio $\mathrm{dom}(b)$ y 
codominio $\mathrm{cod}(b)$.

Ejemplos son:

 1. Las funciones con la composición de funciones.

*** Grupoide
Un *grupoide* es un grupo coloreado. 
** TODO Adjunciones
** TODO Media 2018
** TODO Three Emacs
** TODO Notes and spaced repetition cards in org-mode
** TODO Applicative functors
** TODO Integral calculus with Yoneda
*** on V-enriched categories
*** Day convolution
** TODO Reals in Agda

** TODO A zoo of adjunctions
distribuciones y simplices.
fibraciones y proposiciones

This is already done on Math.StackExchange!
 * https://math.stackexchange.com/questions/46708/a-bestiary-about-adjunctions

** TODO Recursion schemes
** TODO A quote by Conor McBride
#+begin_quote
"The task of the academic is not to scale great intellectual
mountains, but to flatten them." -- Conor McBride
#+end_quote
** TODO Van Laarhoven representation for lenses
# Derive it from Yoneda.
# Live code.
** TODO Notations for adjunctions
** TODO Yoneda, lentes y adjunciones

*** Introducción

**** Categoría producto
**** Categorías de funtores

**** Funtor hom
Fijemos una categoría $\mathbf{C}$.  Dados cualesquiera dos objetos $a, b \in \mathbf{C}$, 
podemos considerar el conjunto de homomorfismos entre ellos,
$\mathbf{C}(a,b) \in \mathbf{Sets}$.  Además, dado un morfismo $f \colon b \to d$,
su /postcomposición/ $(f \circ -) \colon \mathbf{C}(a,b) \to \mathbf{C}(a,d)$ es una /función/,
un morfismo de conjuntos que transforma cada morfismo $u \colon a \to b$
en un morfismo $f \circ u \colon a \to d$. Y también, dado un mofismo $g \colon c \to a$,
su /precomposición/ $(- \circ g) \colon \mathbf{C}(a,b) \to \mathbf{C}(c,b)$ es otra función. Esto
determina un funtor.

#+begin_proposition
Fijado cualquier objeto $a \in \mathbf{C}$, podemos construir un funtor al que
llamaremos $\mathbf{C}(a,-) \colon \mathbf{C} \to \mathbf{Sets}$.  Su acción en morfismos viene dada
por la postcomposición.
#+end_proposition
#+begin_proof
Para demostrar que es un funtor, debemos demostrar que preserva
identidades y composiciones.  Para cualquier objeto $b \in \mathbf{C}$, sea
el morfismo identidad $\mathrm{id} \colon b \to b$.  Demostramos que la postcomposición
con la identidad, $(\mathrm{id} \circ -) \colon \mathbf{C}(a,b) \to \mathbf{C}(a,b)$ es a su vez la identidad en ese
conjunto: nótese que $( \mathrm{id}_b \circ -) h = \mathrm{id} \circ h = h = \mathrm{id}_{\mathbf{C}(a,b)}(h)$, luego
$(\mathrm{id}_{b} \circ -) = \mathrm{id}_{\mathbf{C}(a,b)}$.

Ahora demostraremos que también preserva composiciones. Dadas dos
funciones $f \colon b \to c$ y $g \colon c \to d$, queremos demostrar que la postcomposición
con $(g \circ f)$ es exactamente igual que la postcomposición $f$ /compuesta/
con la postcomposición con $g$. Tenemos que
\[\begin{aligned} ((g \circ -) \circ (f \circ -)) h &= (g \circ -) (f \circ h) & \mbox{ \textit{ (definición)}} \\&=
g \circ (f \circ h) & \mbox{ \textit{ (asociatividad)}}  \\&=
(g \circ f) \circ h & \mbox{ \textit{ (definición)}} \\&=
((g \circ f) \circ -) h,
\end{aligned}\]
luego $(g \circ -)\circ (f \circ -) = ((g \circ f) \circ -)$.
#+end_proof

/Nota:/ en las dos partes de esta demostración usamos dos veces el hecho
de que si dos funciones son iguales en cada punto, entonces son iguales.
Esto es, asumimos que $\forall x \in a, f(a) = g(a)$ implica $f = g$. Esto se
conoce como el principio de /extensionalidad de las funciones/, y es cierto
para morfismos de la categoría $\mathbf{Sets}$, pero no es cierto en general y podemos
encontrar contraejemplos en la categoría dada por los homomorfismos entre grafos.
Es decir, en esta demostración estamos usando crucialmente las propiedades de
los conjuntos. \\

Ahora podemos aplicar este mismo resultado a la categoría opuesta, para
tener que $\mathbf{C}(-,d) \cong \mathbf{C}^{op}(d,-) \colon \mathbf{C}^{op} \to \mathbf{Sets}$ también determina un funtor.
Nótese que este segundo funtor es contravariante, llevará cada morfismo
$f \colon a \to b$ a su /precomposición/ $(- \circ f) \colon \mathbf{C}(b,d) \to \mathbf{C}(a,d)$. \\

Todavía podemos ir más lejos, teniendo un funtor $\mathbf{C}(a,-) \colon \mathbf{C} \to \mathbf{Sets}$ y un funtor
$\mathbf{C}^{op} \to \mathbf{Sets}$, tenemos por la propiedad universal del producto un funtor
$\mathbf{C} \times \mathbf{C}^{op} \to \mathbf{Sets}$. Este funtor lleva pares de objetos $(a,b) \in \mathbf{C} \times \mathbf{C}^{op}$ de
forma covariante y contravariante respectivamente

#+begin_proposition
La asignación $\mathbf{C}(-,-) \colon \mathbf{C} \times \mathbf{C}^{op} \to \mathbf{Sets}$ que acabamos de describir
es funtorial.
#+end_proposition
#+begin_proof

#+end_proof


*** El lema de Yoneda
Fijemos una categoría $\mathbf{C}$.  Cada objeto $c \in \mathbf{C}$ determina un funtor contravariante
$\mathbf{C}(-,c) \in \mathbf{Cat}(\mathbf{C}^{op}, \mathbf{Sets})$. Los funtores de esta forma se llaman /representables/,
y decimos que $\mathbf{C}(-,c)$ está representado por $c$. Dada una función $f \colon c \to d$, su
postcomposición puede verse como una transformación natural
$(f \circ -) \colon \mathbf{C}(-,c) \tonat \mathbf{C}(-,d)$.  Esto induce un funtor.

#+begin_proposition
El *embebimiento de Yoneda* es un funtor $\hirayo \colon \mathbf{C} \to \mathbf{Cats}(\mathbf{C}^{op}, \mathbf{Sets})$ que está
determinado en objetos por $c \mapsto \mathbf{C}(-,c)$ y en morfismos por $f \mapsto (f \circ -)$.
#+end_proposition


*** Ópticas

**** Invariantes

**** Polimórficas

**** Composicionalmente
# Pickering. Compositionality fails.

*** Representación profuntorial de una óptica

*** En la práctica

** Monoides coloreados y bi(monoides coloreados)                                             :post:
:PROPERTIES:
:TITLE: Monoides coloreados y bi(monoides coloreados)
:EXPORT_FILE_NAME: monoidescoloreadosbimonoidescoloreados.pdf
:EXPORT_DATE: 14 de abril de 2019
:INDEX_DATE: <2019-04-14 Sun>
:EXPORT_OPTIONS: toc:3 num:t lang:es
:END:

\quad\\

*** Introducción                                                                          :ignore:
Nuestro objetivo es el siguiente: primero presentamos una /sintaxis/, ciertos
símbolos que forman diagramas y que siguen ciertas reglas. Luego
veremos que esta sintaxis toma /modelos/ en objetos matemáticos con
cierta estructura.  ¿Cuál es la utilidad de estudiar la sintaxis? Cada
vez que probemos algo sólo usando sus reglas, lo estaremos probando
para todos sus modelos.  ¿En qué se diferencia esto de una
presentación axiomática de, digamos, un grupo? en que nuestra sintaxis
viene dada, no por cadenas de caracteres como suele hacerse en lógica,
¡sino por diagramas!  Vamos a ir un paso más allá, y, haciendo
implícitamente uso de teoremas de coherencia y complitud, definir las
nuestras estructuras de forma elemental usando diagramas.  En lugar de
definir diagramas, los tomamos como conceptos primitivos.

/In this article I am drawing diagrams using tikz and following
Marsden's cite:marsden14 macros for string diagrams./ /The general idea
follows this paper, but also Vicary-Heunen-Reutter's notes/ /for
Categorical Quantum Mechanics,/ cite:vicary19.

*** Monoides y monoides coloreados
#+begin_definicion 
Un elemento de un *monoide* es una /cuerda/ con /nodos/, un diagrama en una dimensión.
Los siguientes diagramas representan elementos de un monoide.
\begin{center}
\begin{tikzpicture}[scale=0.5]
\path coordinate[label=below:$$] (b) ++(0,4) coordinate[label=above:$M$] (t);
\coordinate[dot, label=right:$a$] (alpha) at ($(b)!0.333!(t)$);
\coordinate[dot, label=right:$b$] (alpha') at ($(b)!0.666!(t)$);
\draw (b) -- (alpha) to node[left]{$$} (alpha') -- (t);
\begin{pgfonlayer}{background}
\fill[color={white}] ($(t) + (-2,0)$) rectangle (b);
\fill[color={white}] (t) rectangle ($(b) + (2,0)$);
\end{pgfonlayer}
\end{tikzpicture}
\begin{tikzpicture}[scale=0.5]
\path coordinate[label=below:$$] (b) ++(0,4) coordinate[label=above:$M$] (t);
\draw (b) -- (t);
\begin{pgfonlayer}{background}
\fill[color={white}] ($(t) + (-2,0)$) rectangle (b);
\fill[color={white}] (t) rectangle ($(b) + (2,0)$);
\end{pgfonlayer}
\end{tikzpicture}
\begin{tikzpicture}[scale=0.5]
\path coordinate[label=below:$$] (b) ++(0,4) coordinate[label=above:$M$] (t);
\coordinate[dot, label=right:$x$] (alpha) at ($(b)!0.75!(t)$);
\coordinate[dot, label=right:$y$] (alpha') at ($(b)!0.5!(t)$);
\coordinate[dot, label=right:$z$] (alpha'') at ($(b)!0.25!(t)$);
\draw (b) -- (alpha) to node[left]{$$} (alpha') to node[left]{$$} (alpha'') -- (t);
\begin{pgfonlayer}{background}
\fill[color={white}] ($(t) + (-2,0)$) rectangle (b);
\fill[color={white}] (t) rectangle ($(b) + (2,0)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{center}
A la cuerda vacía se le llama *identidad* o /elemento neutro/ del monoide.
A la *concatenación* de dos cuerdas se le llama tradicionalmente /multiplicación/.
#+end_definicion

#+begin_ejemplo
Los números naturales con la suma forman un monoide.[fn:1] La
cuerda vacía es el cero y dos cuerdas con la misma suma se
declaran iguales.
\begin{equation*}
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[label=below:$$] (b) ++(0,4) coordinate[label=above:$\mathbb{N}$] (t);
\coordinate[dot, label=right:$3$] (alpha) at ($(b)!0.75!(t)$);
\coordinate[dot, label=right:$2$] (alpha') at ($(b)!0.5!(t)$);
\coordinate[dot, label=right:$4$] (alpha'') at ($(b)!0.25!(t)$);
\draw (b) -- (alpha) to node[left]{$$} (alpha') to node[left]{$$} (alpha'') -- (t);
\begin{pgfonlayer}{background}
\fill[color={white}] ($(t) + (-2,0)$) rectangle (b);
\fill[color={white}] (t) rectangle ($(b) + (2,0)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered} = \begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[label=below:$$] (b) ++(0,4) coordinate[label=above:$\mathbb{N}$] (t);
\coordinate[dot, label=right:$9$] (alpha) at ($(b)!0.5!(t)$);
\draw (b) -- (alpha) -- (t);
\begin{pgfonlayer}{background}
\fill[color={white}] ($(t) + (-2,0)$) rectangle (b);
\fill[color={white}] (t) rectangle ($(b) + (2,0)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
\end{equation*}
¿Cuál es la ventaja de escribir esto frente a la notación usual de un
monoide? con esta notación, la asociatividad es transparente. No tenemos
forma de distinguir $((3+2)+4)$ de $(3+(2+4))$ y esto es bueno, porque
en un monoide no debería poder existir forma de distinguirlos. Además, cuando
dibujamos la unidad como una cuerda vacía, estamos haciendo la unitalidad
transparente. No tenemos forma de distinguir $9$ de $0+9$.

[fn:1] Y los dibujos describen un /ábaco/.
#+end_ejemplo

La estructura de un monoide es muy rica, pero podemos ir más allá. En
un monoide, cualesquiera dos nodos pueden componerse sobre la cuerda,
pero podemos limitar esta composición dando colores a las cuerdas.
Cada nodo cambiará el color de la cuerda, y sólo podremos componer dos
nodos si el color de salida del primero coincide con el color de
entrada del segundo.

#+begin_definicion
Una *categoría* es un monoide coloreado. Alternativamente, un monoide es
una categoría monocroma.  Normalmente, a los elementos de una categoría
se les llama /morfismos/, a los colores se les llama /objetos,/ se les pone una
etiqueta en lugar de un color, y se dice que
/un monoide es una categoría con un sólo objeto/. 
Los siguientes son morfismos en una categoría.
\begin{center}
\begin{tikzpicture}[scale=0.5]
\path coordinate[label=below:$$] (b) ++(0,4) coordinate[label=above:$\mathbf{C}$] (t);
\coordinate[dot, label=right:$f$] (alpha) at ($(b)!0.333!(t)$);
\coordinate[dot, label=right:$g$] (alpha') at ($(b)!0.666!(t)$);
\draw[red!75!black] (b) to node[left]{$A$} (alpha);
\draw[blue!75!black] (alpha) to node[left]{$B$} (alpha');
\draw[green!60!black] (alpha') to node[left]{$C$} (t);
\begin{pgfonlayer}{background}
\fill[color={white}] ($(t) + (-2,0)$) rectangle (b);
\fill[color={white}] (t) rectangle ($(b) + (2,0)$);
\end{pgfonlayer}
\end{tikzpicture}
\begin{tikzpicture}[scale=0.5]
\path coordinate[label=below:$$] (b) ++(0,4) coordinate[label=above:$\mathbf{C}$] (t);
\draw[red!75!black] (b) to node[left]{$A$} (t);
\begin{pgfonlayer}{background}
\fill[color={white}] ($(t) + (-2,0)$) rectangle (b);
\fill[color={white}] (t) rectangle ($(b) + (2,0)$);
\end{pgfonlayer}
\end{tikzpicture}
\begin{tikzpicture}[scale=0.5]
\path coordinate[label=below:$$] (b) ++(0,4) coordinate[label=above:$\mathbf{C}$] (t);
\coordinate[dot, label=right:$h$] (alpha) at ($(b)!0.5!(t)$);
\draw[blue!75!black] (b) to node[left]{$B$} (alpha);
\draw[red!75!black] (alpha) to node[left]{$A$} (t);
\begin{pgfonlayer}{background}
\fill[color={white}] ($(t) + (-2,0)$) rectangle (b);
\fill[color={white}] (t) rectangle ($(b) + (2,0)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{center}
A la concatenación se le suele llamar *composición* y a la cuerda vacía de un
determinado color se le llama *identidad* sobre ese objeto. Al color de entrada
de un nodo se le llama *dominio* y al color de salida se le llama *codominio*.
#+end_definicion

Ahora la composición está limitada: podemos poner $g$ después de $f$
porque el dominio de $g$ y el codominio de $f$ coinciden, pero no
podemos poner $h$ después de $g$, por ejemplo, porque $h$ tiene dominio $B$.

#+begin_ejemplo
Las funciones entre conjuntos forman una categoría, que suele notarse
por $\mathbf{Set}$.  Cada color es un conjunto, y entre dos conjuntos $A$ y $B$ podemos
considerar los nodos dados por las funciones $f \colon A \to B$.  Al concatenar
varias funciones, lo que hacemos es componerlas. Una cadena vacía sobre
un conjunto representa la función identidad sobre ese conjunto.
\begin{equation*}
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[label=below:$$] (b) ++(0,4) coordinate[label=above:$\mathbf{Set}$] (t);
\coordinate[dot, label=right:$\mathsf{not}$] (alpha) at ($(b)!0.666!(t)$);
\coordinate[dot, label=right:$\mathsf{even}$] (alpha') at ($(b)!0.333!(t)$);
\draw[yellow!60!black] (t) to node[left]{$\mathsf{Bool}$} (alpha);
\draw[yellow!60!black] (alpha) to node[left]{$\mathsf{Bool}$} (alpha');
\draw[red!70!black] (alpha') to node[left]{$\mathbb{N}$} (b);
\begin{pgfonlayer}{background}
\fill[color={white}] ($(t) + (-2,0)$) rectangle (b);
\fill[color={white}] (t) rectangle ($(b) + (2,0)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered} = \begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[label=below:$$] (b) ++(0,4) coordinate[label=above:$\mathbf{Set}$] (t);
\coordinate[dot, label=right:$\mathsf{odd}$] (alpha) at ($(b)!0.5!(t)$);
\draw[red!70!black] (b) -- (alpha);
\draw[yellow!70!black] (alpha) -- (t);
\begin{pgfonlayer}{background}
\fill[color={white}] ($(t) + (-2,0)$) rectangle (b);
\fill[color={white}] (t) rectangle ($(b) + (2,0)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
\end{equation*}
La asociatividad de la composición de funciones y la neutralidad de la
función se han vuelto invisibles con esta notación.
#+end_ejemplo

*** Categorías monoidales
Cuando los diagramas de verdad se vuelven interesantes es cuando
pasamos de una a dos dimensiones.  Nuestra siguiente definición usa
dos dimensiones. En uno de los ejes tenemos un monoide, en el otro
tenemos una categoría.

#+begin_definicion
Los morfismos de *categoría monoidal* vienen dados por diagramas
bidimensionales de cuerdas con distintos colores.  Un morfismo puede
tener como entrada y salida un número cualquiera de cuerdas.
\begin{center}
\begin{tabular}{c c c c}
\begin{tikzpicture}[scale=0.5]
\path coordinate (bl) ++(0,2) coordinate[dot, label=left:$\alpha$] (alpha) ++(0,2) coordinate (tl)
 (bl) ++(2,0) coordinate (br) ++(0,2) coordinate[dot, label=right:$\beta$] (beta) ++(0,2) coordinate (tr);
\draw[red!75!black] (bl) -- (alpha);
\draw[blue!75!black] (alpha) -- (tl);
\draw[green!75!black] (br) -- (beta);
\draw[red!75!black] (beta) -- (tr);
\begin{pgfonlayer}{background}
\fill[color={white!95!black}] ($(tl) + (-2,0)$) rectangle (bl);
\fill[color={white!95!black}] (tl) rectangle (br);
\fill[color={white!95!black}] (tr) rectangle ($(br) + (2,0)$);
\end{pgfonlayer}
\end{tikzpicture} 
&
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=above:\ensuremath{\gamma}]
 (eta) ++(-1,1) coordinate (a) ++(0,1) coordinate (tl)
 (eta) ++(1,1) coordinate (b) ++(0,1) coordinate (tr)
 (eta) ++(-1,-1) coordinate[dot, label=left:$\delta$] (c) ++(0,-1) coordinate (el)
 (eta) ++(1,-1) coordinate (d) ++(0,-1) coordinate (er)
 (eta) ++(0,-2) coordinate (e);
\draw[red!75!black] (tl) -- (a) to[out=-90, in=180] (eta.west);
\draw (eta.west) -- (eta.east);
\draw[red!75!black] (eta.east) to[out=0, in=-90] (b) -- (tr);
\draw[blue!75!black] (el) -- (c);
\draw[orange!75!black] (c) to[out=90, in=180] (eta.west);
\draw (eta.west) -- (eta.east);
\draw[blue!75!black] (eta.east) to[out=0, in=90] (d) -- (er);
\draw[blue!75!black] (eta) -- (e);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(tl) + (-2,0)$) rectangle ($(tr) + (2,-4)$);
%\fill[white!95!black] (tl) -- (a) to[out=-90, in=180] (eta.west) -- (eta.east) to[out=0, in=-90] (b) -- (tr) -- cycle;
%\fill[white!95!black] ($(tl) + (-1,-2)$) rectangle ($(tr) + (1,-4)$);
\end{pgfonlayer}
\end{tikzpicture}
&
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=above:\ensuremath{\psi}]
 (eta) ++(0,-2) coordinate (e);
\draw[blue!75!black] (eta) -- (e);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(eta) + (-2,2)$) rectangle ($(eta) + (2,-2)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{tabular}
\end{center}
#+end_definicion

Consideramos iguales cualesquiera dos diagramas que sean isotópicos,
pero aun tenemos la restricción dada por los colores: el morfismo
$\gamma$, por ejemplo, necesita tomar (¡en ese orden!) una entrada
naranja y dos azules. Nuestro siguiente paso será colorear las regiones
del diagrama, así que quizá es una buena idea cambiar los colores de las
cuerdas por etiquetas, como implícitamente estamos haciendo con los
morfismos.

#+begin_ejemplo
Las funciones sobre conjuntos no sólo forman una categoría, sino que
forman una categoría monoidal con el producto dado por el producto
cartesiano.  Esto nos permite además expresar funciones no necesariamente
unarias en nuestros diagramas.  ¡Importante!: los diagramas se suelen leer
de abajo hacia arriba; pero a veces también se encuentran en la literatura
de izquierda a derecha o incluso de arriba a abajo.
\begin{center}
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label={[label distance=1ex]0:$\small{(+)}$}]
 (eta) ++(0,1.333) coordinate[dot, label=right:$\mathsf{odd}$] (a) ++(0,1.333) coordinate (tl)
 (eta) ++(-1,-1.333) coordinate (c) ++(0,0) coordinate (el)
 (eta) ++(1,-1.333) coordinate (d) ++(0,0) coordinate (er);
\draw[yellow!75!black] (tl) -- (a);
\draw[red!75!black] (a) -- (eta);
\draw (eta.west) -- (eta.east);
\draw[red!75!black] (el) -- (c);
\draw[red!75!black] (c) to[out=90, in=180] (eta.west);
\draw (eta.west) -- (eta.east);
\draw[red!75!black] (eta.east) to[out=0, in=90] (d) -- (er);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(eta) + (-3,2.666)$) rectangle ($(eta) + (3,-1.333)$);
\end{pgfonlayer}
\end{tikzpicture}\end{gathered} = \begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label={[label distance=1ex]0:$\small{(\oplus)}$}]
 (eta) ++(0,1.333) coordinate (tl)
 (eta) ++(-1,-1.333) coordinate[dot, label=left:$\mathsf{odd}$] (c) ++(0,-1.333) coordinate (el)
 (eta) ++(1,-1.333)  coordinate[dot, label=right:$\mathsf{odd}$] (d) ++(0,-1.333) coordinate (er);
\draw[yellow!75!black] (tl) -- (eta);
\draw[red!75!black] (el) -- (c);
\draw[yellow!75!black] (c) to[out=90, in=180] (eta.west);
\draw (eta.west) -- (eta.east);
\draw[yellow!75!black] (eta.east) to[out=0, in=90] (d);
\draw[red!75!black] (d) -- (er);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(eta) + (-3,1.333)$) rectangle ($(eta) + (3,-2.666)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
\end{center}
Por cierto, esta ecuación está expresando que la función que calcula si un
número es impar es un homomorfismo de monoides (en su definición usual como
conjuntos) del monoide de los naturales con la suma al monoide de los booleanos
con la operación xor.
#+end_ejemplo

*** PROs y teorías de Lawvere
Nos hemos saltado un paso obvio. ¿Qué ocurre si tomamos dos
dimensiones pero sólo usamos cuerdas de un color? El resultado *no* es
una categoría monoidal con un solo objeto, sino una categoría monoidal
cuyos objetos vienen dados por el monoide libre sobre un
generador. Esto ocurre porque no forzamos un número arbitrario de
cuerdas a ser iguales a una sóla cuerda.

#+begin_definicion
Un *PRO*, o *categoría de (pro)ductos monoidales*, es una categoría monoidal
monocroma. Alternativamente, una categoría monoidal es un PRO coloreado.
#+end_definicion

#+begin_ejemplo
Estas categorías pueden usarse para describir teorías algebraicas internas
a nuestras teorías. ¿Qué quiere decir esto? Nosotros hemos partido de una
noción primitiva de monoide y categoría, pero una vez que tenemos la categoría
monoidal de conjuntos, podríamos intentar definir un monoide /en la categoría de conjuntos/.
Este monoide no será un diagrama sino una operación de multiplicación (con dos
entradas y una salida) y una unidad (con una salida y ninguna entrada)
/dentro de la categoría/.  Un monoide en una categoría monoidal viene determinado por
los siguientes morfismos.
\begin{center}
\begin{tabular}{c c c c}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=below:\ensuremath{m}]
 (eta) ++(-1,-1) coordinate (a) ++(0,-1) coordinate (tl)
 (eta) ++(1,-1) coordinate (b) ++(0,-1) coordinate (tr)
 (eta) ++(0,2) coordinate (e);
\draw[black] (tl) -- (a) to[out=90, in=180] (eta.east);
\draw[black] (eta.west) to[out=0, in=90] (b) -- (tr);
\draw[black] (eta) -- (e);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(eta) + (-3,2)$) rectangle ($(eta) + (3,-2)$);
\end{pgfonlayer}
\end{tikzpicture} &
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=below:\ensuremath{u}]
 (eta) ++(0,2) coordinate (e);
\draw[black] (eta) -- (e);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(eta) + (-2,2)$) rectangle ($(eta) + (2,-2)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{tabular}
\end{center}
Cumpliendo los axiomas de un monoide, que son las siguientes ecuaciones.
La primera se llama *unitalidad* y comprueba que la unidad es neutra respecto
al producto.
\begin{center}
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label={[label distance=1ex]0:$\small{m}$}]
 (eta) ++(0,1.333) coordinate (tl)
 (eta) ++(-1,-1.333) coordinate[dot, label=left:$u$] (c) ++(0,-1.333) coordinate (el)
 (eta) ++(1,-1.333)  coordinate (d) ++(0,-1.333) coordinate (er);
\draw[black] (tl) -- (eta);
\draw[black] (c) to[out=90, in=180] (eta.west);
\draw (eta.west) -- (eta.east);
\draw[black] (eta.east) to[out=0, in=90] (d);
\draw[black] (d) -- (er);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(eta) + (-3,1.333)$) rectangle ($(eta) + (3,-2.666)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
=
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate
 (eta) ++(0,1.333) coordinate (tl)
 (eta) ++(0,-1.333) coordinate (c) ++(0,-1.333) coordinate (el)
 (eta) ++(0,-1.333)  coordinate (d) ++(0,-1.333) coordinate (er);
\draw[black] (tl) -- (er);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(eta) + (-3,1.333)$) rectangle ($(eta) + (3,-2.666)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
=
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label={[label distance=1ex]0:$\small{m}$}]
 (eta) ++(0,1.333) coordinate (tl)
 (eta) ++(-1,-1.333) coordinate (c) ++(0,-1.333) coordinate (el)
 (eta) ++(1,-1.333)  coordinate[dot, label=right:$u$] (d) ++(0,-1.333) coordinate (er);
\draw[black] (tl) -- (eta);
\draw[black] (el) -- (c);
\draw[black] (c) to[out=90, in=180] (eta.west);
\draw (eta.west) -- (eta.east);
\draw[black] (eta.east) to[out=0, in=90] (d);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(eta) + (-3,1.333)$) rectangle ($(eta) + (3,-2.666)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
\end{center}
La segunda se llama *asociatividad* y nos permite aplicar las multiplicaciones
en cualquier orden.
\begin{center}
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label={[label distance=1ex]180:$\small{m}$}]
 (eta) ++(0,1.333) coordinate (tl)
 (eta) ++(-1,-1.333) coordinate[dot, label={[label distance=1ex]180:$\small{m}$}] (c) ++(0,-1.333) coordinate (el)
 (c) ++(-0.666,-1.333) coordinate (pl)
 (c) ++(0.666,-1.333) coordinate (pr)
 (eta) ++(1,-1.333)  coordinate (d) ++(0,-1.333) coordinate (er);
\draw[black] (tl) -- (eta);
\draw[black] (c) to[out=90, in=180] (eta.west);
\draw[black] (pl) to[out=90, in=180] (c.west);
\draw (eta.west) -- (eta.east);
\draw[black] (eta.east) to[out=0, in=90] (d);
\draw[black] (c.east) to[out=0, in=90] (pr);
\draw[black] (d) -- (er);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(eta) + (-3,1.333)$) rectangle ($(eta) + (3,-2.666)$);
ñ\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
=
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label={[label distance=1ex]0:$\small{m}$}]
 (eta) ++(0,1.333) coordinate (tl)
 (eta) ++(-1,-1.333) coordinate (c) ++(0,-1.333) coordinate (el)
 (eta) ++(1,-1.333)  coordinate[dot, label={[label distance=1ex]0:$\small{m}$}] (d) ++(0,-1.333) coordinate (er)
 (d) ++(-0.666,-1.333) coordinate (pl)
 (d) ++(0.666,-1.333) coordinate (pr);
\draw[black] (tl) -- (eta);
\draw[black] (el) -- (c);
\draw[black] (c) to[out=90, in=180] (eta.west);
\draw (eta.west) -- (eta.east);
\draw[black] (eta.east) to[out=0, in=90] (d);
\draw[black] (pl) to[out=90, in=180] (d.west);
\draw[black] (d.east) to[out=0, in=90] (pr);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(eta) + (-3,1.333)$) rectangle ($(eta) + (3,-2.666)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
\end{center}
Los números complejos con la multiplicación, las cadenas de caracteres
con la concatenación o los naturales con la suma son ejemplos clásicos
de monoide.
#+end_ejemplo

Dada una teoría, consideramos su teoría *dual* como aquella que resulta de
invertir la dirección de los diagramas.

#+begin_definicion
Un *comonoide* es el dual de un monoide.  Esto quiere decir que tendrá una
/counidad/ y una /comultiplicación/.
\begin{center}
\begin{tabular}{c c c c}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=above:\ensuremath{n}]
 (eta) ++(-1,1) coordinate (a) ++(0,1) coordinate (tl)
 (eta) ++(1,1) coordinate (b) ++(0,1) coordinate (tr)
 (eta) ++(0,-2) coordinate (e);
\draw[black] (tl) -- (a) to[out=-90, in=180] (eta.east);
\draw[black] (eta.west) to[out=0, in=-90] (b) -- (tr);
\draw[black] (eta) -- (e);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(eta) + (-3,2)$) rectangle ($(eta) + (3,-2)$);
\end{pgfonlayer}
\end{tikzpicture} &
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=above:\ensuremath{c}]
 (eta) ++(0,-2) coordinate (e);
\draw[black] (eta) -- (e);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(eta) + (-2,2)$) rectangle ($(eta) + (2,-2)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{tabular}
\end{center}
Satisfaciendo axiomas de *counitalidad* y *coasociatividad*.

¿Por qué no solemos hablar de comonoides cuando estudiamos álgebra?
Nuestra notación es siempre unidimensional, y eso hace un poco difícil hablar
de operaciones con más de una salida; además de esta limitación, esencialmente
existe un único comonoide en la categoría de conjuntos. El único comonoide de la
categoría de conjuntos es el comonoide de *copia y borrado*, donde la multiplicación
es la diagonal $A \to A \times A$ y el borrado es la única función $A \to 1$.  Nunca hablamos
de este comonoide, pero aparece continuamente cuando hacemos álgebra: lo que hacemos
para evitar hablar de él es repetir nombres de variables, por ejemplo, la función
$x \mapsto x + x$ es realmente la composición de la suma con la copia.
#+end_definicion

*** Trenzados
Otra condición que suele considerarse para monoides es la
*conmutatividad*.  Para ella, necesitamos un poco más de estructura
en nuestra categoría monoidal.

#+begin_definicion
Una *categoría monoidal trenzada* es aquella en la que las cuerdas
pueden trenzarse. Es decir, existe un morfismo, llamado
/trenzado/, que escribimos como en el siguiente diagrama.
\begin{center}
\begin{tikzpicture}[scale=0.5]
\path coordinate
 (eta) ++(-1,1) coordinate (a) ++(0,1) coordinate (tl)
 (eta) ++(1,1) coordinate (b) ++(0,1) coordinate (tr)
 (eta) ++(-1,-1) coordinate (c) ++(0,-1) coordinate (el)
 (eta) ++(1,-1) coordinate (d) ++(0,-1) coordinate (er);
\draw[red!75!black] (tl) -- (a);
\draw[red!75!black] (a) to[out=-90, in=90] (d);
\draw[red!75!black] (d) -- (er);
\foreach \arrow in {1, ..., 2} {
        \fill[white!95!black, name intersections={of=bg arrow and fg arrow\arrow, name=i}] (i-1) circle (4pt);
    }
\draw[blue!75!black] (b) -- (tr);
\draw[blue!75!black] (b) to[out=-90, in=90] (c);
\draw[blue!75!black] (el) -- (c);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(tl) + (-2,0)$) rectangle ($(tr) + (2,-4)$);
%\fill[white!95!black] (tl) -- (a) to[out=-90, in=180] (eta.west) -- (eta.east) to[out=0, in=-90] (b) -- (tr) -- cycle;
%\fill[white!95!black] ($(tl) + (-1,-2)$) rectangle ($(tr) + (1,-4)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{center}
#+end_definicion

#+begin_ejemplo
En una categoría monoidal, un monoide es *conmutativo* si el componer
con una trenza no altera su multiplicación. La *coconmutatividad* se
define de forma análoga.
\begin{center}
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=below:\ensuremath{m}]
 (eta) ++(-1,-1) coordinate (a) ++(0,-1) coordinate (tl)
 (eta) ++(1,-1) coordinate (b) ++(0,-1) coordinate (tr)
 (eta) ++(0,2) coordinate (e);
\draw[black] (a) to[out=90, in=180] (eta.east);
\draw[black] (eta.west) to[out=0, in=90] (b);
\draw[black] (eta) -- (e);
\draw[name path=fgarrow, black] (tl) to[out=90,in=-90] (b);
\draw[name path=bgarrow, black] (tr) to[out=90,in=-90] (a);
\fill[white!95!black, name intersections={of=bgarrow and fgarrow, name=i}] (i-1) circle (13pt);
\draw[name path=ubgarrow, black] (tr) to[out=90,in=-90] (a);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(eta) + (-3,2)$) rectangle ($(eta) + (3,-2)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered} =
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=below:\ensuremath{m}]
 (eta) ++(-1,-1) coordinate (a) ++(0,-1) coordinate (tl)
 (eta) ++(1,-1) coordinate (b) ++(0,-1) coordinate (tr)
 (eta) ++(0,2) coordinate (e);
\draw[black] (tl) -- (a) to[out=90, in=180] (eta.east);
\draw[black] (eta.west) to[out=0, in=90] (b) -- (tr);
\draw[black] (eta) -- (e);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(eta) + (-3,2)$) rectangle ($(eta) + (3,-2)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
\end{center}
#+end_ejemplo

*** Dualidades y espacios vectoriales
Antes de dar el siguiente paso, vamos a considerar dualidades y vamos a
trabajar con uno de los ejemplos más interesantes de categoría monoidal:
los espacios vectoriales.

#+begin_definicion
Una *dualidad* entre dos cuerdas $f \dashv g$ viene dada por una forma de crearlas
desde la nada y una forma de fundirlas.  ¡Nótese que la definición no es
simétrica! Si $f \dashv g$, no necesariamente se tiene $g \dashv f$.
\begin{center}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=below:\ensuremath{\eta}] 
 (eta) ++(-1,1) coordinate (a) ++(0,0.5) coordinate[label=above:\ensuremath{f}] (tl)
 (eta) ++(1,1) coordinate (b) ++(0,0.5) coordinate[label=above:\ensuremath{g}] (tr);
\draw[red!75!black] (tl) -- (a) to[out=-90, in=180] (eta.west);
\draw[blue!75!black] (eta.east) to[out=0, in=-90] (b) -- (tr);
\begin{pgfonlayer}{background}
\fill[white] ($(tl) + (-1,0)$) rectangle ($(tr) + (1,-2)$);
\fill[white] (tl) -- (a) to[out=-90, in=180] (eta.west) -- (eta.east) to[out=0, in=-90] (b) -- (tr) -- cycle;
\fill[white] ($(tl) + (-1,-2)$) rectangle ($(tr) + (1,-3)$);
\end{pgfonlayer}
\end{tikzpicture}
&
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=above:\ensuremath{\varepsilon}] 
 (epsilon) ++(-1,-1) coordinate (a) ++(0,-0.5) coordinate[label=below:\ensuremath{g}] (bl)
 (epsilon) ++(1,-1) coordinate (b) ++(0,-0.5) coordinate[label=below:\ensuremath{f}] (br);
\draw[blue!75!black] (bl) -- (a) to[out=90, in=180] (epsilon.west);
\draw[red!75!black] (epsilon.east) to[out=0, in=90] (b) -- (br);
\begin{pgfonlayer}{background}
\fill[white] ($(bl) + (-1,0)$) rectangle ($(br) + (1,2)$);
\fill[white] (bl) -- (a) to[out=90, in=180] (epsilon.west) -- (epsilon.east) to[out=0, in=90] (b) -- (br) -- cycle;
\end{pgfonlayer}
\end{tikzpicture}
\end{center}
Satisfaciendo las siguientes *ecuaciones de zig-zag*.
\begin{center}
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=above:$\eta$] (eta) ++(1,1) coordinate (a) ++(1,1) coordinate[dot, label=below:$\varepsilon$] (epsilon) 
 ++(1,-1) coordinate (b) ++(0,-2) coordinate (br)
 (eta) ++(-1,1) coordinate (c) ++(0,2) coordinate (tl);
\draw[red!75!black] (tl) -- (c) to[out=-90, in=180] (eta);
\draw[blue!75!black] (eta) to[out=0, in=-90] (a) to[out=90, in=180] (epsilon);
\draw[red!75!black] (epsilon) to[out=0, in=90] (b) -- (br);
\begin{pgfonlayer}{background}
\fill[white!95!black] (tl) -- (c) to[out=-90, in=180] (eta) to[out=0, in=-90] (a) to[out=90, in=180] (epsilon) to[out=0, in=90] (b) -- (br)
 -- ++(0.5,0) -- ++(0,4) -- cycle;
\fill[white!95!black] (tl) -- (c) to[out=-90, in=180] (eta) to[out=0, in=-90] (a) to[out=90, in=180] (epsilon) to[out=0, in=90] (b) -- (br)
 -- ++(-4.5,0) -- ++(0,4) -- cycle;
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
\enskip=\enskip
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate (b) ++(0,4) coordinate (t);
\draw[red!75!black] (b) -- (t);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(t) + (-1,0)$) rectangle (b);
\fill[white!95!black] (t) rectangle ($(b) + (1,0)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
\qquad
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=below:$\varepsilon$] (epsilon) ++(1,-1) coordinate (a) ++(1,-1) coordinate[dot, label=above:$\eta$] (eta)
 ++(1,1) coordinate (b) ++(0,2) coordinate (tr)
 (epsilon) ++(-1,-1) coordinate (c) ++(0,-2) coordinate (bl);
\draw[blue!75!black] (bl) -- (c) to[out=90, in=180] (epsilon);
\draw[red!75!black] (epsilon) to[out=0, in=90] (a) to[out=-90, in=180] (eta);
\draw[blue!75!black] (eta) to[out=0, in=-90] (b) -- (tr);
\begin{pgfonlayer}{background}
\fill[white!95!black] (bl) -- (c) to[out=90, in=180] (epsilon) to[out=0, in=90] (a) to[out=-90, in=180] (eta) to[out=0, in=-90] (b) -- (tr)
 -- ++(0.5,0) -- ++(0,-4) -- cycle;
\fill[white!95!black] (bl) -- (c) to[out=90, in=180] (epsilon) to[out=0, in=90] (a) to[out=-90, in=180] (eta) to[out=0, in=-90] (b) -- (tr)
 -- ++(-4.5,0) -- ++(0,-4) -- cycle;
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
\enskip=\enskip
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate (b) ++(0,4) coordinate (t);
\draw[blue!75!black] (b) -- (t);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(t) + (-1,0)$) rectangle (b);
\fill[white!95!black] (t) rectangle ($(b) + (1,0)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
\end{center}
#+end_definicion

#+begin_ejemplo
Consideramos la categoría mononidal de los espacios vectoriales
finitos, fijada una base ortonormal.[fn:2] Los morfismos son funciones
lineales, y los espacios vectoriales en sí forman un monoide con el
producto tensor de espacios vectoriales.
Pero además, cada espacio vectorial es dual consigo mismo, $V \dashv V^{\ast} \cong V$, 
gracias al producto escalar, que es una función $\varepsilon \colon V \otimes V \to V$, y a
la diagonal de la base $\eta \colon I \to V \otimes V$, que está definida por el
elemento $\sum (e_i \otimes e_i)$.

Con todo esto, la *traspuesta* de una función lineal $f \colon V \to W$
es una función $f \colon W \to V$ definida como sigue. Nótese que aquí
$\eta$ y $\varepsilon$ se refieren a distintas dualidades, cada una de uno de los
espacios es dual consigo mismo.
\begin{center}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=below:$\eta$] (eta) ++(1,1) coordinate[dot, label=right:$f$] (a) ++(1,1) coordinate[dot, label=above:$\varepsilon$] (epsilon) 
 ++(1,-1) coordinate (b) ++(0,-2) coordinate (br)
 (eta) ++(-1,1) coordinate (c) ++(0,2) coordinate (tl);
\draw[orange!75!black] (tl) -- (c) to[out=-90, in=180] (eta);
\draw[orange!75!black] (eta) to[out=0, in=-90] (a);
\draw[violet!75!black] (a) to[out=90, in=180] (epsilon);
\draw[violet!75!black] (epsilon) to[out=0, in=90] (b) -- (br);
\begin{pgfonlayer}{background}
\fill[white!95!black] (tl) -- (c) to[out=-90, in=180] (eta) to[out=0, in=-90] (a) to[out=90, in=180] (epsilon) to[out=0, in=90] (b) -- (br)
 -- ++(0.5,0) -- ++(0,4) -- cycle;
\fill[white!95!black] (tl) -- (c) to[out=-90, in=180] (eta) to[out=0, in=-90] (a) to[out=90, in=180] (epsilon) to[out=0, in=90] (b) -- (br)
 -- ++(-4.5,0) -- ++(0,4) -- cycle;
\end{pgfonlayer}
\end{tikzpicture}
\end{center}
Usando trenzados y moviendo el diagrama, podemos demostrar que la
traspuesta de la traspuesta es de nuevo la función original.

[fn:2] Sobre los reales, por ejemplo. Pero todo lo que hagamos
funciona para cualquier cuerpo en general e incluso para módulos sobre
un semianillo arbitrario.  Si tomamos por ejemplo el semianillo de los
booleanos, obtenemos la categoría de relaciones $\mathbf{Rel}$.
#+end_ejemplo

#+begin_ejemplo
<<ejemplo-dualidad-monoide>>
Toda dualidad $f \dashv g$ da lugar a un monoide en el producto tensorial $f \otimes g$. Su multiplicación
y su unidad son las siguientes. Los axiomas se siguen de las ecuaciones de zig-zag.
\begin{center}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=below:\ensuremath{\eta}] 
 (eta) ++(-1,1) coordinate (a) ++(0,0.5) coordinate[label=above:\ensuremath{f}] (tl)
 (eta) ++(1,1) coordinate (b) ++(0,0.5) coordinate[label=above:\ensuremath{g}] (tr);
\draw[red!75!black] (tl) -- (a) to[out=-90, in=180] (eta.west);
\draw[blue!75!black] (eta.east) to[out=0, in=-90] (b) -- (tr);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(tl) + (-1,0)$) rectangle ($(tr) + (1,-2)$);
\fill[white!95!black] (tl) -- (a) to[out=-90, in=180] (eta.west) -- (eta.east) to[out=0, in=-90] (b) -- (tr) -- cycle;
\fill[white!95!black] ($(tl) + (-1,-2)$) rectangle ($(tr) + (1,-3)$);
\end{pgfonlayer}
\end{tikzpicture}
&
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=below:$\varepsilon$] 
 (epsilon) ++(-1,-1) coordinate (a) ++(0,-0.5) coordinate (bl) ++(-1,0) coordinate (bll) 
  ++(0,3) coordinate[label=above:$f$] (tl)
 (epsilon) ++(1,-1) coordinate (b) ++(0,-0.5) coordinate (br) ++(1,0) coordinate (brr) 
  ++(0,3) coordinate[label=above:$g$] (tr);
\draw[red!75!black] (bll) -- (tl);
\draw[blue!75!black] (brr) -- (tr);
\draw[blue!75!black] (bl) -- (a) to[out=90, in=180] (epsilon.west);
\draw[red!75!black] (epsilon.east) to[out=0, in=90] (b) -- (br);
\begin{pgfonlayer}{background}
\fill[white!95!black] ($(tl) + (-1,0)$) rectangle (bll);
\fill[white!95!black] ($(tr) + (1,0)$) rectangle (brr);
\fill[white!95!black] (bll) rectangle (tr);
\fill[white!95!black] (bl) -- (a) to[out=90, in=180] (epsilon.west) -- (epsilon.east) to[out=0, in=90] (b) -- (br) -- cycle;
\end{pgfonlayer}
\end{tikzpicture}
\end{center}
#+end_ejemplo

*** Bicategorías
El siguiente paso es colorear las regiones.  Esto limitará qué cuerdas
podemos colocar al lado de otras cuerdas.

#+begin_definicion
Una *bicategoría* es una categoría monoidal coloreada en las regiones.
Alternativamente, una categoría monoidal es una bicategoría monocroma.
\begin{center}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label={[label distance=0.25cm]right:\ensuremath{\alpha}}] (sigma) 
 ++(-2,1) coordinate[dot, label=below:\ensuremath{\beta}] (epsilon) ++(-1,-1) coordinate (a)
 ++(0,-0.5) coordinate[label=below:\ensuremath{f}] (bl)
 (sigma) ++(1,1.5) coordinate[label=above:\ensuremath{h}] (tr)
 (sigma) ++(0,1.5) coordinate[label=above:\ensuremath{e}] (tl)
 (sigma) ++(0,-0.5) coordinate[label=below:\ensuremath{g}] (br);
\draw (tr) to[out=-90, in=0] (sigma) to[out=180, in=0] (epsilon) to[out=180, in=90] (a) -- (bl);
\draw (br) -- (tl);
\begin{pgfonlayer}{background}
\fill[green!20] ($(bl) + (-1,0)$) rectangle (tl);
\fill[green!50] ($(tr) + (1,0)$) rectangle (br);
\begin{scope}
\clip ($(bl) + (-1,0)$) rectangle (tl);
\fill[blue!20] (tr) to[out=-90, in=0] (sigma) to[out=180, in=0] (epsilon) to[out=180, in=90] (a) -- (bl) -- ++(5,0) -- ++(0,2) -- cycle;
\end{scope}
\begin{scope}
\clip ($(tr) + (1,0)$) rectangle (br);
\fill[blue!50] (tr) to[out=-90, in=0] (sigma) to[out=180, in=0] (epsilon) to[out=180, in=90] (a) -- (bl) -- ++(5,0) -- ++(0,2) -- cycle;
\end{scope}
\end{pgfonlayer}
\end{tikzpicture}
\end{center}
#+end_definicion

#+begin_ejemplo
La bicategoría $\mathbf{Cat}$ tiene regiones dadas por categorías. Una cuerda
entre dos regiones es un funtor, y los funtores forman una categoría
con la composición de funtores.  Un nodo viene dado por una transformación
natural, que convierte la composición de varios funtores en otra composición
de funtores.  Por ejemplo, una mónada resulta de dibujar un monoide en esta
categoría.
\begin{center}
\begin{tabular}{c c c c}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=below:\ensuremath{\mu}]
 (eta) ++(-1,-1) coordinate (a) ++(0,-1) coordinate[label=below:{$T$}] (tl)
 (eta) ++(1,-1) coordinate (b) ++(0,-1) coordinate[label=below:{$T$}] (tr)
 (eta) ++(0,2) coordinate[label=above:{$T$}] (e);
\draw[black] (tl) -- (a) to[out=90, in=180] (eta.east);
\draw[black] (eta.west) to[out=0, in=90] (b) -- (tr);
\draw[black] (eta) -- (e);
\begin{pgfonlayer}{background}
\fill[blue!20] ($(eta) + (-3,2)$) rectangle ($(eta) + (3,-2)$);
\end{pgfonlayer}
\end{tikzpicture} &
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=below:\ensuremath{\eta}]
 (eta) ++(0,2) coordinate[label=above:{$T$}] (e)
 (eta) ++(0,-2) coordinate[label=below:{$\phantom{t}$}] (ep);
\draw[black] (eta) -- (e);
\begin{pgfonlayer}{background}
\fill[blue!20] ($(eta) + (-2,2)$) rectangle ($(eta) + (2,-2)$);
\end{pgfonlayer}
\end{tikzpicture}
\end{tabular}
\end{center}
En otras palabras, una mónada viene determinada por una transformación
natural llamada /multiplicación/ $\mu \colon T \circ T \tonat T$ y una transformación natural
llamada /unidad/ $\eta \colon 1 \tonat T$, donde $1$ es el funtor identidad.  Esto son dos
familias de funciones indexadas sobre los objetos de una categoría $c \in \mathbf{C}$,
donde la multiplicación es $\mu_c \colon T(T(c)) \to T(c)$ y la unidad es $\eta_c \colon c \to T(c)$.
Cumplirán además los axiomas de un monoide.
#+end_ejemplo

#+begin_ejemplo
Una dualidad en la bicategoría $\mathbf{Cat}$ se llama *adjunción*.  Por el Ejemplo [[ejemplo-dualidad-monoide]],
sabemos entonces que toda adjunción $F \dashv G$ da lugar a una mónada $G \circ F$.

Es decir, estos diagramas de cite:marsden14 representan una adjunción.
\begin{center}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=above:\ensuremath{\eta}] 
 (eta) ++(-1,1) coordinate (a) ++(0,0.5) coordinate[label=above:\ensuremath{F}] (tl)
 (eta) ++(1,1) coordinate (b) ++(0,0.5) coordinate[label=above:\ensuremath{G}] (tr);
\draw (tl) -- (a) to[out=-90, in=180] (eta.west) -- (eta.east) to[out=0, in=-90] (b) -- (tr);
\begin{pgfonlayer}{background}
\fill[catc] ($(tl) + (-1,0)$) rectangle ($(tr) + (1,-2)$);
\fill[catd] (tl) -- (a) to[out=-90, in=180] (eta.west) -- (eta.east) to[out=0, in=-90] (b) -- (tr) -- cycle;
\fill[white] ($(tl) + (-1,-2)$) rectangle ($(tr) + (1,-3)$);
\end{pgfonlayer}
\end{tikzpicture}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=below:\ensuremath{\epsilon}] 
 (epsilon) ++(-1,-1) coordinate (a) ++(0,-0.5) coordinate[label=below:\ensuremath{G}] (bl)
 (epsilon) ++(1,-1) coordinate (b) ++(0,-0.5) coordinate[label=below:\ensuremath{F}] (br);
\draw (bl) -- (a) to[out=90, in=180] (epsilon.west) -- (epsilon.east) to[out=0, in=90] (b) -- (br);
\begin{pgfonlayer}{background}
\fill[catd] ($(bl) + (-1,0)$) rectangle ($(br) + (1,2)$);
\fill[catc] (bl) -- (a) to[out=90, in=180] (epsilon.west) -- (epsilon.east) to[out=0, in=90] (b) -- (br) -- cycle;
\end{pgfonlayer}
\end{tikzpicture}
\end{center}

La unitalidad de la mónada se demuestra gracias al zig-zag.
\begin{equation*}
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=above:$\eta$] (eta) ++(2,1) coordinate[dot, label=below:$\epsilon$] (epsilon)
 ++(1,-1) coordinate (a) ++(0,-0.5) coordinate[label=below:$F$] (bl)
 (eta) ++(-1,1) coordinate (b) ++(0,0.5) coordinate[label=above:$F$] (tl)
 (bl) ++(1,0) coordinate[label=below:$G$] (br) ++(0,2) coordinate[label=above:$G$] (tr);
\draw (tl) -- (b) to[out=-90, in=180] (eta.west) -- (eta.east) to[out=0, in=180] (epsilon.west) -- (epsilon.east) to[out=0, in=90] (a) -- (bl);
\draw (br) -- (tr);
\begin{pgfonlayer}{background}
\fill[catc] ($(tl) + (-1,0)$) rectangle ($(br) + (1,0)$);
\fill[catd] (tl) -- (b) to[out=-90, in=180] (eta.west) -- (eta.east) to[out=0, in=180] (epsilon.west) -- (epsilon.east) to[out=0, in=90] (a) -- (bl) -- (br) -- (tr) -- cycle;
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}=
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[label=above:$F$] (tl) ++(1,0) coordinate[label=above:$G$] (tr)
 (tl) ++(0,-2) coordinate[label=below:$F$] (bl)
 (tr) ++(0,-2) coordinate[label=below:$G$] (br);
\draw (bl) -- (tl)
 (br) -- (tr);
\begin{pgfonlayer}{background}
\fill[catc] ($(tl) + (-1,0)$) rectangle (bl);
\fill[catc] ($(tr) + (1,0)$) rectangle (br);
\fill[catd] (tl) rectangle (br);
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
=
\begin{gathered}
\begin{tikzpicture}[scale=0.5]
\path coordinate[dot, label=above:$\eta$] (eta) ++(-2,1) coordinate[dot, label=below:$\epsilon$] (epsilon)
 ++(-1,-1) coordinate (a) ++(0,-0.5) coordinate[label=below:$G$] (br)
 (eta) ++(1,1) coordinate (b) ++(0,0.5) coordinate[label=above:$G$] (tr)
 (br) ++(-1,0) coordinate[label=below:$F$] (bl) ++(0,2) coordinate[label=above:$F$] (tl);
\draw (tr) -- (b) to[out=-90, in=0] (eta.east) -- (eta.west) to[out=180, in=0] (epsilon.east) -- (epsilon.west) to[out=180, in=90] (a) -- (br)
 (bl) -- (tl);
\begin{pgfonlayer}{background}
\fill[catc] ($(bl) + (-1,0)$) rectangle ($(tr) + (1,0)$);
\fill[catd] (tr) -- (b) to[out=-90, in=0] (eta.east) -- (eta.west) to[out=180, in=0] (epsilon.east) -- (epsilon.west) to[out=180, in=90] (a) -- (br)
 -- (bl) -- (tl) -- cycle;
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
\end{equation*}
Y la asociatividad gracias a las isotopías.
\begin{equation*}
\begin{gathered}
\begin{tikzpicture}[auto,scale=0.3]
\path (0,-2.5) coordinate (base) 
 (-1.5,-1) coordinate[dot, label=below:$\epsilon$] 
 (epsilon1) ++(-1,-1) coordinate (a)
 (epsilon1) ++(1,-1) coordinate (b)
 (1.5,1) coordinate[dot, label=below:$\epsilon$] (epsilon2)
 (epsilon2) ++(-1,-1) coordinate (c)
 (epsilon2) ++(1,-1) coordinate (d);
\path let \p1 = (base) in
      let \p2 = (a) in
      let \p3 = (b) in
      let \p4 = (c) in
      let \p5 = (d) in
 coordinate[label=below:$G$] (bll) at (\x2, \y1)
 coordinate[label=below:$F$] (bl) at (\x3, \y1)
 coordinate[label=below:$G$] (br) at (\x4, \y1)
 coordinate[label=below:$F$] (brr) at (\x5, \y1);
\path 
 (bll) ++(-1,0) coordinate[label=below:$F$] (blll) ++(0,4) coordinate[label=above:$F$] (tlll)
 (brr) ++(1,0) coordinate[label=below:$G$] (brrr) +(0,4) coordinate[label=above:$G$] (trrr);
\draw (bll) -- (a) to[out=90, in=180] (epsilon1.west) -- (epsilon1.east) to[out=0, in=90] (b) -- (bl)
      (br) -- (c) to[out=90, in=180] (epsilon2.west) -- (epsilon2.east) to[out=0, in=90] (d) -- (brr)
 (blll) -- (tlll)
 (brrr) -- (trrr);
\begin{pgfonlayer}{background}
\fill[catd] ($(blll) + (-1,0)$) rectangle ($(trrr) + (1,0)$);
\fill[catc] ($(blll) + (-1,0)$) rectangle (tlll);
\fill[catc] ($(brrr) + (1,0)$) rectangle (trrr);
\fill[catc] (bll) -- (a) to[out=90, in=180] (epsilon1.west) -- (epsilon1.east) to[out=0, in=90] (b) -- (bl) -- cycle;
\fill[catc] (br) -- (c) to[out=90, in=180] (epsilon2.west) -- (epsilon2.east) to[out=0, in=90] (d) -- (brr) -- cycle;
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
=
\begin{gathered}
\begin{tikzpicture}[auto,scale=0.3]
\path (0,-2.5) coordinate (base) 
 (-1.5,0) coordinate[dot, label=below:$\epsilon$] 
 (epsilon1) ++(-1,-1) coordinate (a)
 (epsilon1) ++(1,-1) coordinate (b)
 (1.5,0) coordinate[dot, label=below:$\epsilon$] (epsilon2)
 (epsilon2) ++(-1,-1) coordinate (c)
 (epsilon2) ++(1,-1) coordinate (d);
\path let \p1 = (base) in
      let \p2 = (a) in
      let \p3 = (b) in
      let \p4 = (c) in
      let \p5 = (d) in
 coordinate[label=below:$G$] (bll) at (\x2, \y1)
 coordinate[label=below:$F$] (bl) at (\x3, \y1)
 coordinate[label=below:$G$] (br) at (\x4, \y1)
 coordinate[label=below:$F$] (brr) at (\x5, \y1);
\path 
 (bll) ++(-1,0) coordinate[label=below:$F$] (blll) ++(0,4) coordinate[label=above:$F$] (tlll)
 (brr) ++(1,0) coordinate[label=below:$G$] (brrr) +(0,4) coordinate[label=above:$G$] (trrr);
\draw (bll) -- (a) to[out=90, in=180] (epsilon1.west) -- (epsilon1.east) to[out=0, in=90] (b) -- (bl)
      (br) -- (c) to[out=90, in=180] (epsilon2.west) -- (epsilon2.east) to[out=0, in=90] (d) -- (brr)
 (blll) -- (tlll)
 (brrr) -- (trrr);
\begin{pgfonlayer}{background}
\fill[catd] ($(blll) + (-1,0)$) rectangle ($(trrr) + (1,0)$);
\fill[catc] ($(blll) + (-1,0)$) rectangle (tlll);
\fill[catc] ($(brrr) + (1,0)$) rectangle (trrr);
\fill[catc] (bll) -- (a) to[out=90, in=180] (epsilon1.west) -- (epsilon1.east) to[out=0, in=90] (b) -- (bl) -- cycle;
\fill[catc] (br) -- (c) to[out=90, in=180] (epsilon2.west) -- (epsilon2.east) to[out=0, in=90] (d) -- (brr) -- cycle;
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
=
\begin{gathered}
\begin{tikzpicture}[auto,scale=0.3]
\path (0,-2.5) coordinate (base) 
 (-1.5,1) coordinate[dot, label=below:$\epsilon$] 
 (epsilon1) ++(-1,-1) coordinate (a)
 (epsilon1) ++(1,-1) coordinate (b)
 (1.5,-1) coordinate[dot, label=below:$\epsilon$] (epsilon2)
 (epsilon2) ++(-1,-1) coordinate (c)
 (epsilon2) ++(1,-1) coordinate (d);
\path let \p1 = (base) in
      let \p2 = (a) in
      let \p3 = (b) in
      let \p4 = (c) in
      let \p5 = (d) in
 coordinate[label=below:$G$] (bll) at (\x2, \y1)
 coordinate[label=below:$F$] (bl) at (\x3, \y1)
 coordinate[label=below:$G$] (br) at (\x4, \y1)
 coordinate[label=below:$F$] (brr) at (\x5, \y1);
\path 
 (bll) ++(-1,0) coordinate[label=below:$F$] (blll) ++(0,4) coordinate[label=above:$F$] (tlll)
 (brr) ++(1,0) coordinate[label=below:$G$] (brrr) +(0,4) coordinate[label=above:$G$] (trrr);
\draw (bll) -- (a) to[out=90, in=180] (epsilon1.west) -- (epsilon1.east) to[out=0, in=90] (b) -- (bl)
      (br) -- (c) to[out=90, in=180] (epsilon2.west) -- (epsilon2.east) to[out=0, in=90] (d) -- (brr)
 (blll) -- (tlll)
 (brrr) -- (trrr);
\begin{pgfonlayer}{background}
\fill[catd] ($(blll) + (-1,0)$) rectangle ($(trrr) + (1,0)$);
\fill[catc] ($(blll) + (-1,0)$) rectangle (tlll);
\fill[catc] ($(brrr) + (1,0)$) rectangle (trrr);
\fill[catc] (bll) -- (a) to[out=90, in=180] (epsilon1.west) -- (epsilon1.east) to[out=0, in=90] (b) -- (bl) -- cycle;
\fill[catc] (br) -- (c) to[out=90, in=180] (epsilon2.west) -- (epsilon2.east) to[out=0, in=90] (d) -- (brr) -- cycle;
\end{pgfonlayer}
\end{tikzpicture}
\end{gathered}
\end{equation*}
El ejemplo común de una situación como esta lo dan el funtor que crea
la mónada libre sobre un conjunto $F \colon \mathbf{Set} \to \mathbf{Mon}$ y el funtor de
olvido $G \colon \mathbf{Mon} \to \mathbf{Set}$. La mónada $G \circ F$ se llama en programación
funcional la *mónada Lista* (/List monad/).

De forma dual, podemos definir comónadas y demostrar que toda adjunción
$F \dashv G$ da lugar a una comónada $F \circ G$.
#+end_ejemplo


*** Conclusión
Tenemos la siguiente tabla y nada nos impide continuar hacia más
dimensiones y más colores.  Calcular manipulaciones de diagramas en
dimensiones arbitrarias es lo que hace el asistente [[https://homotopy.io/][homotopy.io]] cite:homotopyio
de Vicary-Hu-Liss.

|---------------------+---------------+-------------+--------------------|
| Estructuras         | 0 dimensiones | 1 dimensión | 2 dimensiones      |
|---------------------+---------------+-------------+--------------------|
| Blanco y negro      | Conjunto      | Monoide     | PRO                |
| Cuerdas coloreadas  |               | Categoría   | Categoría monoidal |
| Regiones coloreadas |               |             | Bicategoría        |
|---------------------+---------------+-------------+--------------------|

Una estructura tricolor, por ejemplo, nos permite llegar a
tricategorías y bicategorías monoidales.

*** references                                                                            :ignore:
bibliographystyle:alpha
bibliography:Math.bib

** Lawvere's fixed point theorem                                                             :post:
:PROPERTIES:
:TITLE: Lawvere's fixed point theorem
:EXPORT_FILE_NAME: lawverefixedpoint.html
:INDEX_DATE: <2019-02-28 Mon 10:23>
:END:

This is a note stating the main result 
from [[http://tac.mta.ca/tac/reprints/articles/15/tr15.pdf][Diagonal arguments and Cartesian Closed Categories]] by
William Lawvere.

*Definition.* A morphism s : X → Y is /point-surjective/ if for each y : 1
→ Y, there exists some x : 1 → X such that sx = y.

*Theorem* (Lawvere, 1969). In any cartesian closed category, if there exists a
point-surjective morphism d : A → (A → B), then each morphism f : B →
B has a fixed point, that is, some b : B such that f b = b.

*Proof.* As d is point-surjective, there exists x : A such that dx =
λa.f(daa), but then, dxx = (λa.f(daa)) x = f(dxx) is a fixed point.

** Apuntes de Haskell                                                                        :post:
:PROPERTIES:
:TITLE: Apuntes de Haskell
:EXPORT_FILE_NAME: apuntesdehaskell.html
:INDEX_DATE: <2019-02-27 Mon 21:00>
:END:

Hace ya un tiempo, [[https://github.com/mx-psi][@mx-psi]] y yo escribimos estos 
[[https://github.com/libreim/haskell][apuntes de introducción a Haskell]].  Los hemos usado varias veces
en los seminarios de LibreIM, [[https://github.com/pedritomelenas][Pedro García-Sánchez]] añadió un 
[[https://github.com/libreim/haskell/blob/3acbc2f7088483d3ba69ecdc00891c8419341aaf/PrimeraParte/PrimeraParte.ipynb][cuaderno de Jupyter]] para acompañarlos, y finalmente [[https://github.com/mx-psi][@mx-psi]] ha vuelto a revisarlos
y dejarlos listos para otro seminario este año. 

** Diagramas para categorías monoidales                                                      :post:
:PROPERTIES:
:TITLE: Diagramas para categorías monoidales
:EXPORT_FILE_NAME: diagramascategoriasmonoidales.pdf
:INDEX_DATE: <2019-01-21 Mon 19:01>
:END:

Este es un post de enlaces sobre lenguajes diagramáticos. Me temo que
todo el material está en inglés, pero quería tener una nota sobre el
tema que no estuviera en inglés. \\

Vamos a motivarlos primero siguiendo un ejemplo de cite:coecke17; la
explicación de todo está en el libro, aquí sólo quiero dar una idea.
Supongamos que tenemos los siguientes ingredientes representados en un
diagrama. Dos partes (Alice y Bob) comparten un /estado/ común
representado como un cable en forma de U. Alice tiene además cierta información propia
ψ que quiere enviar a Bob. Por último,
Alice puede tomar dos estados y hacerlos iguales introduciendo un
error en el proceso.  Bob puede corregir este error una vez Alice le
informa de él. Todos los procesos se representan como cajas con una
serie de entradas (abajo) y salidas (arriba). El eje y se interpreta
como una línea temporal de abajo a arriba.

#+attr_latex: :width 5cm
#+caption: Los ingredientes.
[[./alicebob1.jpg]]

¿Cómo combinamos estas piezas? La respuesta obvia es el siguiente
diagrama. Aquí, Alice toma el estado que quiere enviar y el estado
compartido y los hace iguales introduciendo un error; Bob corrige
este error. Las siguientes igualdades son válidas en el cálculo
diagramático y muestran que esto es equivalente a que Bob acabe
teniendo la información que Alice le quería mandar.

#+caption: La solución.
[[./alicebob2.jpg]]

Este diagrama puede traducirse formalmente a un morfismo en una
categoría con suficiente estructura (explícitamente, a una categoría
monoidal cerrada compacta, pero no necesitamos detalles).  La
categoría de conjuntos cuyos morfismos son relaciones, *Rel*, tiene esa
estructura; y cuando interpretamos este diagrama obtenemos el
protocolo de /libreta de un solo uso/ (one-time pad).  La categoría de
espacios de Hilbert con matrices unitarias tiene esa estructura
también, y cuando interpretamos el morfismo ¡obtenemos un protocolo de
/teleportación cuántica/!  Es decir, un poco de razonamiento
diagramático nos ha servido para obtener en abstracto un protocolo y
descubrir que dos protocolos conocidos son dos de sus instancias
particulares en distintas categorías. Podríamos estudiar otros
protocolos, y podríamos interpretarlos en otras categorías. ¿Qué más
podemos hacer con diagramas?, lo que sigue es una lista no exhaustiva.

 * *Álgebra lineal.* Un ejemplo perfecto de categorías con esta estructura
   son los espacios vectoriales. En el blog [[https://graphicallinearalgebra.net/][Graphical Linear Algebra]],
   [[https://www.southampton.ac.uk/~ps1a06/][Pawel Sobocinski]] da una introducción informal al álgebra
   lineal y al razonamiento diagramático.

 * *Mecánica cuántica diagramática.* /Picturing Quantum Processes/, de [[https://www.cs.ox.ac.uk/people/bob.coecke/][Coecke]] y [[http://www.cs.ru.nl/A.Kissinger/][Kissinger]]
   cite:coecke17, de donde viene el primer ejemplo. Es una introducción
   elemental que no asume prácticamente ningún conocimiento previo: ni de
   mecánica cuántica ni de diagramas. Profundiza mucho en los diagramas en sí y
   no requiere conocer la teoría de categorías subyacente.

 * *Mecánica cuántica categórica.* /Categorical Quantum Mechanics ([[https://www.cs.ox.ac.uk/files/10510/notes.pdf][link]]),/ de
   [[https://www.cs.ox.ac.uk/people/jamie.vicary/][Vicary]] y [[http://homepages.inf.ed.ac.uk/cheunen/teaching.html][Heunen]] da otra introducción a las aplicaciones en
   mecánica cuántica. Enfatiza mucho más la teoría de categorías, aquí
   sí es un prerrequisito haber leído teoría de categorías. Como bonus,
   hay un estudio muy detallado de cómo las categorías justifican el
   razonamiento diagramático.

 * *Teoría de categorías*. /Category theory with string diagrams/, de [[https://www.cs.ox.ac.uk/people/dan.marsden/][Marsden]],
   es muy accesible y explica 2-categorías, adjunciones, mónadas e incluso 
   límites; usando razonamiento gráfico.

 * *Lingüística.* /Distributional compositional categorical semantics/ es
   un marco teórico para calcular el significado de las frases en función
   del significado de las palabras. Es /distribucional/ porque el significado
   de una palabra se calcula según las palabras que aparecen cerca de ella
   en un corpus de texto suficientemente grande; es /composicional/ porque
   podemos componer esos significados usando la estructura categórica para
   calcular el significado de frases completas. Una introducción es
   cite:coecke10 de [[https://www.cs.ox.ac.uk/people/bob.coecke/][Coecke]], [[http://www.eecs.qmul.ac.uk/profiles/sadrzadehmehrnoosh.html][Sadrzadeh]] y [[https://sites.google.com/site/stephenclark609/][Clark]].

 * *Teoría de juegos*, usando una categoría de [[https://julesh.com/2018/08/16/lenses-for-philosophers/][lentes]]. Hay una [[https://www.youtube.com/watch?v=C64905vTT3s&feature=youtu.be][charla introductoria]]
   de Jules Hedges y varios artículos como cite:hedges18.
   
Por último, una visión general de los lenguages diagramáticos es cite:selinger10.

*** references                                                                            :ignore:
bibliographystyle:alpha
bibliography:Math.bib

** dotfiles in a single org-file                                                             :post:
:PROPERTIES:
:TITLE: dotfiles in a single org-file
:EXPORT_FILE_NAME: dotfilesinasingleorg.html
:INDEX_DATE: <2019-01-21 Mon 19:01>
:END:

I was thinking that it would be nice to have all your configuration
files on a single, literate, org-mode file... and actually it should
be really easy to make it work: take an org file and create an org-babel block 
for the contents of each configuration file. They can be tangled
back into the filesystem using the property =:tangle /path/tofile=,
where =/path/tofile= is the desired location of the config file.
If =sudo= is needed, =tramp= can be used with =:tangle /sudo::/path/tofile=.

For instance, this is how =.Xresources= looks now inside my org file.
Highlighting works perfectly thanks to org-babel.

#+BEGIN_EXAMPLE
 ** X resources
 
 Configuration parameters for X client applications.

 #+BEGIN_SRC conf /home/mario/.Xresources
 xterm*font: *-fixed-*-*-*-24-*
 Xft.dpi:    192
 #+END_SRC
#+END_EXAMPLE

This file can be put under version control and a /dotfiles repository/
can be created without having to use hard links (yep, I was doing that
until now).

As always with Emacs, this use case is obvious in retrospect, but /why
didn't anyone tell me?/

** Every surjection to a projective R-module is split                                        :post:
:PROPERTIES:
:TITLE: Every surjection to a projective R-module is split
:EXPORT_FILE_NAME: everysurjectiontoprojectiveissplit.pdf
:INDEX_DATE: <2018-12-24 Sun 09:07>
:END:

/The statement comes from an exercise on André Henriques' course on/
/[[https://courses.maths.ox.ac.uk/node/36705][Homological Algebra]]/.

#+begin_statement
Let $R$ be a ring. Prove that an $R\mathrm{-module}$ $P$ is projective iff every surjective
map $A \to P$ admits a section.
#+end_statement

Given a projective module $P$, we can apply the definition to any surjection
$f \colon A \twoheadrightarrow P$ to get the existence of a section.
\[\begin{tikzcd}
& P \dar{\mathrm{id}} \dlar[dashed,swap]{\exists s}\\
A \rar{f} & P 
\end{tikzcd}\]
Suppose every surjection admits a section, we can take a surjection from the
free module over $P$, which we call $\pi \colon F \to P$ and take a section $s \colon P \to F$.
Then the sequence $0 \to \mathrm{ker}(\pi) \to F \to P \to 0$ splits,
$P$ is a direct summand of a free module and thus a projective module.

** Hom is continuous and then all right adjoints are                                         :post:
:PROPERTIES:
:TITLE: Hom is continuous
:EXPORT_FILE_NAME: homcontinuous.pdf
:INDEX_DATE: <2018-12-23 Sun 16:20>
:END:

/This is an exercise on Samson Abramsky's notes/
/on the course Categories, Proofs and Processes./ cite:abramsky10 \\

#+begin_statement
Let $A$ be an object in the category ${\cal C}$. Show that the covariant $\mathrm{hom}$ functor
${\cal C}(A,-)$, as defined in Lecture III, preserves all limits.
#+end_statement
#+begin_proof
Let ${\cal I}$ be a small category, $F \colon {\cal I} \to {\cal C}$ a functor and let $L$ with the
morphisms $(l_{I})_{I \in {\cal I}}$ be the limit of that functor. We know that for every
morphism $i \colon I \to J$ in ${\cal I}$, we have $l_J = Fi\circ l_I$.

Let $Z$ be a set with a family of morphisms $f_I \colon Z \to {\cal C}(A,FI)$ determining
a cone to ${\cal C}(A,F-) \colon {\cal I} \to \mathbf{Sets}$; that is, such that for each $i \colon I \to J$ in ${\cal I}$, we 
have that $f_J = (Fi \circ -) \circ f_I$; or, in other words, for each $z \in Z$ we have
$f_J(z) = Fi \circ f_I(z)$. Thus, fixing any $z \in Z$ gives as a family of morphisms
$f_I(z) \in {\cal C}(A,FI)$ defining a cone. This implies that there exists some
unique morphism $a(z) \colon A \to L$ such that $l_{I} \circ a(z) = f_I(z)$.

Repeating this for every $z \in Z$ we have obtained a function $a \colon Z \to {\cal C}(A,L)$
with the property $l_I \circ a = f_I$. This function must be the unique one with this
property, because for any other $a' \colon Z \to {\cal C}(A,L)$, for each $z \in Z$ 
we would have $l_I \circ a'(z) = f_I(z)$ and that would imply that $a'(z) = a(z)$.
#+end_proof

#+begin_proposition
Right adjoints preserve limits.
#+end_proposition
#+begin_proof
(From cite:awodey10) Let $L \colon \mathbb{C} \to \mathbb{D}$ and $R \colon \mathbb{D} \to \mathbb{C}$ be a pair of adjoints
$L \dashv R$. Let $X_i$ be objects determining any diagram and $Y$ an arbitrary object.
We have the following chain of natural transformations between
hom-sets.
\[\begin{aligned}
\hom(Y,R \lim X_i) &\cong \hom(LY,\lim X_i) \\
&\cong \lim\hom(LY,X_i) \\
&\cong \lim\hom(Y,RX_i) \\
&\cong \hom(Y,\lim RX_i)
\end{aligned}\]
By Yoneda Lemma, $R\lim X_i \cong \lim RX_i$.
#+end_proof

*** references                                                                            :ignore:
bibliographystyle:alpha
bibliography:Math.bib

** Pasting pullbacks                                                                         :post:
:PROPERTIES:
:TITLE: Pasting pullbacks
:EXPORT_FILE_NAME: pastingpullbacks.pdf
:INDEX_DATE: <2018-12-23 Sun 16:09>
:END:

/This is an exercise on Samson Abramsky's notes/
/on the course Categories, Proofs and Processes./ cite:abramsky10 \\

#+begin_proposition
In the following commutative diagram, 
if $ABCD$ and $BEDF$ are pullback squares, so is $AECF$.
\[\begin{tikzcd}
A \rar\dar & B \rar\dar & E \dar \\
C \rar & D \rar & F
\end{tikzcd}\]
#+end_proposition
#+begin_proof
Given some $u \colon Z \to E$ and $v \colon Z \to C$ such that $tu = dcv$, we can use 
the pullback to construct some $Z \to B$ and the other pullback to construct
some $Z \to A$. This proves existence.  Given two morphisms $z$ and $z'$ such that
$baz = u = baz'$ and $rz = v = rz'$, as in the following diagram, we will prove
they are equal.
\[\begin{tikzcd}
Z\ar[dashed,bend left]{drr}{w} \drar[dashed,bend left]{z} \drar[dashed,bend right]{z'} \ar[bend left]{rrrd}{u} \ar[bend right]{ddr}{v} &&&\\
& A \rar{a}\dar{r} & B \rar{b}\dar{s} & E \dar{t} \\
& C \rar{c} & D \rar{d} & F
\end{tikzcd}\]
By the universal property of the pullback $BEDF$ there is a unique morphism
$w \colon Z \to B$ such that $bw = u$ and $sw = cv$, but $baz = baz' = u$ and
$saz = crz = cv = crz' = saz'$, so $az = az'$. Then using the pullback $ABCD$,
there would be a unique morphism $y \colon Z \to A$ such that $ay = az$ and $v = ry$, 
but both $z$ and $z'$ satisfy this condition and thus they are equal.
#+end_proof

#+begin_proposition
In the following commutative diagram, 
if $BEDF$ and $AECF$ are pullback squares, so is $ABCD$.
\[\begin{tikzcd}
A \rar\dar & B \rar\dar & E \dar \\
C \rar & D \rar & F
\end{tikzcd}\]
#+end_proposition
#+begin_proof
Given some $u \colon Z \to B$ and $v \colon Z \to C$ such that $su = cv$, we
can apply the universal property of the pullback $AECF$ to the
maps $bu$ and $v$, which satisfy $tbu = dsu = dcv$, to construct some
$z \colon Z \to A$ such that $baz = bu$ and $v = rz$.

By the universal property of $BEDF$, there exists a unique $y$
such that $by = bu$ and $sy = cv$, but both $az$ and $u$ satisfy that,
and thus they are equal. This proves existence.
\[\begin{tikzcd}
Z\drar[dashed,bend left]{z} \drar[dashed,bend right]{z'} \ar[bend left]{rrd}{u} \ar[bend right]{ddr}{v} &&&\\
& A \rar{a}\dar{r} & B \rar{b}\dar{s} & E \dar{t} \\
& C \rar{c} & D \rar{d} & F
\end{tikzcd}\]
Given two morphisms $z,z' \colon Z \to A$ such that $az = u = az'$ and
$rz = rz' = v$; we know by the universal property of the pullback
$AECF$ applied to $bu$ and $v$ that there is a unique morphism $x \colon Z \to A$
such that $bax = bu$ and $v = rx$; and thus they must be equal.
#+end_proof


*** references                                                                            :ignore:
bibliographystyle:alpha
bibliography:Math.bib

** Linear logic is quantity-sensitive                                                        :post:
:PROPERTIES:
:TITLE: Linear logic is quantity-sensitive
:EXPORT_FILE_NAME: countinginlinearlogic.pdf
:INDEX_DATE: <2018-12-23 Sun 15:50>
:END:

/This is an exercise on Samson Abramsky's notes/
/on the course Categories, Proofs and Processes./ cite:abramsky10 \\

The main idea here is that we can formalize the notion that linear
logic is sensitive to the number of ocurrences of each variable
using the model it has on groups, which are particular cases of
symmetric monoidal closed categories.

#+begin_statement
Can you construct proofs in Linear Logic of the following sequents?

 * $A \vdash A \otimes A$
 * $\vdash (A \multimap (A \multimap B)) \multimap (A \multimap B)$
 * $\vdash A \multimap (B \multimap A)$
#+end_statement

Consider the discrete category of the integers with the monoidal
structure given by addition, which is associative, and $0$ as the unit.
With this we can construct the structural isomorphisms as identities.
This is a symmetric category because addition is commutative. It
is monoidal closed with $(a \multimap b) = b - a$ because we have the following
adjunction, where morphisms represent equalities.
\begin{prooftree}
\AXC{$a + b = c$}
\UIC{$a = c - b$}
\end{prooftree}
Naturality of the structural isomorphisms and of the
adjunction follow from the fact that we are in a discrete category. \\

Now, neither $a = a + a$, $0 = (b-a) - ((b-a)-a) = a$, nor $0 = (a-b)-a = -b$
are true in general. It is impossible to create a morphism of
these types in a symmetric monoidal closed category in general. \\

This shows that linear logic is resource sensitive.  We could assume
that each object has a weight and that morphisms have to be
balanced.  The interpretation on integers precisely reflects this
'weight'.

*** references                                                                            :ignore:
bibliographystyle:alpha
bibliography:Math.bib

** Powerset-algebras are complete semilattices                                               :post:
:PROPERTIES:
:TITLE: Powerset-algebras are complete semilattices
:EXPORT_FILE_NAME: powersetalgebrascompletesemilattices.pdf
:INDEX_DATE: <2018-12-23 Sun 13:10>
:END:

/This is a combination of two exercises from Samson Abramsky's notes/
/on the course Categories, Proofs and Processes./ cite:abramsky10 \\

#+begin_definition
We take a *complete semilattice* to mean a poset $(P, \leq)$ where every
subset $S \subseteq P$ has a least upper bound we write as $\bigvee S$. That is to
say that it is a category with at most one morphism between any two
objects that has all coproducts.
#+end_definition

A morphism between complete semilattices is a map between posets that
preserves all least upper bounds, that is $h \left( \bigvee S \right) = \bigvee h(S)$, where we
write $h(S) = \left\{ h(x) \mid x \in S \right\}$. This property implies monotonicity: note
that from $x \leq y$ we get $h(y) = h(x \vee y) = h(x) \vee h(y)$, and thus $h(x) \leq h(y)$.
We have created a category of complete semilattices with morphisms
between them that we call $\mathbf{SL}$. There is a forgetful functor $U \colon \mathbf{SL} \to \mathbf{Set}$
assigning the underlying set to each poset.

*** Free-forgetful adjunction
#+begin_proposition
The forgetful functor $U \colon \mathbf{SL} \to \mathbf{Set}$ has a left adjoint.
#+end_proposition
#+begin_proof
We will show that the left adjoint is the functor ${\cal P} \colon \mathbf{Set} \to \mathbf{SL}$ sending each set to its powerset
ordered by inclusion, which is a complete semilattice because
the union of a family of sets is its least upper bound. Given 
two sets $A$ and $B$, any
function $f \colon A \to B$ induces a $f^{\ast} \colon {\cal P}A \to {\cal P}B$
sending a subset to its image under $f$; this constitutes the action
of the functor on morphisms. We can check that this
is a morphism of complete semilattices because, for any family
${\cal X} \subseteq {\cal P}(A)$, we have

\[
f^{\ast} \left( \bigcup_{Y \in {\cal X}} Y \right) = 
\left\{ f(y) \;\middle|\; y \in \bigcup_{Y \in {\cal X}} Y \right\} =
\bigcup_{Y \in {\cal X}} \left\{ f(y) \mid y \in  Y \right\} =
\bigcup_{Y \in {\cal X}} f^{\ast}(Y).
\]

To construct the adjunction, we start by defining an isomorphism $\mathbf{Set}(A,UB) \to \mathbf{SL}({\cal P}A,B)$ that sends
$f \colon A \to B$ to the function that acts on some $Y \subseteq A$ as

\[
\overline{f}(Y) = \bigvee_{y \in Y} f(y).
\]

This is a morphism of complete semilattices because for any family
of subsets ${\cal X} \subseteq {\cal P}(A)$ we have

\[
\overline{f} \left( \bigcup_{Y \in {\cal X}} Y  \right) =
\bigvee_{y \in \bigcup_{Y \in {\cal X}} Y} f(y) =
\bigvee_{Y \in {\cal X}} \bigvee_{y \in Y} f(y) =
\bigvee_{Y \in {\cal X}} \overline{f}(Y)
\]

This isomorphism has an inverse sending each morphism $h \colon {\cal P}(A) \to B$ to
the function $A \to B$ defined as $a \mapsto h(\left\{ a \right\})$. We
can check that these are in fact inverses because for any $f \colon A \to B$
and $a \in A$ we have

\[
\overline{f}(\left\{ a \right\}) = \bigvee_{a \in \left\{ a \right\}} f(a) = f(a)
\]

and for any semilattice morphism $h \colon {\cal P}(A) \to B$ we have for any $X \subseteq A$,
using that it preserves least upper bounds, that

\[
\overline{h(\{-\})}(X) =
\bigvee_{x \in X} h(\left\{ x \right\}) = 
h \left( \bigvee_{x \in X} \left\{ x \right\} \right) = 
h(X).
\]

We now show that the isomorphism is in fact natural. Given any
$f \colon A \to UB$, any function $a \colon A' \to A$ and any morphism of semilattices
$b \colon B \to B'$, we have for a given $Y \in {\cal P}(A)$ that

\[
b \overline{f} a^{\ast}(Y) = b \left( \bigvee_{y \in Y}f(a(y))  \right) =
\bigvee_{y \in Y} b f a(y) = \overline{b f a}(Y),
\]

because $b$ preserves least upper bounds. This proves that
$b\circ \overline{f} \circ a^{\ast} = \overline{b \circ f \circ a}$ and the isomorphism is thus natural.
#+end_proof

*** Powerset-algebras
Note that the powerset monad acts on objects as $U{\cal P}$, simply
taking the powerset and forgetting about its semilattice structure.
The unit of the adjunction, $a \mapsto \left\{ a \right\}$ is precisely the unit of the
monad, and the counit of the adjunction, the lattice homomorphism
$\bigvee \colon {\cal P}L \to L$ for any lattice $L$, is such that $U\bigvee_{{\cal P}} = \bigcup \colon {\cal P}{\cal P}A \to {\cal P}A$
is precisely the multiplication of the monad for any set $A$. \\

We can now prove that ${\cal P}\mbox{-algebras}$ are complete semilattices.
Note that an algebra would be a function $f \colon {\cal P}A \to A$ such that

\[
f \left\{ a \right\} = a, \qquad f \left( \bigcup_{i \in I} A_i \right) = f \left\{ f(A_i) \mid i \in I \right\},
\]

for any element $a \in A$ and any family of subsets $A_i \subseteq A$. We can define
a partial order where for any two elements $x,y \in A$, we have that $x \leq y$
when $f \left\{ x,y \right\} = y$. This satisfies

 * *reflexivity*, because $f \left\{ x,x \right\} = x$;
 * *transitivity*, because if $x \leq y \leq z$, then we have
   $f \left\{ x,z \right\} = f \left\{ f\{x\}, f\{y,z\} \right\} = f \left\{ x,y,z \right\} = f \left\{ f\{x,y\},f\{z\} \right\} = z$;
 * and *antisymmetry*, because $x \leq y \leq x$ implies $x = f \left\{ x,y \right\} = y$.

For this particular preorder, the function $f$ is the lowest great bound
$\bigvee$; this can be proved checking that, for any subset $S \subseteq A$,

 * for each $s \in S$, we have $f \left\{ s , f(S) \right\} = f(S \cup \left\{ s \right\})= f(S)$,
   so $s \leq f(S)$;
 * and given some $x \in A$ such that $s \leq x$ for all $s \in S$, we have
   $f \left\{ f(S),x \right\} = f \left( \bigcup_{s \in S} \left\{ s,x \right\} \right) = f \left\{ x \right\} = x$, and thus $f(S) \leq x$.

Finally, we can check that taking the lowest great bound on a subset
of a poset provides a valid algebra.

\[
\bigvee \left\{ a \right\} = a, \qquad
\bigvee \left( \bigcup_{i \in I} A_i \right) = \bigvee \left\{ \bigvee A_i \mid i \in I \right\}.
\]

Note that once we know that all algebras are of this form, a ${\cal P}\mbox{-algebra}$
morphism is precisely a function between complete semilattices $f \colon A \to B$
satisfying, $f \left( \bigvee A \right) = \bigvee f(A)$; that is, a complete semilattice morphism.

*** Monadicity theorem
This is also a consequence of Beck's monadicity theorem. The adjunction ${\cal P} \dashv U$ is
monadic and that implies that the comparison functor $\mathbf{SL} \to \mathbf{Set}^{{\cal P}}$ between complete
semilattices and powerset-algebras is an equivalence.

*** references                                                                            :ignore:
bibliographystyle:alpha
bibliography:Math.bib

** Picado's Interview with Lawvere                                                           :post:
:PROPERTIES:
:TITLE: Picado's Interview with Lawvere
:EXPORT_FILE_NAME: picadolawvereinterview.html
:INDEX_DATE: <2018-09-08 Sat 17:20>
:END:

[[http://www.mat.uc.pt/~picado/][Jorge Picado]] (who is also coauthor of the book on [[https://www.maa.org/press/maa-reviews/frames-and-locales-topology-without-points][locales]] I am reading) has
many nice 'popularisation of mathematics' articles on his webpage. I
have enjoyed a lot his interview with William Lawvere.

 * http://www.mat.uc.pt/~picado/lawvere/interview.pdf

Specially interesting is this criticism to the extra-mathematical
publicity around Gödel's theorem. However, I cannot locate exactly
what 'organized attempts' is he referring to.

#+BEGIN_QUOTE
In Diagonal arguments and Cartesian closed categories we demystified
the incompleteness theorem of Gödel and the truth-definition theory of
Tarski by showing that both are consequences of some very simple
algebra in the Cartesian-closed setting. It was always hard for many
to comprehend how Cantor’s mathematical theorem could be re-christened
as a “paradox” by Russell and how Gödel’s theorem could be so often
declared to be the most significant result of the 20th century.  There
was always the suspicion among scientists that such extra-mathematical
publicity movements concealed an agenda for re-establishing belief as
a substitute for science. Now, one hundred years after Gödel’s birth,
the organized attempts to harness his great mathematical work to such
an agenda have become explicit.
#+END_QUOTE

** A quote by Ampère                                                                         :post:
:PROPERTIES:
:TITLE: A quote by Ampère
:EXPORT_FILE_NAME: quoteampere.html
:INDEX_DATE: <2018-09-03 Mon 21:55>
:END:

/[Les langues] commencent par être una musique, et finissent par être une algèbre./ 
  -- [[https://fr.wikisource.org/wiki/Essai_sur_l%25E2%2580%2599histoire_de_la_langue_bretonne][M. Ampère]].

I am having a bit of trouble locating the exact source of this
sentence and I am also not sure in which sense should be interpreted;
but I somehow imagined that the idea of languages as algebras would
be more modern than this.

** LibreIM, casi cinco años después                                                          :post:
:PROPERTIES:
:TITLE: LibreIM, casi cinco años después
:EXPORT_FILE_NAME: libreimquintoaniversario.html
:INDEX_DATE: <2018-09-03 Mon 21:54>
:END:

Tengo un correo de diciembre de 2013 en el que David Charte consiguió
meter un foro de Moot en una página de Github. En julio de 2014 entre
Nacho Cordón, David Charte y yo perfilamos la idea de reunirnos en la
facultad; tuvimos mucha ayuda del departamento de álgebra; y el 27 de
septiembre de 2014 a las 10:00 en el A13 de Ciencias empezamos el
primer seminario, sobre teoría de categorías y Haskell, con Pablo
Baeyens en la segunda parte.

Llevamos 48 seminarios, y la asistencia ha ido creciendo poco a poco.
Me hace cierta ilusión que, aun con algún problema que otro, haya
funcionado.  Mientras sirvan para seguir poniendo ideas en común y
siga habiendo gente dispuesta a ir y a prepararlos, son una
herramienta muy útil para tener en un grado.  Han servido para
conocer un montón de gente con ganas de explorar y compartir las
matemáticas y la informática.  Y la comunidad motiva mucho; el doble
grado hubiera sido muy árido de otra forma.

No sé muy bien cómo hemos llegado a este equilibrio en el que el
comportamiento por defecto es compartir, pero creo que se ha arraigado
bien en el doble grado y merece mucho la pena cuidarlo.  Estaría muy
orgulloso de todo esto si colectivamente conseguimos mantenerlo en un
futuro.

** Org-drill and spaced repetition                                                           :post:
:PROPERTIES:
:TITLE: Org-drill and spaced repetition
:EXPORT_FILE_NAME: orgdrillspacedrepetition.html
:INDEX_DATE: <2018-09-03 Mon 21:53>
:END:

When it comes to [[https://www.gwern.net/Spaced-repetition][spaced]] [[https://codual.github.io/2016/07/07/repeticion-espaciada/][repetition]] software, [[https://ankiweb.net/about][Anki]] is probably the most
popular option. It is free software, provides syncronization with an
online server, has both desktop and Android applications, and it is
capable of rendering arbitrary Latex and multimedia. I would recommend
Anki to anyone starting with spaced repetition.

However, I do not myself use Anki; I have been using [[https://orgmode.org/worg/org-contrib/org-drill.pdf][org-drill]] for a
few months. The primary reason being Emacs. I really like having all
the cards in plain text and editing them from the text
editor. Org-mode has latex and multimedia support, and most of my math
notes are already there. Its big drawback is that it currently cannot
be used directly from the mobile phone ([[https://termux.com/][Termux]] is an option, but it
won't render Latex); a spaced repetition Android app supporting the
org-drill format would be great.

If you are not yet committed to Anki and you are already confortable
with Emacs, it could be a good idea to try both before settling on one.

** Uniqueness of identity proofs                                                             :post:
:PROPERTIES:
:TITLE: Uniqueness of identity proofs
:EXPORT_FILE_NAME: uniquenessofidentityproofs.pdf
:INDEX_DATE: <2018-08-25 Sat 21:57>
:END:

#+BEGIN_quote
/Attribution: this is only a summary, the original ideas exposed here
can be found on the reference articles./
#+END_quote

Equality in Martin-Löf type theory is a beautiful concept but it is
notoriously tricky to understand.  This is the second time I feel like
I get it; and it probably won't be the last one.  I have been reading
the groupoid interpretation article, and at least the first sections
are recommended lecture to anyone interested in the topic; it is
really well-written and does not require any previous
knowledge. cite:hofmann98

Let's talk about *Uniqueness of identity proofs* (UIP). This is the principle
that says that any two proofs of the same equality must be equal
themselves. That is, for any type $A$, the following type is inhabited

\[
\prod_{x,y : A} \prod_{p, q : x = y} p = q.
\]

Idris and Agda allow the user to prove this proposition in general via
pattern matching.

#+BEGIN_SRC haskell
-- In Agda.
uip : {A : Set} -> {x y : A} -> (p q : x ≡ y) -> p ≡ q
uip refl refl = refl
#+END_SRC

#+BEGIN_SRC haskell
-- In Idris
uip : (t : Type) 
    -> (x : t) -> (y : t) 
    -> (p : x = y) -> (q : x = y) 
    -> p = q
uip t x x Refl Refl = Refl
#+END_SRC

However, UIP is not valid in general in Martin-Löf type theory.
Hofmann and Streicher's groupoid interpretation provides a model where
the UIP fails. In particular, this proves that pattern matching, in full
generality, is not conservative over Martin-Löf type theory. cite:hofmann98
In Agda, we can disable this behaviour with the flag ~--without-K~, this
is necessary if we want to do Homotopy Type Theory, for example.

In general, the rule we /can/ use in Intensional Type Theory is the
J-eliminator. The usual properties of equality, like the Leibniz'
indiscernibility of identicals, are consequences of it. It is subtle
to notice how it works as it should while not implying UIP. For
any type $C$ depending two variables $x : A$ and $y : A$ we have the
following rule.

\begin{prooftree}
\AXC{$\Gamma \vdash a : A$}
\noLine
\UIC{$\Gamma, x : A \vdash c:C(x,x)$}
\AXC{$\Gamma \vdash b : A$}
\noLine
\UIC{$\Gamma \vdash p : a = b$}
\BIC{$\Gamma \vdash \mathsf{J}_C(c,p) : C(a,b)$}
\end{prooftree}

There is also a nice justification of the rule from category theory
and an adjoint characterization of equality due to Lawvere. More on
this can be read on the Michael's Shulman article on homotopy type
theory. cite:shulman17

*** references                                                                            :ignore:
bibliographystyle:alpha
bibliography:Math.bib

** Writing a bachelor's thesis in org-mode                                                   :post:
:PROPERTIES:
:TITLE: Writing a bachelor's thesis in org-mode
:EXPORT_FILE_NAME: bachelorsthesisinorgmode.html
:INDEX_DATE: <2018-08-15 Wed 23:37>
:END:

My [[https://github.com/mroman42/ctlc/][bachelor's thesis]] has been completely written in org-mode
format. At first, I supposed that org-mode would not be powerful
enough for a really long document with templates and lots of latex
customizations, but I stand corrected. You can insert arbitrary latex
code when needed and there is nothing preventing you to create a complex
header for your org-mode document.

After the experience, I would recommend using org-mode. You can manage
your tasks, your references and your text in a single file; and the
org-mode format is much more pleasant to read and write than the usual
tex format. The only problem I had was compilation: Emacs is really
slow and freezes while compiling. My solution was to use a second
Emacs instance which compiles on the background while I continue to
use the first one; the relevant line on the makefile looks as follows
(thanks to [[https://github.com/ncordon][@ncordon]] for the idea!).

#+BEGIN_SRC bash
emacs thesis.org --batch -u `id -un` \
--eval '(load user-init-file)' \
-f org-latex-export-to-pdf
#+END_SRC

** Blogging with a single org-file                                                           :post:
:PROPERTIES:
:TITLE: Blogging with a single org-file
:EXPORT_FILE_NAME: bloggingwithasingleorgfile.html
:INDEX_DATE: <2018-08-15 Wed 23:19>
:ID:       64a920ed-1914-4e64-997d-837f14815cdd
:END:

This blog is generated by a single org-file that can be found
[[https://github.com/mroman42/cosmoi/blob/master/cosmoi.org][here]]. The file contains some org-babel elisp blocks that export the
HTML files, create the index and populate the RSS feed. This is
possible using [[https://orgmode.org/manual/Tags.html#Tags][tags]] that signal whether any specific header is a post,
[[https://orgmode.org/manual/Property-syntax.html][properties]] that store the name and the html direction of the articles,
and the =org-map-entries= function, which maps a function over all
headers.

** Coinduction                                                                               :post:
:PROPERTIES:
:TITLE: Coinduction
:EXPORT_FILE_NAME: coinduction.pdf
:INDEX_DATE: <2018-08-15 Wed 23:08>
:ID:       174d185e-2269-40f2-935c-e8d45e08bfc8
:END:

The following article by Jacobs and Rutten is a really nice
introduction to the notion of coinduction.  It assumes almost no prior
knowledge of categories and details algebras, initiality, coalgebras,
finality, induction and bisimulation.

 * [[http://www.cs.ru.nl/~bart/PAPERS/JR.pdf][A tutorial on (Co)algebras and (Co)induction - Bart Jacobs, Jan Rutten]]

Conatural numbers can be implemented in Agda using [[https://agda.readthedocs.io/en/v2.5.4.1/language/coinduction.html#coinduction][coinductive records]]
as in the following example.  If you are interested in understanding
coinduction, it might be a good idea to experiment in Agda; I learnt a
lot writing basic coinductive definitions.

#+BEGIN_SRC haskell
data Maybe (A : Set) : Set where
  Nothing : Maybe A
  Just : A -> Maybe A

record coNat : Set where
  coinductive
  field
    pred : Maybe coNat
open coNat public    

coZero : coNat
pred coZero = Nothing

coInf : coNat
pred coInf = Just coInf

succ : coNat -> coNat
pred (succ n) = Just n

infixl 20 _+_
_+_ : coNat -> coNat -> coNat
pred (a + b) with pred a
pred (a + b) | Nothing = pred b
pred (a + b) | Just a' = Just (a' + b)
#+END_SRC

** Cartesian closed categories                                                               :post:
:PROPERTIES:
:TITLE: Cartesian closed categories
:EXPORT_FILE_NAME: cartesianclosedcategories.pdf
:INDEX_DATE: <2018-07-01 Sun 11:30>
:ID:       3d52d110-822a-4f85-a1c4-57d868b527d5
:END:

A *cartesian closed category* $\mathbb{C}$ can be defined as a category having a right adjoint
of the unique functor to the terminal category $\ast \colon \mathbb{C} \to 1$, a right adjoint of the
diagonal functor $\Delta \colon \mathbb{C} \to \mathbb{C} \times \mathbb{C}$, and a right adjoint of $- \times A \colon \mathbb{C} \to \mathbb{C}$ for
each $A \in \mathbb{C}$. These three adjoints correspond to the existence of a /terminal/ object,
binary /products/ and /exponentials/.

\begin{prooftree}
\AXC{\begin{tikzcd}[fragile,ampersand replacement=\&] \ast \rar{}\& \ast \end{tikzcd}}
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&] C \rar{!}\& 1 \end{tikzcd}}
\AXC{\begin{tikzcd}[fragile,ampersand replacement=\&] C,C \rar{f,g}\& A,B \end{tikzcd}}
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&] C \rar{\langle f,g \rangle}\& A \times B \end{tikzcd}}
\AXC{\begin{tikzcd}[fragile,ampersand replacement=\&] C \times A \rar{f}\& B \end{tikzcd}}
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&] C \rar{\widetilde{f}}\& B^A \end{tikzcd}}
\noLine
\TIC{}
\end{prooftree}

These three rules match the three introduction rules for the simply
typed lambda calculus. We interpret $C$ as a context $\Gamma$ and each morphism
$a \colon C \to A$ as a term $\Gamma \vdash a : A$.

\begin{prooftree}
\AXC{}
\UIC{$\Gamma \vdash \ast : 1$}
\AXC{$\Gamma \vdash a : A$}
\AXC{$\Gamma \vdash b : B$}
\BIC{$\Gamma \vdash \pair{a,b} : A \times B$}
\AXC{$\Gamma, a : A \vdash b : B$}
\UIC{$\Gamma \vdash (\lambda a.b) : A \to B$}
\noLine
\TIC{}
\end{prooftree}

Now, we should discuss if \beta-equivalence corresponds to the equality between morphisms.

** Category theory and lambda calculus                                                       :post:
:PROPERTIES:
:TITLE: Category theory and lambda calculus
:EXPORT_FILE_NAME: categorytheoryandlambdacalculus.html
:INDEX_DATE: <2018-07-01 Sun 11:00>
:END:

*Category theory and lambda calculus* is the title of my bachelor's
thesis.  It discusses the implementation of [[./mikrokosmos.html][Mikrokosmos]] and
categorical semantics for the simply typed lambda calculus in its
first half. It later extends these notions to dependently typed
programming languages (Agda is used as an example) and locally closed
cartesian categories.  It must be seen as a summary of my study during
these months and as a literature review: there is no claim of
originality more than the way the ideas are presented.

The complete thesis was written with Emacs in [[https://orgmode.org/][org-mode format]] (highly
recommended) and the source code is publicly available [[https://github.com/mroman42/ctlc][at GitHub]]. The
final [[https://mroman42.github.io/ctlc/ctlc.pdf][PDF]] is also available, but if you are not that interested on the
details, you may prefer to simply read the [[https://mroman42.github.io/ctlc-slides/slides.pdf][commented slides]] (in
Spanish), which are a reasonable summary of the ideas presented there.

** Evaluación en cálculo lambda                                                              :post:
:PROPERTIES:
:TITLE: Evaluación en cálculo lambda
:EXPORT_FILE_NAME: evaluacionlambda.html
:INDEX_DATE: <2018-05-25 Fri 18:02>
:END:
Esta es una recopilación de los enunciados que nos llevan a usar la
evaluación mediante \beta-reducciones del cálculo lambda como un
lenguaje de programación.  Los obtuve principalmente del libro de
Barendregt y de las notas de Peter Selinger cuando buscaba la base
teórica para implementar [[file:mikrokosmos.html][Mikrokosmos]] Detallo estos mismos
enunciados recopilando sus demostraciones en [[https://github.com/M42/lambda.notes][M42/lambda.notes]].

*** Forma normal
Una expresión está en /forma normal/ si no se le pueden aplicar más
\beta-reducciones. La forma normal es /única/ como consecuencia del
teorema de Church-Rosser.

*Teorema de Chuch-Rosser.* Si a un mismo término se le aplican dos
cadenas de reducciones distintas, los términos que se obtienen pueden
a su vez reducirse a un término común. Es decir,

 * si $A$ puede reducirse mediante \beta-reducciones a otro término
   $B$, lo que se nota por $A \twoheadrightarrow_{\beta} B$,
 * y $A$ puede reducirse también mediante otras \beta-reducciones,
   posiblemente distintas o en distinto orden, a $C$, $A \twoheadrightarrow_{\beta} C$,
 * entonces existe un término $D$ tal que ambos se pueden reducir
   mediante \beta-reducciones a él; es decir, tal que $B \twoheadrightarrow_{\beta} D$
   y $C \twoheadrightarrow_{\beta} D$.

En particular, esto implica que si un término tuviera dos formas
normales, debería existir otro término al cual se pudieran reducir
ambas; como son formas normales y no pueden reducirse, esto debe
implicar que son iguales.

*** Divergencia
Hemos visto que la forma normal es única, pero no que exista o que
sepamos encontrarla de alguna forma. Puede ocurrir que un término no
esté en forma normal y sin embargo las reducciones no lo lleven a
ella. Por ejemplo, el término $\Omega = (\lambda x.x\ x)(\lambda x.x\ x)$
es invariante a \beta-reducciones y *no llega a forma normal*. O por 
ejemplo, el término $(\lambda x.x\ x\ x)(\lambda x.x\ x\ x)$ se hace cada vez más grande
al aplicarle reducciones, decimos que /diverge/.

*** Evaluación a izquierda
Hay expresiones que llegarán a una forma normal o no dependiendo de
cómo los evaluemos. Por ejemplo, el término $(\mathtt{const}\ \mathtt{id}\ \Omega)$ llega a
la forma normal $\mathtt{id}$ si evaluamos primero la aplicación de $\mathtt{const}$,
pero diverge si empezamos intentando evaluar $\Omega$. 
Sin embargo, existe una estrategia de reducción que siempre encuentra
una forma normal si esta existe. Tenemos el siguiente teorema.

 * Si existe una forma normal, la estrategia que reduce a cada paso
   la aplicación más a la izquierda posible la encuentra.

Y quizá sorprendentemente, existe otra estrategia de reducción que siempre
encuentra la forma de *no* llegar a la forma normal si esta existiera.

 * Si existe alguna sucesión que no llega a forma normal, la
   estrategia que reduce a cada paso la aplicación más a la derecha
   posible la encuentra.

Estas dos formas de evaluación se suelen llamar /call-by-value/ y
/call-by-name/.
** Mikrokosmos                                                                               :post:
:PROPERTIES:
:TITLE: Mikrokosmos
:EXPORT_FILE_NAME: mikrokosmos.html
:INDEX_DATE: <2018-05-25 Fri 18:01>
:ID:       5e645152-8b35-4236-bf9a-95b0d3bcb85d
:END:

*Mikrokosmos* is an untyped and simply typed λ-calculus interpreter,
borrowing its name from the series of progressive piano études
Mikrokosmos written by Bela Bartok. It aims to provide students with a
tool to learn and understand the λ-calculus.

 * [[https://github.com/mroman42/mikrokosmos][GitHub repository]].
 * [[https://mroman42.github.io/mikrokosmos/][User's guide]].
 * [[https://github.com/mroman42/jupyter-mikrokosmos][Jupyter kernel]].

Since version 0.3.0, it comes bundled with a Jupyter Notebook kernel,
a tutorial on lambda calculus and specific modes for SKI combinators.
Thanks to [[https://github.com/ghcjs/ghcjs][GHCJS]] and [[http://codemirror.net/][Codemirror]], you can also try the [[https://github.com/mroman42/mikrokosmos][Mikrokosmos]]
lambda interpreter in your browser. Press the *evaluate* button there
and play with the code!

** Aprendiendo Emacs                                                                         :post:
:PROPERTIES:
:TITLE:    Aprendiendo Emacs
:EXPORT_FILE_NAME: aprendiendoemacs.html
:INDEX_DATE: <2018-05-25 Fri 18:34>
:END:

*** Emacs

*[[https://www.gnu.org/software/emacs/][Emacs]]* es un editor de texto construido sobre un intérprete del lenguaje
*[[https://es.wikipedia.org/wiki/Emacs_Lisp][Elisp]]* para hacerlo
extensible. Cada acción del editor constituye un comando sobre el
intérprete, por lo que podemos reescribir sus comandos o crear nuevos
comandos simplemente programando sobre el intérprete.

[[https://github.com/libreim/blog/raw/post-emacs/images/emacs.png]]
/Emacs editando este mismo artículo en Markdown/

Emacs sirve como IDE para la mayoría de lenguajes de programación y como
editor para programación literaria y ciencia reproducible; se integra
con git y con el sistema de archivos y tiene extensiones disponibles
para usarse como aplicación para organizar listas de tareas, leer el
correo o servir como hoja de cálculo.

#+BEGIN_QUOTE
  I use Emacs, which might be thought of as a thermonuclear word
  processor.

  -- *Neal Stephenson*, /In the Beginning... was the command line./
#+END_QUOTE

En este artículo haré una referencia breve a todo lo que me ha ido
sirviendo para aprender Emacs mientras enlazo a fuentes que tratan cada
uno de los temas más extensamente. Como recursos generales para aprender
Emacs, puedo recomendar:

-  [[https://www.youtube.com/playlist?list=PLxj9UAX4Em-IiOfvF2Qs742LxEK4owSkr][*.Emacs Tutorials*]] de /jekor/, explican todo lo necesario para aprender
   Emacs en 10 videotutoriales que pueden seguirse progresivamente.
-  [[https://www.youtube.com/playlist?list=PL8tzorAO7s0he-pp7Y_JDl7-Kz2Qlr_Pj][*Emacs Meetups*]] de Thoughtbot, que profundizan sobre temas concretos de
   uso de Emacs.
-  [[http://emacsrocks.com/][*Emacs Rocks*]], vídeos breves sobre casos
   concretos de uso de Emacs.
-  [[https://www.emacswiki.org/emacs/SiteMap][*Emacs wiki*]], una wiki
   que documenta todo lo relacionado con Emacs.
-  [[http://sachachua.com/blog/category/geek/emacs/][*sachachua.com*]],
   donde se hace referencia periódicamente a noticias de Emacs, y tiene
   escritas hojas de referencia de atajos de teclado de Emacs.
-  [[http://cestlaz.github.io/stories/emacs/][*C'est la z*]], otro blog
   en el que se tratan temas relacionados con Emacs.
-  [[https://www.gnu.org/software/emacs/manual/][*GNU Emacs*]], la
   documentación oficial de Emacs.
-  [[https://elbauldelprogramador.com/chuleta-atajos-teclado-emacs/][*El baúl del programador*]], que ha empeazado una recopilación colaborativa de
   los comandos y paquetes más útiles para Emacs.

**** Instalación

Emacs puede encontrarse en la mayoría de gestores de paquetes, pero
puede no estar en su versión más actualizada.

#+BEGIN_EXAMPLE
    sudo apt install emacs
#+END_EXAMPLE

Para escribir este artículo estoy usando =GNU Emacs 25.1=, pero la
última versión estable es la *24.5*. La versión estable actual puede
descargarse desde [[https://www.gnu.org/software/emacs/][GNU]].

*** Atajos de teclado
En Emacs se usa una [[https://www.emacswiki.org/emacs/EmacsKeyNotation][notación específica]] para escribir un atajos de teclado. 
La mayoría de
documentación que consultes usará =C-x= en lugar de =Control+x=; usará
=C-x C-s= para indicar que debes dejar pulsado =Control= mientras pulsas
=x= y =s=; y por último, usará =M-x=, donde la =M= se referirá a la
tecla =Meta=. La tecla =Meta= en Emacs se refiere normalmente a dos
opciones equivalentes, o bien pulsar =alt izq.= mientras se pulsa =x=, o
pulsar =Esc= y luego pulsar =x=. En resumen:

|---------+-----------------------------------------------+-----------------|
| Atajo   | Descripción                                   | Comando         |
|---------+-----------------------------------------------+-----------------|
| C-n     | Mantener control pulsado mientras se pulsa n  | Next line       |
| C-x C-s | Mantener control pulsado pulsando x y luego s | Save file       |
| M-x     | Mantener alt o pulsar esc para luego pulsar x | Execute Command |
| RET     | Salto de línea, pulsar enter antes de seguir  |                 |
|---------+-----------------------------------------------+-----------------|

Usar atajos de teclado facilita mucho usar Emacs rápidamente después del
tiempo de aprendizaje.  [1]

Cuando abras el programa por primera vez, te ofrecerá seguir un tutorial
de Emacs escrito en Emacs. El tutorial es muy útil para aprender a
moverse dentro de Emacs, pero la mayoría de lo que cuenta no es
especialmente fácil de aprender de una sola vez. Lo más chocante para un
usuario nuevo puede ser el sistema de copiar-pegar; que de forma muy
simplificada se resume en:  [2]

-  =M-w= copia.
-  =C-w= corta.
-  =C-y= pega.

Pero si no te convence, puedes usar [[https://www.emacswiki.org/emacs/CuaMode][CUA Mode]], que te permite
volver a usar =C-c= y =C-v= para copiar y pegar. Otros comandos útiles
de aprender antes de empezar con nada más son =C-x C-s= para guardar y
=C-x C-f= para abrir un archivo.

**** Documentación

Emacs es un editor autodocumentado, es decir, la documentación del
editor puede consultarse dentro del propio programa. Para llamar a la
ayuda se puede pulsar =C-h ?=, que nos dejará elegir si necesitamos
ayuda sobre comandos, atajos de teclados, variables, licencias, etc.
Especialmente útiles son:

-  =C-h c <atajo de teclado>= nos da el nombre de la función que se
   ejecuta al pulsar esas teclas.
-  =C-h f <nombre de función>= documenta la función.

**** Buffers y ventanas

Cada vez que abrimos un archivo, o pedimos un apartado de documentación,
o abrimos la configuración, se abre un nuevo buffer. Un
[[https://www.emacswiki.org/emacs/Buffer][buffer]] es el equivalente a un documento o un espacio de trabajo en otros 
editores. Podemos movernos
entre los buffers actualmente abiertos pulsando =C-x <left>= o
=C-x <right>=; y podemos mostrar la lista de buffers actualmente
abiertos con =C-x C-b= (¡en un nuevo buffer!).

Además de los buffers que tengamos actualmente abiertos, tenemos
ventanas que los muestran. Podemos partir la pantalla de Emacs en varias
ventanas con =C-x 2= y =C-x 3=, que la parten horizontal y verticalmente
respectivamente. Para volver a quedarnos sólo con la ventana en la que
está el cursor, podemos pulsar =C-x 1=; y para cambiar de ventana sobre
la que actúa el cursor podemos usar =C-x o=.

**** Modos de Emacs

El comportamiento de Emacs sobre cada buffer que abra será distinto
dependiendo normalmente de la extensión del archivo. Esto le permite
colorear de manera distinta distintas sintaxis, o tener comportamientos
específicos (indentación, atajos de teclado, formateo) cuando está
editando cada lenguaje.

Cada una de estas formas de edición se llama [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Major-Modes.html][*modo*]],
y el *modo* actual aparece resaltado entre paréntesis en la barra
inferior de Emacs. El modo básico es =Fundamental=, pero para cada
propósito existen modos específicos. Para casi todos los lenguajes de
programación tendremos un modo. Existen, por ejemplo,
[[https://www.emacswiki.org/emacs/RubyMode][=Ruby-mode=]], [[https://www.emacswiki.org/emacs?action=browse;oldid=PythonMode;id=PythonProgrammingInEmacs#toc2][=Python-mode=]] o [[https://www.emacswiki.org/emacs/CcMode][=CC-mode=]].

Además de los /modos mayores/ de los que hemos hablado hasta ahora,
existen /modos menores/ que son opcionales y complementan a los modos
mayores. Por ejemplo, mientras escribo este artículo estoy usando
[[https://www.emacswiki.org/emacs/MarkdownMode][=Markdown=]] como modo mayor y =ARev= ([[https://www.gnu.org/software/emacs/manual/html_node/emacs/Reverting.html][Auto-revert mode]]) como modo menor.

*** Personalización

Prácticamente todos los parámetros que uses en Emacs pueden ser
ajustados a tu necesidad. Desde los atajos de teclado hasta el tema de
color y fuentes que usa el editor.

La forma más básica de editar todas estas configuraciones es
=M-x customize group=, que accede a un menú en el que se pueden
modificar todas ellas. Todos los cambios que aquí se hagan se guardarán
en un archivo =.emacs= (o =init.el=, en las versiones nuevas de Emacs).
Este archivo es la otra forma de configurar Emacs; el archivo de inicio
=.emacs= contiene código en Elisp que se ejecutará al iniciar el editor
y podemos incluir allí todo lo que queramos configurar. Algunos
paquetes, por ejemplo, necesitarán configuración adicional que habrá que
incluir en este archivo.

[[https://youtu.be/mMcc0IF1hV0][*.Emacs #2 - Customizations and themes* - /jekor/]]

*** Sistemas de paquetes
   :PROPERTIES:
   :CUSTOM_ID: sistemas-de-paquetes
   :END:

**** Melpa
    :PROPERTIES:
    :CUSTOM_ID: melpa
    :END:

Es conveniente añadir un repositorio más grande que el que trae GNU por
defecto, y [[https://melpa.org/#/][MELPA]] es uno de los repositorios de
paquetes de Emacs más grandes y actualizados. El repositorio de MELPA se
añade desde =M-x customize-group RET package=. Dentro de la pestaña de
repositorios puede insertarse la dirección de MELPA:

#+BEGIN_EXAMPLE
     Archive name: melpa-stable
     URL or directory name: https://stable.melpa.org/packages/
#+END_EXAMPLE

Para salir de cualquiera de las pantallas de personalización se usa =q=.

Otra forma de conseguir este mismo efecto es añadirlo directamente a
nuestro archivo de configuración (=.emacs=/=init.el=), como se indica en
las [[https://melpa.org/packages/][instrucciones de instalación]] del
repositorio.

**** Paquetes
    :PROPERTIES:
    :CUSTOM_ID: paquetes
    :END:

Podemos listar los paquetes que podemos instalar usado
=M-x list-packages= y podemos buscar entre los paquetes pulsando varias
veces el comando =C-s=. Si pulsamos =i= al lado de uno de ellos se
marcará para instalar y al pulsar =x= se ejecutará la instalación de
todos los paquetes marcados.

[[https://youtu.be/Cf6tRBPbWKs][*.Emacs #3 - Installing packages and
extensions* - /jekor/]]

*** Paquetes útiles
   :PROPERTIES:
   :CUSTOM_ID: paquetes-útiles
   :END:

**** Dired
    :PROPERTIES:
    :CUSTOM_ID: dired
    :END:

Dired viene instalado por defecto con Emacs y permite navegar la
estructura de directorios del sistema operativo. Podemos empezar a
navegarla usando =M-x dired= y pulsando =RET= cada vez que queramos
abrir un archivo o una carpeta.

Podemos además afectar a los archivos. Por ejemplo, si queremos eliminar
algunos archivos, podemos marcarlos con =d= y eliminarlos
definitivamente con =x=.

[[https://youtu.be/7jZdul2fC94][*.Emacs #4 - Exploring the filesystem* -
/jekor/]]

**** org-mode
:PROPERTIES:
:CUSTOM_ID: org-mode
:END:

*org-mode* es un modo de Emacs que se creó originalmente para gestionar
listas de tareas, agendas y calendarios; pero además, contiene en su
interior un completo lenguaje de marcado. Permite exportar documentos a
una gran variedad de formatos (pdf, html, latex o markdown) e incluir
internamente trozos de código y ejecutarlos. Además, tiene un sistema de
tablas en texto plano capaz de sustituir la hoja de cálculo para tareas
sencillas. Por todo esto, puede ser usado en tareas como la ciencia
reproducible o la programación literaria cuando Latex es demasiado
complejo, ayudando además a manejar la bibliografía y los enlaces tanto
externos como entre archivos.

[[https://youtu.be/SzA2YODtgK4][*Getting started with org-mode* - /Harry Schwartz/]]

Especialmente útil para matemáticas es la
[[http://orgmode.org/worg/org-tutorials/org-latex-preview.html][previsualización de Latex]] y el poder incluir los paquetes de la
[[ftp://ftp.ams.org/pub/tex/doc/amsmath/amsldoc.pdf][AMS]] para marcar teoremas o definiciones.

[[https://github.com/libreim/blog/raw/post-emacs/images/org-math.png]]
/Apuntes de matemáticas en org-mode/

**** magit
    :PROPERTIES:
    :CUSTOM_ID: magit
    :END:

*magit* permite integrar Emacs con *git* fácilmente para incluir los
commits desde dentro del mismo editor. Usando =magit-status= llegamos a
una pantalla en la que podemos elegir qué ficheros añadir al commit con
=s=  [3] y visualizar las diferencias con el commit anterior usando
=tab=; ejecutar el commit con =c c=, que nos mostrará el buffer con el
mensaje de commit y por último usar =C-c C-c= para enviarlo. El push y
pull los haremos desde =magit-status= con =P u= y =F u=,
respectivamente.

Es útil asignar un atajo de teclado al comando =magit-status=, que es el
que muestra la ventana desde la que controlamos el añadir y hacer commit
de ficheros. Por ejemplo, podemos fijarlo en =f5= añadiendo a nuestro
archivo de configuración:

#+BEGIN_SRC lisp
    (global-set-key (kbd "<f5>") 'magit-status)
#+END_SRC

*** Macros de teclado
   :PROPERTIES:
   :CUSTOM_ID: macros-de-teclado
   :END:

Las macros de teclado nos dejan grabar una secuencia de acciones y
volver a repetirla tantas veces como sea necesaria. Se puede empezar a
grabar con =f3= y terminar la grabación y repetirla tantas veces como
sea necesario con =f4=.

[[https://youtu.be/JfZ9fCHzkJw][*.Emacs #9 - Keyboard macros* -
/jekor/]]

*** Elisp
   :PROPERTIES:
   :CUSTOM_ID: elisp
   :END:

[[https://www.gnu.org/software/emacs/manual/html_node/elisp/][Emacs Lisp]], o Elisp, es un lenguaje de programación diseñado específicamente
para escribir un editor de texto. Facilita el tratamiento de texto y el
manejo de archivos y buffers.

Podemos escribir scripts en Elisp que se encarguen de tareas repetitivas
en nuestro editor de texto y asignarlas a atajos de teclado o ampliarlo
con más funcionalidad. Un tutorial básico sobre Elisp es
[[http://emacs-doctor.com/learn-emacs-lisp-in-15-minutes.html][Learn Emacs Lisp in 15 minutes]].

*** Notas
[1] Realmente solo puedo decir que a mí me funciona y que en general los
    atajos de teclado parecen ser [[http://ux.stackexchange.com/a/30749][mejores que usar el ratón]].

[2] El [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Killing.html#Killing][sistema]] que Emacs usa para esto es bastante más sofisticado.

[3] De hecho, podemos seleccionar qué párrafos dentro de un fichero
    queremos añadir al commit.
** Capturando links en org-mode                                                              :post:
:PROPERTIES:
:TITLE:    Capturando links en org-mode
:EXPORT_FILE_NAME: capturandolinksenorgmode.html
:INDEX_DATE: <2017-03-23 Thu 14:54>
:END:

*** Capturando links
El objetivo de este post es describir el proceso que uso para capturar links
desde Firefox y almacenarlos en un archivo de org-mode, que puede leerse luego
desde el propio navegador.

*** Org-capture
La primera parte será activar =org-capture= y =org-protocol= en Emacs. [[https://www.gnu.org/software/emacs/manual/html_node/org/Capture.html#Capture][org-capture]]
puede ser usado también para escribir pequeñas ideas y almacenarlas en ficheros org
rápidamente; pero, en este caso, lo usaremos sólo para recibir el link desde Firefox.

#+BEGIN_SRC emacs-lisp
  (require 'org-protocol)
#+END_SRC

Lo primero que debemos hacer es definir la plantilla que queremos usar para capturar
los links. La sintaxis usada se explica en la [[https://www.gnu.org/software/emacs/manual/html_node/org/Template-expansion.html#Template-expansion][documentación]] de org-mode, así como
las opciones que usa después:

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
	(quote (
		("x" "org-protocol" entry (file "~/links.org")
		 "** %c %?" :kill-buffer t :prepend t))))
#+END_SRC

En este caso, guardará los links en un archivo llamado =links.org= en el directorio
=home=. Pueden añadirse [[https://www.gnu.org/software/emacs/manual/html_node/org/Template-elements.html#Template-elements][opciones]] para explicitar en qué punto exacto del archivo
queremos insertar el link una vez lo capturemos.

*** Extensión de firefox
El uso de =org-protocol= desde Firefox puede gestionarse más detalladamente usando
[[http://orgmode.org/worg/org-contrib/org-protocol.html#sec-4][marcadores]] que activen la captura. En nuestro caso, como sólo necesitamos la configuración
básica, podemos ahorrarnos este trabajo y dejárselo a la extensión [[http://chadok.info/firefox-org-capture/][org-capture for Firefox]].

La extensión nos deja elegir en sus opciones si queremos que use una nueva ventana (me
parece lo más conveniente y además veremos cómo controlarla luego con i3); la letra
asignada a la plantilla (en nuestro caso hemos usado la =x= en la configuración
anterior); y el atajo de teclado para activarla, que por defecto es =Ctrl-Alt-r=.

Una vez activemos la extensión, podremos capturar enlaces pulsando el atajo.

*** Cerrando ventanas
Un problema menor al usar esta extensión es que crea ventanas de Emacs que no cierra
al terminar. Otro problema es que suele crear también un buffer inicial al lado de nuestro
buffer de captura. Podemos usar *hooks* para forzarlo a corregir ese comportamiento:

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-capture-mode-hook 'delete-other-windows)
  (add-hook 'org-capture-after-finalize-hook 'delete-frame)
#+END_SRC

*** Integrándolo en i3
Para los usuarios de i3, puede ser útil poder controlar dónde y cómo se crea la ventana
de captura de Emacs. Un ejemplo de configuración es la siguiente, que coloca la ventana
como flotante y en el centro de la pantalla; como si fuera un popup:

#+BEGIN_SRC bash
for_window [class="Emacs" title="CAPTURE"] floating enable
for_window [class="Emacs" title="CAPTURE"] resize set 1880 480
for_window [class="Emacs" title="CAPTURE"] move position center
#+END_SRC

*** Mostrando los links en el navegador
Para que además los links se muestren en el navegador, pueden usarse también *hooks* que
se activen al guardado para exportar a HTML. En este post de [[https://rafaelleru.github.io/2017/01/22/to_read_list_emacs/][@rafaelleru]] se explica el
proceso en detalle.

*** Un detalle sin solucionar
En la plantilla de captura, me gustaría poder usar además =%^g=, que crea un pequeño
diálogo donde insertar tags al link que se está guardando. El problema con esto es que,
hasta que ese diálogo no ha terminado, no se ejecutan los hooks y el frame no se hace
único (ni se reposiciona en i3).
** Distribuciones discretas con mónadas                                                      :post:
:PROPERTIES:
:TITLE: Distribuciones discretas con mónadas
:EXPORT_FILE_NAME: distribucionesmonadas.html
:INDEX_DATE: <2018-05-25 Fri 18:34>
:END:

*** El modelo
Como parte de una serie de ejemplos sobre uso de mónadas, he escrito
un poco de código para modelar distribuciones discretas usando
mónadas.  Por un lado, usa un [[https://math.dartmouth.edu/archive/m20f11/public_html/RANDOMNESS_LCG.pdf][generador congruencial lineal]] para
generar números aleatorios; y por otro, usa la mónada [[https://wiki.haskell.org/State_Monad][State]] para pasar
una semilla aleatoria de una función a otra que me permita seguir
generado números aleatorios.  Por último, aporta un método que deriva
[[http://www.zvon.org/other/haskell/Outputprelude/Show_c.html][Show]] para probar las distribuciones y dibujar un histograma de
cualquiera de ella.

*** Componiendo distribuciones
Lo más útil de esta idea es el poder generar unas distribuciones a
partir de otras. La primera que intentamos es una uniforme discreta
(un dado de =n= caras) usando una semilla inicial. En el siguiente
código se implementa el generador congruencial.

#+BEGIN_SRC haskell
  dice :: Int -> Distribution Int
  dice n = state (\s -> (s `mod` n + 1, 16807*s `mod` 2147483647))
#+END_SRC

Vemos que funciona como una distribución uniforme.

#+BEGIN_SRC bash
>>> dice 6

1:	 ################
2:	 ################
3:	 ################
4:	 ################
5:	 ################
6:	 ################
#+END_SRC

Y desde ella generar fácilmente otras usando funciones que
compongan distribuciones. Un ejemplo es usar =(⊕) = liftM2 (+)= para
sumar dados.

#+BEGIN_SRC bash
>>> dice 6 ⊕ dice 6

2:	 #####
3:	 ##########
4:	 ###############
5:	 ####################
6:	 ##########################
7:	 ##############################
8:	 #########################
9:	 ####################
10:	 ###############
11:	 ##########
12:	 #####
#+END_SRC

*** Otras distribuciones
Si seguimos componiendo usando la estructura de mónada, podemos crear
otras distribuciones simples como la distribución de *Bernoulli* y la
distribución *binomial*.

#+BEGIN_SRC haskell
  bernoulli :: Double -> Distribution Int
  bernoulli p = do
    sample <- dice 1000000
    if (fromIntegral sample / 1000000.0 < p)
      then return 1
      else return 0

  binomial :: Int -> Double -> Distribution Int
  binomial k p = sum <$> replicateM k (bernoulli p)
#+END_SRC

Lo interesante de este código es que dejamos a la estructura de
mónada encargarse internamente de el paso de la semilla de
aleatoriedad y la construcción de distribuciones complejas
puede hacerse composicionalmente.

*** El código
El siguiente código es una primera implementación de este post en
Haskell.

#+BEGIN_SRC haskell
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-
En este archivo vamos a usar mónadas para definir distribuciones
discretas de probabilidad y aplicar operaciones algebraicas sobre ellas.
-}
import Control.Monad.State

-- Generación aleatoria
-- Para generar números pseudoaleatorios usaremos LCGs. La idea es tener
-- un dado que nos dé una distribución de probabilidad uniforme dada una
-- semilla y nos devuelva el resultado de la tirada y una nueva semilla
-- aleatoria. Buscamos que un dado de seis caras sea, por ejemplo:
--
--   dice 6 :: Seed -> (Int, Seed)
--
-- Si quisiéramos tirar dos dados, tendríamos que tomar la semilla resultante
-- del primer lanzamiento y pasarla al segundo; algo así:
--
--   let (a,newseed) = dice 6 seed
--   let (b,_)       = dice 6 newseed
--   print [a,b]
--
-- Pero esto se hace demasiado complejo. La semilla, en el fondo, es un
-- estado, así que podemos modelarla con la mónada State. Cada lanzamiento
-- será de la forma:
--
--   State Seed a   ===   Seed -> (a, Seed)
--
-- Luego podemos llamar a la distribución: Distribution a = State Seed a, y
-- trabajar con ella usando las funciones normales de mónadas.
type Seed = Int
type Distribution = State Seed



-- Nuestra primera distribución es un dado de "n" lados que usa internamente un
-- generador de números aleatorios.
dice :: Int -> Distribution Int
dice n = state (\s -> (s `mod` n + 1, 16807*s `mod` 2147483647))

-- Una moneda es un dado de dos caras
coin :: Distribution Int
coin = dice 2

-- Estas funciones pueden ser llamadas con la mónada estado, dada una
-- semilla inicial, devuelven el resultado y la nueva semilla:
--
-- λ> runState (dice 6) 1
-- (2,16807)
-- λ> runState (dice 6) 16807
-- (2,282475249)
--
-- El usar composición con mónadas nos ahorraba controlar los errores
-- en el primer caso, aquí nos ahorra controlar el cambio de semilla,
-- por ejemplo: para lanzar dos dados y hacer que la semilla se pase
-- internamente.
twodices' :: Distribution Int
twodices' = do
  a <- dice 6
  b <- dice 6
  return (a+b)

(⊕) :: Distribution Int -> Distribution Int -> Distribution Int
(⊕) = liftM2 (+)
(⊗) :: Distribution Int -> Distribution Int -> Distribution Int
(⊗) = liftM2 (*)

twodices :: Distribution Int
twodices = dice 6 ⊕ dice 6

-- Igual que hago esto, podría hacer:
--
--   foldr (⊕) (return 0) [dice 6,dice 6,dice 6]
--   foldr (⊕) (return 0) (replicate 10 (dice 6))
--
-- Que da un resultado que se aproxima a una distribución normal.

-- Ahora, desde ella, podemos crear otras distribuciones. La distribución de
-- bernoulli sería la de una moneda trucada donde una cara tiene probabilidad
-- p y la otra tiene probabilidad (1-p).
bernoulli :: Double -> Distribution Int
bernoulli p = do
  sample <- dice 1000000
  if (fromIntegral sample / 1000000.0 < p)
    then return 1
    else return 0

-- La distribución binomial es la suma de k distribuciones de Bernoulli
binomial :: Int -> Double -> Distribution Int
binomial k p = sum <$> replicateM k (bernoulli p)

-- La distribución constante y otra forma de escribir la distribución
-- binomial, de manera algebraica.
constant :: Int -> Distribution Int
constant n = return n

binomial' :: Int -> Double -> Distribution Int
binomial' k p = foldr (⊕) (constant 0) (replicate k (bernoulli p))



-- Muestra la distribución. Los detalles de implementación no son interesantes.
-- Hemos usado  TypeSynonymInstances para simplificar el proceso de sobrecargar
-- la instancia de Show y poder dibujar directamente por la pantalla las
-- demostraciones.
instance Show (State Seed Int) where
  show = showdist

showdist :: Distribution Int -> String
showdist dist = unlines $ map counter [minimum samples..maximum samples]
  where samples = fst $ runState (replicateM 50000 dist) 1
        counter n = show n ++ ":\t " ++ replicate ((count n samples) `div` (3000 `div` range)) '#'
        range = maximum samples - minimum samples + 1

count :: Eq a => a -> [a] -> Int
count x = length . filter (x==)


main :: IO ()
main = return ()
#+END_SRC
** Inducción estructural                                                                     :post:
:PROPERTIES:
:TITLE:    Inducción estructural
:EXPORT_FILE_NAME: induccionestructural.html
:INDEX_DATE: <2015-03-14 Sat 15:02>
:END:

Normalmente aplicamos inducción sobre los números naturales, y cuando
necesitamos aplicar inducción en otro contexto lo hacemos corresponder con los 
números naturales. Por ejemplo, si queremos demostrar una propiedad sobre los
árboles binarios, la demostraríamos por inducción sobre la altura del
árbol. Pero el proceso de llevar todo a los naturales puede ser
incómodo, tedioso y puede complicar la demostración innecesariamente. En
este post vamos a desarrollar una forma de ampliar la inducción a la
estructura de los tipos de datos para simplificar todas esas
demostraciones.

*** Conjuntos bien fundados

Vamos a definir las relaciones bien fundadas, que nos permitirán definir
una inducción generalizada. [1]

-  *Relación bien fundada:* una relación en un conjunto de elementos
   es bien fundada si todo subconjunto no vacío tiene un elemento
   minimal. Dado un orden parcial, es bien fundado si todo subconjunto
   no vacío tiene un elemento tal que ninguno es menor que él.

Y podemos realizar inducción sobre cualquier conjunto con una relación
bien fundada.

-  *Inducción noetheriana:* sea $X$ un conjunto bien fundado con
   $A \subset X$. Si se cumple:

   \[ (y < x \Rightarrow y \in A) \Rightarrow x \in A \]

   Entonces $A = X$.

*** Inducción sobre tipos
Ahora vamos a aplicar esto a teoría de tipos. Sea un tipo con sus
constructores. Para todas las instancias constructibles del tipo (es decir,
aquellas que pueden
generarse en un número finito de pasos desde sus constructores),
definimos un orden parcial:

-  *Orden constructivo:* para dos instancias del tipo: $a,b::A$,
   $b$ se construye con $a$ si el constructor de $b$ toma a $a$
   como argumento. La clausura transitiva de esta relación forma un
   orden parcial:

   \[ a \leq b \Rightarrow a \mbox{ se usa en la construcción de } b \]

Y ahora tenemos una inducción sobre los constructores de los tipos, que
describimos ahora.

-  *Inducción sobre tipos*: sea un tipo $A$ con constructores y sea
   $P :: A \rightarrow Bool$ una propiedad. Siendo
   $a_1, a_2 \dots a_i :: A$ argumentos del constructor, si se cumple
   la condición de inducción para cada constructor $C_i$:

   \[P(a_1) \wedge P(a_2) \wedge \dots P(a_i) \Rightarrow P(C_i(a_1,a_2,\dots,b_0,b_1\dots))\]

Entonces $a::A \Rightarrow P(a)$.

*** Ejemplo 1: Naturales
Nuestro primer ejemplo va a ser obtener la inducción sobre los naturales
como caso particular. Damos una definición de los naturales en lenguaje
Haskell, con los axiomas de Peano, un natural es 0 o el siguiente de un
natural:

#+BEGIN_SRC haskell
    data Nat = O
             | S Nat
#+END_SRC

Que equivale a la definición en Coq:

#+BEGIN_EXAMPLE
    Inductive nat : Type :=
      | O : nat
      | S : nat -> nat
#+END_EXAMPLE

Es decir, si lo demostramos para =0= y para =S n= sabiéndolo para =n=,
lo hemos demostrado para todos los naturales.

*** Ejemplo 2: Árboles binarios
Ahora vamos a intentar el ejemplo que motivó esta búsqueda. Definimos un
árbol binario como un árbol vacío o como un nodo del que surgen dos
árboles binarios, en Haskell:

#+BEGIN_SRC haskell
    data Tree a = Empty
                | Node a (Tree a) (Tree a)
#+END_SRC

Que equivale a la definición en Coq:

#+BEGIN_EXAMPLE
    Inductive tree (X:Type) : Type :=
      | nilt : tree X
      | node : X -> tree X -> tree X -> tree X.
#+END_EXAMPLE

Es decir, si demostramos una propiedad para el árbol vacío y para un
árbol sabiendo que la cumplen sus subárboles derecho e izquierdo, la
hemos demostrado para todos los árboles binarios.

En el repositorio [[https://github.com/MROMAN42/recorridosArboles][mroman42/recorridosArboles]] hay
varias demostraciones por inducción sobre árboles binarios, explicados
en lenguaje natural y demostrados luego sobre el asistente de
demostraciones Coq.

[1] Post sobre generalizaciones de la inducción [[http://math.blogoverflow.com/2015/03/10/when-can-we-do-induction/][en Stack Overflow]].   
** Mónadas                                                                                   :post:
:PROPERTIES:
:TITLE:    Mónadas
:EXPORT_FILE_NAME: monadas.html
:INDEX_DATE: <2016-12-24 Mon 15:09>
:END:

#+BEGIN_QUOTE
  A monad is just a monoid in the category of endofunctors, what's the
  problem?

  -- *Philip Walder* (apócrifa) en /[[http://james-iry.blogspot.com.es/2009/05/brief-incomplete-and-mostly-wrong.html][A Brief, Incomplete, and Mostly Wrong History of programming languages]]/
#+END_QUOTE

*** Prerrequisitos
Este artículo requiere un conocimiento previo de Haskell, o al menos, de
otro lenguaje de programación funcional. Puedes consultar nuestra
[[http://tux.ugr.es/dgiim/blog/2014/10/01/intro-haskell/][introducción a Haskell]] con recursos para iniciarte en el lenguaje.

Por otro lado, para la segunda parte del artículo es recomendable
conocimiento previo sobre teoría de categorías. Aun así, no es necesaria
para leer la primera parte del artículo, donde hablamos de mónadas sin
hacer ninguna referencia explícita a la teoría de categorías. Si quieres
leer sobre ese tema, puedes consultar nuestros apuntes de
[[http://tux.ugr.es/dgiim/blog/2014/10/04/intro-categorias/][introducción a teoría de categorías]].

*** Motivación para las mónadas
**** Mónadas en Haskell
    :PROPERTIES:
    :CUSTOM_ID: mónadas-en-haskell
    :END:

Imaginemos que necesitamos controlar cuando una función interna devuelve
un error, o cuando usa un estado que debe ser pasado al resto de
funciones. Cuando trabajamos con programación funcional pura, debemos
devolver explícitamente el error (señalar cómo va a tratarlo cada
función) o pasar el estado como argumento a cada una de las funciones;
así que una solución sería modificar cada una de las funciones que
usamos para que tenga en cuenta ese estado o ese caso de error, pero
esto añadiría mucha complejidad innecesaria a nuestro código. La
estructura de mónada simplifica esta escritura.

El siguiente ejemplo, en el que tratamos el manejo de errores
encapsulado en una mónada, está inspirado en los ejemplos de:

-  [[http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf][Monads for functional programming]] - /Philip Wadler/

Que es una muy buena introducción al uso de las mónadas en programación
funcional.

**** Calculando raíces cuadradas
Por ejemplo, supongamos que intentamos sacar raíces cuadradas en los
reales usando el [[https://en.wikipedia.org/wiki/Integer_square_root#Algorithm][método de Newton]]. Si intentamos calcular $\sqrt{n}$, 
podemos tomar a cada paso la aproximación:

\[ x_{k+1} = \frac{1}{2}\left( x_k+\frac{n}{x_k} \right) \]

Y parar cuando estemos suficientemente cerca (más cerca que un ε dado):

\[ |x_{k+1} - x_k| < \varepsilon \]

Escribimos una implementación de ese concepto de convergencia para
listas infinitas en Haskell y del método de Newton, basado en la función
[[http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:iterate][=iterate=]]:

#+BEGIN_SRC haskell
    limit :: Float -> [Float] -> Float
    limit epsilon (x:y:xs)
      | abs (x-y) < epsilon = y
      | otherwise           = limit epsilon (y:xs)

    newtonaprox :: Float -> Float -> Float
    newtonaprox n x = (x + n/x)/2

    sqroot :: Float -> Float
    sqroot 0 = 0
    sqroot x = limit 0.03 (iterate (newtonaprox x) x)
#+END_SRC

Ahora imaginemos que usamos esta raíz cuadrada recién definida para
solucionar una ecuación de segundo grado $x^2 + bx + c = 0$:

\[ x = \frac{-b \pm \sqrt{b^2 - 4c}}{2} \]

Podemos definir una estructura de datos =QPol= para el polinomio y una
función que lo resuelva obteniendo sus dos raíces:

#+BEGIN_SRC haskell
  data QPol = QPol Float Float Float

  instance Show QPol where
      show (Qpol a b c) = show a ++ "x² + " ++ show b ++ "x + " show c

  solve :: QPol -> (Float,Float)
  solve (QPol a b c) = (sol1 sol2)
      where sol1 = ((-b) + sqroot(b*b-4*c*a))/(2*a)
            sol2 = ((-b) - sqroot(b*b-4*c*a))/(2*a)
#+END_SRC

Y podemos comprobar que funciona:

#+BEGIN_EXAMPLE
    λ> pol = QPol 1 (-5) 6
    λ> putStrLn $ "Las soluciones de " ++ show pol ++ " son " ++ solve pol
    Las soluciones de 1.0x² + -5.0x + 6.0 son (3.0,2.0)
#+END_EXAMPLE

**** Controlando los errores
Pero ¿qué ocurre cuando intentamos calcular la raíz cuadrada de un
número no positivo? Este método no la encuentra, por lo que debería
devolver un error antes de intentar empezar a calcularla. La solución
obvia es reflejar este error con un =Maybe= en el cálculo de la raíz
cuadrada.

#+BEGIN_SRC haskell
    sqroot' :: Float -> Maybe Float
    sqroot' x
      | x < 0     = Nothing
      | x == 0    = Just 0.0
      | otherwise = Just ( limit 0.03 (iterate (newtonsqrt x) x) )
#+END_SRC

Esto lo soluciona, pero nos crea un problema mayor. La función =solve=
está usando la raíz cuadrada y se espera de ella que devuelva un número,
no un posible error. Si queremos conseguir que funcione con la nueva
=sqroot'=, necesitaríamos implementar todas sus componentes internas
teniendo en cuenta ese error. Por ejemplo, deberíamos reescribir el
=(+)=, para tener en cuenta errores y propagarlos por todos los cálculos
involucrando a =sqroot'=:

#+BEGIN_SRC haskell
    (+.) :: Maybe Float -> Maybe Float -> Maybe Float
    (+.) Nothing _ = Nothing
    (+.) _ Nothing = Nothing
    (+.) (Just a) (Just b) = Just (a + b)
#+END_SRC

Pero esto es muy pesado de implementar; deberíamos implementarlo ¡para
cada una de las operaciones que usen la raíz cuadrada en algún punto!
Esto obliga a cada una de nuestras operaciones intermedias a ser
conscientes de la posibilidad de error, dándonos código mucho menos
modular y reusable.

Una solución ligeramente mejor es la de abstraer este proceso de hacer a
una función consciente de la posibilidad de error en una función aparte
y definir las demás en función suya:

#+BEGIN_SRC haskell
    errorAware :: (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
    errorAware op Nothing _ = Nothing
    errorAware op _ Nothing = Nothing
    errorAware op (Just a) (Just b) = Just (op a b)

    (+.), (*.) :: Maybe Float -> Maybe Float -> Maybe Float
    (+.) = errorAware (+)
    (*.) = errorAware (*)
#+END_SRC

Esto nos permite hacer cálculos con ellas:

#+BEGIN_EXAMPLE
    λ> sqroot' (-3) +. Just 4
    Nothing
    λ> sqroot' 3 +. Just 4
    Just 5.732143
#+END_EXAMPLE

**** La mónada Maybe
Esta idea para simplificar el tratamiento de errores, realizada
correctamente, es lo que nos va a proporcionar la estructura de mónada.
En Haskell, podemos definir una mónada como:

#+BEGIN_SRC haskell
    class Monad m where
      (>>=)  :: m a -> (a -> m b) -> m b
      return :: a -> m a
#+END_SRC

La idea intuitiva es que =(>>=)= nos permite tomar una función que puede
devolver errores pero que no comprueba a la entrada si ha recibido un
error, es decir, de tipo =(a -> Maybe b)= ; y aplicarla sobre una
función que puede contener un error. La podríamos usar por ejemplo para
componer varias =sqroot'=, que era algo que hasta ahora no podíamos
hacer sin tratar cada posible caso de error. Y la función =return=, que
en este caso es simplemente =Just=, nos permite considerar una constante
como un posible error. Podemos calcular fácilmente así
$$\sqrt{\sqrt{3}}$$ teniendo en cuenta los casos de error:

#+BEGIN_SRC haskell
    sqroot' (sqroot' 3)              -- ¡Error de tipos!
    sqroot' 3 >>= sqroot'            -- Usando mónadas
    Just   3 >>= sqroot' >>= sqroot' -- Usando Just
    return 3 >>= sqroot' >>= sqroot' -- Equivalente a lo anterior
#+END_SRC

**** Notación do
Las mónadas definen las funciones anteriores y muchas más que no vamos a
tratar ahora mismo, pero como resultado, nos acaban ofreciendo la
*[[https://en.wikibooks.org/wiki/Haskell/do_notation][notación do]]*,
que es la que podemos usar para acabar escribiendo nuestra función
=solve= como:

#+BEGIN_SRC haskell
    solve :: QPol -> Maybe (Float,Float)
    solve (QPol a b c) = do
      discriminant <- sqroot' (b*b - 4*c*a)
      return (((-b) + discriminant)/(2*a), ((-b) - discriminant)/(2*a))
#+END_SRC

En la primera línea tenemos en cuenta que la función =sqroot= puede
producir error, y en la segunda simplemente usamos el /posible/
resultado de ella sin tener que preocuparnos por el resto de funciones.

Nótese que la notación *do* es sólo una notación diseñada para aliviar
la escritura de operaciones con mónadas en algunos casos particulares;
es sólo /azúcar sintáctico/ para operaciones que no dejan de ser
puramente funcionales. Existen críticas al uso de esta notación. [1]

*** Mónadas en programación funcional
**** Mónadas como clase de tipos
Las mónadas en Haskell están definidas como una clase de tipos teniendo:

-  Un *constructor* de tipos ~m ∷ * -> *~, que para cada tipo =a=,
   devuelve una mónada conteniéndolo, =m a=.
-  Una *función* ~return ∷ a -> m a~, que para todo elemento de tipo
   =a=, devuelve una mónada que lo contiene.
-  Una *función* ~(>>=) ∷ m a -> (a -> m b) -> m b~, que dada una
   mónada y una función que se aplique sobre su interior y devuelva otra
   mónada, devuelve la mónada resultante. Sirve como composición de
   funciones monádicas.

La existencia de la última función equivale a la existencia de otras dos
funciones =fmap ∷ (a -> b) -> m a -> m b= y =join ∷ m (m a) -> m a=.

Nótese entonces que para ser mónada, una clase de tipos debe ser primero
un funtor. Dentro de los funtores que conocemos, podemos reconocer
algunas mónadas, incluyendo la mónada =Maybe= que hemos usado hasta
ahora:

#+BEGIN_SRC haskell
  -- Return de la mónada Maybe
  return x = Just x

  -- Bind de la mónada Maybe
  (Just x) >>= k = k x
  Nothing  >>= _ = Nothing

  -- Return de la mónada List
  return x = [x]

  -- Bind de la mónada List
  xs >>= f = [y | x <- xs, y <- f x]
#+END_SRC

Puedes empezar a leer tutoriales sobre el uso de las mónadas en Haskell
en:

 - [[http://learnyouahaskell.com/a-fistful-of-monads][A fistful of monads - Learn you a Haskell]]
 - [[https://en.wikibooks.org/wiki/Haskell/Understanding_monads][Understanding monads - Wikibooks]]

**** Mónada lista
En las listas, por ejemplo, tenemos como candidato para
=join :: [[a]] -> [a]= la concatenación de listas, =concat=. Nuestro
=return :: a -> [a]= será simplemente incluir un elemento en una lista
que sólo lo contenga a él.

En esta mónada, =(>>=)= mapea una función =a -> [a]= sobre cada elemento
de la lista y concatena todos los resultados:

#+BEGIN_EXAMPLE
    λ> [1,2,3] >>= (replicate 3)
    [1,1,1,2,2,2,3,3,3]
#+END_EXAMPLE

Nótese que, de la misma manera en la que podemos usar =(>>=)=, podemos
usar una versión con sus parámetros cambiados de orden, =(=<<)=. Aquí
usamos la mónada lista para enumerar los racionales repitiendo
elementos:[2]

#+BEGIN_SRC haskell
    import Data.List
    import Data.Ratio

    -- Crea los racionales con denominador n
    withDenom :: Integral -> [Rational]
    withDenom n = map (%n) [1..]

    -- Para cada entero, crea los racionales que lo
    -- tienen como denominador
    rationalsDup :: [Rational]
    rationalsDup = withDenom =<< [1..]

    -- Evita duplicados con 'nub'
    rationals :: [Rational]
    rationals = nub rationalsDup
#+END_SRC

**** Mónada IO
La mónada IO surge como una solución al problema de implementar efectos
secundarios (como la lectura o escritura) en un lenguaje puro y de forma
extensible, sin tener que alterar el sistema de tipos y respetando el
orden en el que queremos que se ejecuten.

#+BEGIN_SRC haskell
    greeting :: IO ()
    greeting = fmap ("Hola, "++) getLine >>= print
#+END_SRC

Pueden leerse más detalles sobre mónada IO y su implementación en:

-  [[http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/][IO is pure]] - Chris Taylor
-  [[https://www.microsoft.com/en-us/research/wp-content/uploads/1993/01/imperative.pdf][Imperative functional programming]] - Simon L. Peyton Jones, Philip Wadler
-  [[https://blog.jle.im/entry/first-class-statements][First-Class “Statements”]] - Justin Le

**** Mónada estado
En ocasiones necesitamos que nuestras funciones conserven un estado
además de realizar sus operaciones. Para esos casos existe la mónada
estado =State s=, que guarda un valor de estado de tipo =s=. Podemos
pensar en =State s a= como =s -> (a,s)=; es decir, un elemento dentro de
la mónada es una función dispuesta a tomar un estado inicial y a
devolver algún elemento junto a un estado final.

Existen tutoriales sobre la mónada estado en:

-  [[https://wiki.haskell.org/State_Monad][State Monad - Haskell wiki]]
-  [[http://learnyouahaskell.com/for-a-few-monads-more][For a few monads more - Learn you a Haskell]]
-  [[http://brandon.si/code/the-state-monad-a-tutorial-for-the-confused/][The State Monad: a tutorial for the confused - Brandon Simmons]]
-  [[http://adit.io/posts/2013-06-10-three-useful-monads.html][Three useful monads - Aditya Bhargava]]

Un uso de la mónada estado puede ser el guardar la semilla de una
generación pseudoaleatoria de números usando
[[https://en.wikipedia.org/wiki/Linear_congruential_generator][generadores lineales congruenciales]]. En concreto, usaremos la fórmula iterativa
$x_{i+1} \equiv 16807x_i \text{ mod } 2147483647$, que se expone [[https://math.dartmouth.edu/archive/m20f11/public_html/RANDOMNESS_LCG.pdf][aquí]].
Con este generador podremos escribir dados de un número dado de caras y
llamarlos varias veces. El estado interno pasará la semilla aleatoria de
un dado al siguiente:

#+BEGIN_SRC haskell
    import Control.Monad.State
    type Seed = Int

    dice :: Int -> State Seed Int
    dice n = state (\s -> (s `mod` n + 1, 16807*s `mod` 2147483647))
#+END_SRC

Y podríamos llamarlo con la semilla =1000= de la forma siguiente; que
nos devolverá por un lado el resultado de la tirada y por otro lado la
nueva semilla:

#+BEGIN_EXAMPLE
    λ> runState (dice 6) 1000
    (5,1660)
#+END_EXAMPLE

Si queremos hacer varias tiradas seguidas, podemos usar
=replicateM :: Int -> m a -> m [a]=, que se encarga de pasar
internamente la semilla de cada tirada a la siguiente tirada:

#+BEGIN_EXAMPLE
    λ> fst (runState (replicateM 100 (dice 6)) 1037)

    [6,6,2,5,4,3,6,1,4,6,3,6,4,4,6,3,5,1,5,2,6,4,2,6,4,2,4,
    5,1,6,5,4,1,3,5,4,6,4,2,3,4,2,1,1,6,5,5,4,1,1,4,6,5,3,6,
    3,1,1,5,1,4,1,2,3,5,5,4,5,3,3,2,6,4,1,1,1,2,5,4,5,2,4,5,
    6,1,2,4,3,3,6,4,6,3,4,5,1,4,2,2,2]
#+END_EXAMPLE

Incluso podemos crear nuevos generadores aleatorios a partir de los
anteriores con las operaciones usuales:

#+BEGIN_SRC haskell
    twodices :: State Seed Int
    twodices = do
        a <- dice 6
        b <- dice 6
        return (a+b)
#+END_SRC

Cuando lo llamemos, tomará la distribución suma de las dos
distribuciones de dados:

#+BEGIN_EXAMPLE
    λ> fst (runState (replicateM 100 twodices) 1032)

    [8,11,8,8,5,3,7,8,9,5,2,6,7,9,8,7,5,9,3,9,10,7,7,10,
    8,2,5,6,4,10,8,6,4,6,4,8,9,7,12,11,9,3,2,7,5,5,6,10,
    6,6,3,11,4,7,3,6,3,7,10,4,4,11,4,10,3,5,2,8,4,10,12,
    8,9,5,9,11,6,4,10,6,6,12,5,2,7,8,7,4,4,4,9,6,6,6,3,
    11,11,9,7,6]
#+END_EXAMPLE

*** Mónadas en teoría de categorías
Para entender cómo funcionan las [[https://es.wikipedia.org/wiki/M%C3%B3nada_(teor%C3%ADa_de_categor%C3%ADas)][mónadas]]
en teoría de categorías tenemos que entender dos conceptos: los
/productos en una [[https://es.wikipedia.org/wiki/Categor%C3%ADa_monoidal][categoría monoidal]]/ y /los endofuntores de una categoría/. 
La unión de ambos conceptos es lo que nos dará las mónadas como una 
construcción en teoría de categorías.

**** Categorías monoidales
Simplificando, una categoría monoidal es aquella donde, dados dos
objetos $A,B$, tenemos un objeto /"producto tensor"/ de ambos,
$A \otimes B$, donde además existe un objeto identidad $I$
cumpliendo propiedades como:

\[A \otimes B \cong B \otimes A\]

\[A \otimes (B \otimes C) \cong (A \otimes B) \otimes C\]

\[A \otimes I \cong A\]

**** Ejemplos de categorías monoidales
Los *conjuntos* con el producto cartesiano y el conjunto de un elemento
forman ya una categoría monoidal. Puede comprobarse sobre ellos que
existen los isomorfismos:

\[A \times B \cong B \times A\]

\[A \times (B \times C) \cong (A \times B) \times C\]

\[A \times \{\bullet\} \cong A\]

Pero además, podemos darles /otra/ estructura de categoría monoidal,
esta vez con la [[https://es.wikipedia.org/wiki/Uni%C3%B3n_disjunta][unión disjunta]] y el conjunto vacío:

\[A \sqcup B \cong B \sqcup A\]

\[A \sqcup (B \sqcup C) \cong (A \sqcup B) \sqcup C\]

\[A \sqcup \varnothing \cong A\]

En general, *todas las categorías con productos finitos son categorías
monoidales* con el producto categórico y el objeto terminal como unidad.
Todas las categorías con coproductos finitos son categorías monoidales
con el coproducto categórico y el objeto inicial como unidad.

Otro ejemplo distinto lo forman los *espacios vectoriales* sobre un
cuerpo $K$ con el producto tensor y el propio cuerpo sirviendo como
unidad; o los *grupos abelianos* con el producto tensor y $\mathbb{Z}$
siendo la unidad.

**** Objetos monoide
Un objeto $A$ de una categoría monoidal es objeto monoide cuando puedo
definir un morfismo desde el objeto identidad hacia él y un morfismo
desde el producto tensor $A \otimes A$ hacia él. Es decir, hay un
morfismo /unidad/, $I \overset{u}\longrightarrow A$; y hay un morfismo /multiplicación/,
$A \otimes A \overset{\mu}\longrightarrow A$.

Cumpliendo ciertas propiedades similares a las que exigimos a un
monoide. De hecho, un objeto monoide en la categoría de los conjuntos
con el producto cartesiano es simplemente un *monoide* normal y
corriente.

**** Categorías de endofuntores
El ejemplo que nos interesa ahora, sin embargo, es el de los
*endofuntores* de una categoría. Un *funtor*, de forma simplificada, es
una /aplicación entre categorías/; que lleva objetos en objetos y
morfismos en morfismos, respetando además el punto de inicio y fin de
cada morfismo.

Si consideramos los funtores de una categoría a sí misma, tenemos los
*endofuntores* de la categoría. Y entre ellos existen transformaciones
naturales que actúan como morfismos en el sentido de que se componen
para dar otras transformaciones naturales. Teniendo unos objetos (los
endofuntores), y unos morfismos (las transformaciones naturales),
tenemos una categoría. Nótese que hemos abstraído mucho, estamos
trabajando con una categoría en la que cada objeto es en sí mismo un
endofuntor y cada morfismo es toda una transformación natural entre dos
funtores.

Esta es además una categoría monoidal. El producto tensor de esta
categoría monoidal será la composición $\circ$, y el objeto identidad
el endofuntor identidad, que actúa dejando fijo cada objeto y cada
morfismo.

**** Mónadas
Pues bien, una mónada es un objeto monoide en la categoría de los
endofuntores con la composición como producto tensor. Esto quiere decir
que es un endofuntor $F$ con transformaciones naturales:

\[F \circ F \Rightarrow F\]

\[I \Rightarrow F\]

Como una transformación natural nos da un morfismo por cada objeto en el
que se aplica el funtor, lo que tenemos son familias de morfismos:

\[F(F(X)) \overset{\mu_x}\longrightarrow F(X)\]

\[X \overset{r_x}\longrightarrow F(X)\]

**** Una categoría para la programación funcional
Algunos sistemas de tipos, con las funciones entre ellos =A -> B= como
morfismos, forman una categoría[3]. No es el caso de Haskell, en el que,
por varios motivos, sus tipos no forman una categoría[4]; pero las
construcciones con inspiración en la teoría de categorías toman el
nombre de sus homólogas.[5]

El primer ejemplo de esto son los *funtores*. En Haskell, un funtor se
define como:

#+BEGIN_SRC haskell
  class Functor f where 
    fmap :: (a -> b) -> f a -> f b 
#+END_SRC

Es decir un funtor toma un tipo =a= (un objeto de la categoría), y nos
devuelve otro tipo =f a= (otro objeto de la /misma/ categoría). Por otro
lado, el funtor toma un morfismo =a -> b= y nos devuelve otro morfismo
=f a -> f b=. Es decir, los funtores de la programación funcional son
*endofuntores en la categoría de los tipos*, siempre que conserven
ciertas reglas que tienen su reflejo en las reglas de funtores en
Haskell.

**** Monoides en la categoría de los endofuntores
Entonces, si los funtores =f :: * -> *= son endofuntores en alguna
categoría, tiene sentido cuestionarse cuáles de ellos son monoides.
Esto, junto con ciertas restricciones que se le imponen como leyes a las
mónadas, equivale a decir que existen los morfismos dados por las
transformaciones naturales que pedíamos antes, es decir, deben existir
morfismos de tipos =a -> m a= y =m (m a) -> m a=:

#+BEGIN_SRC haskell
    return :: a -> m a
    join :: m (m a) -> m a
#+END_SRC

Así, a cualquier funtor que tiene estos dos morfismos, además del =fmap=
que tenía por ser funtor, lo llamamos *mónada*. Nótese que =>>== puede
implementarse desde =join= y viceversa, como:

#+BEGIN_SRC haskell
    (>>=) :: m a -> (a -> m b) -> m b
    (>>=) x f = join (fmap f a)

    join :: m (m a) -> m a
    join x = x >>= id
#+END_SRC

Tenemos entonces dos definiciones equivalentes de lo que es una mónada.
Una desde la teoría de categorías y otra desde la teoría de tipos y los
lenguajes de programación funcional. Una visión desde las mónadas como
monoides en la categoría de los endofuntores desde dentro de Haskell
puede verse [[http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html][aquí]].

*** Y más
Además de las enunciadas en este post, existen más otros temas
relevantes en relación a las mónadas, tanto en programación funcional
como en teoría de categorías:

-  [[http://book.realworldhaskell.org/read/monad-transformers.html][Transformadores de mónadas]], usadas para componer mónadas.
-  [[http://stackoverflow.com/questions/8428554/what-is-the-comonad-typeclass-in-haskell][Comónadas]], la noción dual de una mónada.
-  [[https://en.wikipedia.org/wiki/Kleisli_category][Categorías de Kleisli]], cada mónada da lugar a una categoría de Kleisli.
-  [[https://en.wikipedia.org/wiki/Adjoint_functors][Funtores adjuntos]], cada par de funtores adjuntos da lugar a una mónada.
-  [[http://www.cs.tufts.edu/comp/150FP/archive/brent-yorgey/tc.pdf][Typeclassopedia]], una revisión de otras clases de tipos relevantes en Haskell y
   relacionadas con la teoría de categorías.

*** Referencias
[1] Peligros de la notación do.
    [[https://wiki.haskell.org/Do_notation_considered_harmful][Do notation considered harmful]]

[2] Enumerando los racionales.
    [[http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/rationals.pdf][Enumerating the rationals - J. Gibbons, D. Lester, R. Bird]]

[3] La correspondencia entre tipos, lógica y categorías.
    [[https://ncatlab.org/nlab/show/computational+trinitarianism][Computational Trinitarianism - NLab]]

[4] Por qué los tipos de Haskell no son una categoría.
    [[http://math.andrej.com/2016/08/06/hask-is-not-a-category/][Hask is not a category - Andrej Bauer]]

[5] Por qué en ocasiones puede ser útil pensar en ellos como una
    categoría.
    [[https://ro-che.info/articles/2016-08-07-hask-category][Does it matter if Hask is (not) a category?]]
** Matemáticas en emacs                                                                      :post:
:PROPERTIES:
:TITLE:    Matemáticas en emacs
:EXPORT_FILE_NAME: matematicasemacs.html
:INDEX_DATE: <2016-09-26 Mon 15:07>
:END:

/Actualizado a 06 de agosto de 2017./

*** Apuntes a ordenador
Tomar apuntes de matemáticas con el ordenador es una tarea difícil por
lo complejo que es transcribir la notación (símbolos, letras en otros
alfabetos, índices...) y la velocidad necesaria. Además, los
diagramas, dibujos, flechas o anotaciones no textuales que tomamos
parecen imposibles de transcribir fielmente a un fichero.

*[[https://www.latex-project.org/about/][Latex]]* permite notación matemática pero no facilita la velocidad (al fin y
al cabo, Latex estaría pensado para edición de libros, no para tomar apuntes).
*[[https://daringfireball.net/projects/markdown/][Markdown]]*, por otro lado, simplifica mucho el poder escribir, pero pierde mucha 
potencia respecto a Latex. Así que una solución es usar *[[http://orgmode.org/][org-mode]]* como lenguaje
de marcado; es relativamente simple y fácilmente legible, como markdown, mientras
que permite visualización de latex conforme se edita, programación literaria y
exportación a latex y html, permitiendo la inclusión de código latex o html arbitrario
para exportarlo.

*** Ventajas de org-mode
*org-mode* tiene internamente un lenguaje de marcado similar al de
markdown, con la ventaja para el usuario de Emacs de que está adaptado
especialmente al editor. Permite escribir fórmulas en Latex y exportar
luego a =.tex= y =.pdf=, controlando las opciones de Latex.

Una fórmula en Latex puede escribirse directamente en *org-mode*
incluyéndola entre $\mathtt{\backslash\left( \dots \backslash\right)}$, si está dentro de una línea de texto 
(como en \(i \ast x = x\)); o entre $\backslash[\ \dots\ \backslash]$, cuando
queremos que se muestre aparte del texto como en el siguiente ejemplo

\[ \sum_{n=0}^\infty \frac{1}{2^n}. \]

Cuando terminamos de escribirla podemos [[http://orgmode.org/worg/org-tutorials/org-latex-preview.html][previsualizarla]] directamente con
=C-c C-x C-l=, como si fuera un editor [[https://es.wikipedia.org/wiki/WYSIWYG][WYSIWYG]].

Si vamos a acabar exportando a latex podemos insertar entornos como los
que ofrece la biblioteca de la AMS con

#+BEGIN_EXAMPLE
#+begin_theorem
[texto del teorema]
#+end_theorem
#+END_EXAMPLE

o incluso definir nuestros propios entornos y usarlos después de la misma
forma. Además, también permite la inclusión de bloques de código con

#+BEGIN_EXAMPLE
#+begin_src ruby
[código en ruby]
#+end_src
#+END_EXAMPLE

en la mayoría de lenguajes de programación y algunos especialmente útiles
para matemáticas como =Sage=.

*** Zoom
Un problema menor (y quizá sólo mío) al configurar todo esto es que
las fórmulas previsualizadas parecen demasiado pequeñas. Aunque estén
en proporción con el texto, cuesta más leerlas; y cuando aumentamos el
tamaño del texto con =C-x C-+=, las fórmulas no se amplían con
él. Para conseguir que lo hagan hay que incluir el siguiente trozo de
código en el archivo de configuración de Emacs, mezcla de dos
respuestas de [[http://emacs.stackexchange.com/questions/3387/how-to-enlarge-latex-fragments-in-org-mode-at-the-same-time-as-the-buffer-text][thisirs y Mark]] en Stack Overflow:

#+BEGIN_SRC lisp
  (defun update-org-latex-fragment-scale ()
    (let ((text-scale-factor
           (expt text-scale-mode-step text-scale-mode-amount)))
      (plist-put org-format-latex-options
                 :scale (* 1.2 text-scale-factor)))
  )
  (add-hook
   'text-scale-mode-hook
   'update-org-latex-fragment-scale)
#+END_SRC

Después de volver a cargar el archivo de configuración, las fórmulas nuevas
deberían volver a ajustarse con el texto.

*** Aumentando la velocidad de escritura
Mi objetivo principal con todo esto era escribir matemáticas más
rápidamente, así que [[http://emacs.stackexchange.com/questions/26322/math-autocompletion-in-org-mode][pregunté sobre autocompletado]] y concluí en usar
=latex-math-mode=. Esto permite incluir comandos de Latex con atajos
de teclado. En su configuración original usa el caracter =`= para
acceder a ellos, así que =`-a= escribe =\alpha=.  Yo he decidido
cambiar el acento invertido, que ya cuesta dos pulsaciones en el
teclado en español, por la =ç=, que no la suelo usar. Además de los
que incluye el paquete por defecto, se pueden escribir atajos propios.

Además de =latex-math-mode=, =cdlatex= es un modo de Emacs escrito
por el mismo creador de org-mode, que facilita la escritura rápida
de símbolos de latex. Puede añadirse a =org-mode= usando

#+BEGIN_SRC emacs-lisp
  (use-package cdlatex
    :ensure t)

  (add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+END_SRC

y las instrucciones del paquete pueden encontrarse [[https://github.com/cdominik/cdlatex][aquí]].

Por otro lado, empecé a usar *yasnippets* en Emacs. Son cómodos,
fáciles de programar, y me permiten simplificar tareas como escribir
diagramas conmutativos o complejos simpliciales en pocos pasos.

*** Diagramas conmutativos
Ahora estoy escribiendo sobre álgebra homológica y teoría de categorías, así que
la mayoría de lo que escribo usa secuencias exactas y diagramas conmutativos.

Para las secuencias exactas, por ejemplo, tengo simplemente
una plantilla con =yasnippet=, que me deja 
incluirlas escribiendo =complex_= y pulsando =<tab>=:

#+BEGIN_EXAMPLE
  # -*- mode: snippet -*-
  # name: complex
  # key: complex_
  #--
  \begin{aligned*} $1 \overset{$6}\longrightarrow 
  $2 \overset{$7}\longrightarrow 
  $3 \overset{$8}\longrightarrow 
  $4 \overset{$9}\longrightarrow 
  $5 \end{aligned*}
#+END_EXAMPLE

Para los diagramas conmutativos, la solución es un poco más
compleja. El paquete *tikz* de Latex es muy útil para escribirlos pero
tiene una sintaxis es demasiado recargada; así que existe *tikz-cd*, que
simplifica esa sintaxis para centrarla en diagramas conmutativos. Para
usarlo, hay que empezar por incluir en el archivo de configuración
=init.el= las siguientes líneas

#+BEGIN_SRC lisp
(add-to-list
  'org-latex-packages-alist '("" "tikz" t))

(eval-after-load "preview"
  '(add-to-list
    'preview-default-preamble
    "\\PreviewEnvironment{tikzpicture}"
    t))
#+END_SRC

que pueden modificarse y escribirse de forma análoga si queremos que Emacs
use internamente otros paquetes de Latex.

Además en mi caso, tuve que cambiar el programa con el que generaba
las imágenes. Parece funcionar sólo *imagemagick* cuando queremos
usar diagramas conmutativos

#+BEGIN_SRC lisp
     (setq org-latex-create-formula-image-program 'imagemagick)
   #+END_SRC

*** Cabeceras en Latex
Cuando necesitamos funcionalidad adicional que ofrece Latex en bibliotecas aparte,
como usar =tikz-cd=, podemos incluirlas en la cabecera del archivo org como:
   
#+BEGIN_SRC latex 
#+latex_header: \usepackage{amsthm}
#+latex_header: \usepackage{amsmath}
#+latex_header: \usepackage{tikz-cd}
#+END_SRC

Además, si queremos que sea funcionalidad que sólo se use en la exportación de
latex pero no en la previsualización, podemos incluirla con =#+latex_header_extra=.

*** Archivos de configuración de org
Para evitar tener que repetir varias veces la misma cabecera en varios
archivos, podemos usar un sólo archivo para escribir matemáticas y
fraccionarlo en secciones temáticas. Cuando necesitamos tratar una
sección, podemos usar la funcionalidad de /narrowing/ de [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Narrowing.html][org]] para
tratar sólo una sección. 

Otra opción es la de tener un sólo archivo de configuración
=math.setup= con reglas de la forma

#+BEGIN_SRC latex
#+latex_header: \usepackage{amsthm}
#+latex_header: \usepackage{amsmath}
#+latex_header: \usepackage{tikz-cd}
#+END_SRC

y cargarlo en cada archivo =org= con =#+SETUPFILE: math.setup=.

*** Ejemplos
Pueden encontrarse ejemplos de uso en [[https://github.com/mroman42/math][este repositorio]] con mis apuntes
de matemáticas. Mi archivo de configuración de Emacs está disponible en
[[https://github.com/M42/.emacs.d][mroman42/emacs.d]].
** Ideas de teoría de tipos                                                                  :post:
:PROPERTIES:
:TITLE:    Ideas de teoría de tipos
:EXPORT_FILE_NAME: ideasteoriatipos.html
:INDEX_DATE: <2016-01-08 Fri 15:13>
:END:

/Una recopilación de algunas ideas y enlaces después de haber empezado
a leer sobre teoría de tipos./

Los sistemas de tipos tienen su utilidad en las matemáticas. Sirven para
modelar una fundamentación de las matemáticas distinta de la usual
fundamentación conjuntista; y tienen varias aplicaciones interesantes en
lenguajes funcionales y asistentes de demostración. En particular, sobre
los tipos se puede definir un álgebra y se pueden representar sistemas
lógicos. Vamos a tratar esas aplicaciones referenciando en cada caso
artículos donde se exponen en profundidad.

*** Inducción estructural
La inducción estructural es una generalización de la inducción usual
sobre los naturales que la extiende a otras estructuras representables
como tipos de un lenguaje funcional. Sobre la inducción estructural
hemos escrito previamente en el blog una introducción:

-  [[http://tux.ugr.es/dgiim/blog/2015/03/14/induccion-estructural/][Inducción Estructural - Blog LibreIM]]

En ese post se escriben ejemplos sobre los naturales y los árboles. El
artículo sobre el que se basa es:

-  [[http://math.blogoverflow.com/2015/03/10/when-can-we-do-induction/][When can we do induction? - math.blogoverflow]]

Ejemplos y más detalles sobre inducción estructural y sus usos pueden
encontrarse en:

-  [[http://www.cs.cmu.edu/~me/212/handouts/structural.pdf][Some notes on Structural Induction - Michael Erdmann]]
-  [[http://arxiv.org/pdf/1312.2696.pdf][Structural Induction Principles for Functional Programmers - James Caldwell]]

Y varias demostraciones por inducción estructural implementadas en Coq
en este repositorio sobre [[https://github.com/mroman42/recorridosArboles][*recorridos en árboles*]].

*** Álgebra de tipos
En un post anterior del blog de *LibreIM* hemos tratado el álgebra de
tipos. Ese post se basó sobre otros tres publicados en el blog de Chris
Taylor:

-  [[http://tux.ugr.es/dgiim/blog/2015/03/24/algebra-tipos/][Álgebra de tipos - Blog LibreIM]]
-  [[http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/][The algebra of algebraic data types, Part I - Chris Taylor]]
-  [[http://chris-taylor.github.io/blog/2013/02/11/the-algebra-of-algebraic-data-types-part-ii/][The algebra of algebraic data types, Part II - Chris Taylor]]
-  [[http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/][The algebra of algebraic data types, Part III - Chris Taylor]]

En el segundo de los artículos se usan funciones generadoras para probar
resultados sobre los números de Catalan y los árboles binarios. La
teoría de funciones generadoras necesaria para entender el tratamiento
de los árboles binarios la explica Mike Spivey en
/[[https://mikespivey.wordpress.com/2013/03/19/the-catalan-numbers-from-their-generating-function/][The catalan numbers from their generating function]]/.

Además, existe un resultado de *Fiore y Leinster* que afirma que si
demostramos una relacion polinómica para números complejos, también será
válida para cualquier
[[https://en.wikipedia.org/wiki/Semiring][semianillo]]. Y por tanto,
para los tipos. Esto quiere decir que, en la mayoría de las ocasiones,
podemos usar la resta o la división de tipos como si existieran. La
demostración excluye algunos casos particulares y se expone aquí:

-  [[http://arxiv.org/pdf/math/0212377v1.pdf][Objects of categories as
   complex numbers - Marcelo Fiore y Tom Leinster]]

Sobre el uso de las derivadas en el álgebra de tipos existe un resultado
de *Conor McBride* que relaciona las derivadas parciales con los
[[http://learnyouahaskell.com/zippers][/zippers/]] de Haskell usados
para representar contextos. Puede leerse aquí:

-  [[http://strictlypositive.org/diff.pdf][The derivative of a regular
   type is its type of one-hole contexts - Conor McBride]].

*** Lógica con tipos
La aplicación de los tipos a la lógica y las demostraciones parte del
isomorfismo de Curry-Howard, que relaciona los sistemas de tipos con
sistemas lógicos. El sistema más simple donde puede apreciarse el
isomorfismo es el
[[https://en.wikipedia.org/wiki/Typed_lambda_calculus][*cálculo lambda tipado*]], que es isomorfo a la
[[https://en.wikipedia.org/wiki/Natural_deduction][*deducción natural*]]. La deducción natural es un ejemplo de lógica intuicionista,
lo que en la práctica quiere decir que /no/ (!) se tienen el /tercio
excluso/ y la /doble negación/ como axiomas:

$$ A \vee \neg A$$

$$ \neg \neg A \implies A $$

Los apuntes sobre [[https://github.com/libreim/curryHoward/blob/master/CurryHoward.pdf][*Curry-Howard*]]
de los repositorios del doble grado explican el isomorfismo sobre la
deducción natural y el cálculo lambda tipado. El
[[https://github.com/libreim/curryHoward/tree/master/src][código fuente]] acompañando los apuntes está escrito en Coq y Haskell.

La idea de tratar las proposiciones como tipos la expone *Philip Wadler*
en los dos siguientes artículos: primero de manera didáctica, con una
introducción histórica y sobre el sistema de la deducción natural, y
luego de forma más compleja, exponiendo el isomorfismo sobre el sistema
de tipos de Haskell.

-  [[http://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf][Propositions
   as Types - Philip Wadler]]
-  [[http://homepages.inf.ed.ac.uk/wadler/papers/gr2/gr2.pdf][The
   Girard-Reynolds Isomorphism - Philip Wadler]]

*** Parametricidad
La parametricidad limita las instancias posibles de los tipos de la
forma =forall a. p(a)=, y nos permite obtener teoremas sobre todas las
instancias de esos tipos. Se explica a nivel intuitivo en el siguiente
post de Bartosz Milewski y más formalmente en este paper de Philip
Wadler:

-  [[http://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/][Parametricity:
   Money for Nothing and Theorems for Free - Bartosz Milewski]]
-  [[http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf][Theorems
   for free! - Philip Wadler]]

*** Teoría de tipos
Los tipos pueden usarse para fundamentar las matemáticas, del mismo modo
que lo hacen los conjuntos (en sistemas axiomáticos como [[https://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory][ZFC]])
o las categorías (en sistemas como [[https://ncatlab.org/nlab/show/ETCS][ETCS]]). En el siguiente artículo
se discuten las diferencias de ambos con la *teoría de tipos
dependientes de Martin-Löf*, que se expone por completo en las notas de
Nordström, Petersson y Smith:

-  [[https://golem.ph.utexas.edu/category/2013/01/from_set_theory_to_type_theory.html][From Set Theory to Type Theory - The n-Category Café]]
-  [[http://www.cse.chalmers.se/~bengt/papers/hlcs.pdf][Martin-Löf Type Theory - B. Nordström, K. Petersson, J.M. Smith]]

Esto nos da una fundamentación de las matemáticas con una interpretación
computacional clara.

Una refinación de esas teorías para producir una fundamentación
también constructivista de las matemáticas es el Cálculo de
Construcciones (Calculus of constructions, COC) desarrollado por
*Thierry Coquand* y *Gérard Huet*, que finalmente dará lugar al
asistente de demostraciones *COQ*, desarrollado por el INRIA. El
[[https://en.wikipedia.org/wiki/Lambda_cube][*\lambda-cubo*]] es un diagrama para exponer cómo este sistema amplía al
/cálculo lambda tipado/ y al /Sistema $F_\omega$/ que usa Haskell.

-  [[http://ac.els-cdn.com/0890540188900053/1-s2.0-0890540188900053-main.pdf?_tid=3846e956-b301-11e5-8e78-00000aab0f02&acdnat=1451925532_87ac5a8e6a7bd6477746a55c17130f43][Calculus of Constructions - T. Coquand, G. Huet]].
-  [[https://coq.inria.fr/][The Coq proof assistant - INRIA]]

** Informal CV                                                                               :post:
:PROPERTIES:
:TITLE:    Informal CV
:EXPORT_FILE_NAME: informalcv.html
:INDEX_DATE: <2018-10-21 Sun>
:END:

 * December 2018. Attended [[http://events.cs.bham.ac.uk/syco/2/][SYCO2]]. (University of Strathclyde)
 * October 2018. Started a [[https://www.ox.ac.uk/admissions/graduate/courses/msc-mathematics-and-foundations-computer-science?wssl=1][MSc in Mathematics and Foundations of Computer Science]]. (University of Oxford)
 * August 2018. Participant [[https://homalg-project.github.io/capdays-2018/][CAP days]]. (Universität Siegen)
 * June 2018. Finished the double degree on Mathematics and Computer Engineering. (University of Granada)
 * June 2018. Presented my bachelor's thesis. [[https://mroman42.github.io/ctlc/ctlc.pdf][Category theory and lambda calculus]]. (University of Granada)
 * December 2017. [[https://unimath.github.io/bham2017/][School and Workshop on Univalent Mathematics]]. (University of Birmingham)
 * July 2017. [[https://sites.google.com/view/summerschool2017-eutypes/][EUTypes Summer School]]. (Ohrid, Macedonia)
 * March 2017. [[https://sites.google.com/unizar.es/affine-group-schemes-seminar/inicio][Seminar. Affine group schemes, an introduction]]. (University of Zaragoza)
 * October 2012. Attended the XXVII Olimpiada Iberoamericana de Matemática. (Cochabamba, Bolivia)
 * September 2012. Started a double degree in [[http://grados.ugr.es/informaticaymatematicas/][Mathematics and Computer Engineering]]. (University of Granada)
 * July 2012. Attended the [[http://oma.org.ar/imo2012/][53rd International Mathematical Olympiad]]. (Mar del Plata, Argentina)

** Projective, injective and flat modules
:PROPERTIES:
:TITLE:    Projective, injective and flat modules
:HUGO_TAGS: math
:HUGO_TOPICS: math
:HUGO_FILE: post/projectivemodules.md
:HUGO_DATE: [2017-02-18 Sat 15:10]
:END:

*** Definitions
An R-module $D$ is:

 1. *Projective* if $Hom(D, -)$ is an exact functor.
 2. *Injective* if $Hom(-,D)$ is an exact functor.
 3. *Flat* if $D \otimes -$ is an exact functor.

*** Characterization
We know that $Hom(D,-)$ and $Hom(-,D)$ are left-exact and that
$D\otimes -$ is right-exact; so for them to be exact, we only need:

- A module $D$ is *projective* when every $f : B \longrightarrow C$ surjective induces
  $(f\circ\_) :Hom(D,B) \longrightarrow Hom(D,C)$ surjective.
  #+attr_html: :width 300px
  https://raw.githubusercontent.com/mroman42/mroman42.github.io/images/projective.jpeg

- A module $D$ is *injective* when $f : A \longrightarrow B$ surjective induces
  $(\_\circ f) : Hom(B,D) \longrightarrow Hom(A,D)$ surjective.
  #+attr_html: :width 300px
  https://raw.githubusercontent.com/mroman42/mroman42.github.io/images/injective.jpeg
   
- A module $D$ is *flat* when $f : A \longrightarrow B$ injective induces 
  $f' : D\otimes A \longrightarrow D \otimes B$ injective.
** Wikipedia contributions                                                                   :post:
:PROPERTIES:
:TITLE:    Wikipedia contributions
:EXPORT_FILE_NAME: wikipediacontributions.html
:INDEX_DATE: <2018-02-17 Tue 12:00>
:END:

The majority of my math-related contributions to Wikipedia are
translations from the English language Wikipedia to the Spanish one
in math-related areas.  There are also some minor contributions to
other articles. There I keep a (not-that-updated) list of articles
I have contributed to.

 * [[https://es.wikipedia.org/wiki/Lema_de_escisi%25C3%25B3n][Lema de escisión]].
 * [[https://es.wikipedia.org/wiki/Compleci%25C3%25B3n_(%25C3%25A1lgebra)][Compleción (Álgebra)]].
 * [[https://es.wikipedia.org/wiki/Lema_de_la_serpiente][Lema de la serpiente]].
 * [[https://es.wikipedia.org/wiki/M%25C3%25B3nada_(teor%25C3%25ADa_de_categor%25C3%25ADas)][Mónada (teoría de categorías)]].
 * [[https://es.wikipedia.org/wiki/Funtor_Tor][Funtor Tor]].
 * [[https://es.wikipedia.org/wiki/M%25C3%25B3dulo_simple][Módulo simple]].
 * [[https://es.wikipedia.org/wiki/Teor%25C3%25ADa_de_dominios][Teoría de dominios]].
 * [[https://es.wikipedia.org/wiki/L%25C3%25ADmite_(teor%25C3%25ADa_de_categor%25C3%25ADas)][Límite]].
 * [[https://es.wikipedia.org/wiki/Extensi%25C3%25B3n_de_Kan][Extensión de Kan]].
 * Espacio de Cantor.
 * [[https://es.wikipedia.org/wiki/Categor%25C3%25ADa_de_espacios_topol%25C3%25B3gicos][Categoría de espacios topológicos]].
 * [[https://es.wikipedia.org/wiki/Categor%25C3%25ADa_cartesiana_cerrada][Categoría cartesiana cerrada]].
 * [[https://es.wikipedia.org/wiki/Teor%25C3%25ADa_de_tipos_homot%25C3%25B3pica][Teoría de tipos homotópica]].
 * [[https://es.wikipedia.org/wiki/C%25C3%25A1lculo_lambda_simplemente_tipado][Cálculo lambda simplemente tipado]].
 * [[https://es.wikipedia.org/wiki/Bloqueo_del_card%25C3%25A1n][Bloqueo del cardán]].
 * [[https://es.wikipedia.org/wiki/Fibraci%25C3%25B3n_de_Grothendieck][Fibración de Grothendieck]].

** Yoneda lemma
:PROPERTIES:
:TITLE:    Yoneda lemma
:EXPORT_FILE_NAME: wikipediacontributions.pdf
:INDEX_DATE: <2018-02-17 Tue 12:00>
:END:

*** Lema de Yoneda
Sea $G : {\cal C} \longrightarrow \mathtt{Set}$ un funtor covariante. Fijado $A \in obj({\cal C})$, tenemos una
biyección entre las transformaciones naturales del funtor $Hom(A,-)$ a
$G$ y los elementos del conjunto $G(A)$:

\[
y : Nat(Hom_{\cal C}(A,-),G) \longrightarrow G(A)
\]

Que viene dada por $y(\tau) = \tau_A(1_A)$, la imagen de la identidad por la
transformación natural.

**** Demostración
Dado cualquier $p$ crearemos la única transformación natural que cumple
$\eta_A(1_A) = p$. Por definición de transformación natural, sabemos que debe
cumplir el siguiente diagrama conmutativo:

#+attr_html: :width 500px
https://raw.githubusercontent.com/mroman42/mroman42.github.io/images/yonedaproof1.jpeg

Lo que deja determinado a cualquier $\eta_B(f)$, y por tanto a toda la función:

\[\eta_B(f) = \eta_B(f\circ id) = Gf(\eta_A(id_A)) = Gf(p) \]

Nos falta comprobar que la función así construida es de hecho una 
transformación natural. Es decir, que cumple el siguiente diagrama
conmutativo:

#+attr_html: :width 500px
https://raw.githubusercontent.com/mroman42/mroman42.github.io/images/yonedaproof2.jpeg

Y de hecho, dado cualquier elemento $f \in Hom(A,B)$ tenemos:

\[Gg\circ \eta(f) = Gg \circ Gf(p) = G(g\circ f)(p) = \eta(g\circ f)\]

*** Lema de Yoneda (caso contravariante)
Si aplicamos Yoneda sobre $\mathcal{C}^{op}$, dado $G : {\cal C} \longrightarrow \mathtt{Set}$ *contravariante*
y fijado $A \in obj({\cal C})$; existe una biyección entre las transformaciones naturales
del funtor $Hom(-,A)$ a $G$ y los elementos del conjunto $G(A)$:

\[
y : Nat(Hom_{\cal C}(-,A),G) \longrightarrow G(A)
\]

Que viene de nuevo dada por $y(\tau) = \tau_A(1_A)$.

*** Referencias y enlaces
[1] J. Rotman, An Introduction to Homological Algebra.

[2] Bartosz Milewski's Programming Cafe.
    [[https://bartoszmilewski.com/2015/09/01/the-yoneda-lemma/][The Yoneda Lemma]]

[3] The Catsters.
    [[https://www.youtube.com/watch?v=TLMxHB19khE][Representables and Yoneda 3]]
* About
:PROPERTIES:
:TITLE:  About
:EXPORT_FILE_NAME: about.html
:END:

Hi! I'm *Mario Román*.  I am studying an MSc on Mathematics and Computer
Science at the University of Oxford; my main interests being
[[https://en.wikipedia.org/wiki/Category_theory][categories]], [[https://en.wikipedia.org/wiki/Type_theory][types]], [[https://en.wikipedia.org/wiki/Functional_programming][functional programming]] and logic.  I completed my
(double) bachelor's degree at the [[https://www.ugr.es/en/][University of Granada]] (Spain).  I am a
founder and ex-organizer of the [[https://libreim.github.io/][LibreIM]] community, for which I still
write articles and organize seminars.

  - GitHub: [[https://github.com/mroman42][@mroman42]]
  - GitLab: [[https://gitlab.com/mroman42][@mroman42]]
  - CV: [[https://mroman42.github.io/friggeri-cv-a4/cv.pdf][My CV on Github pages]].
  - Email: [[mailto:mromang08+blog@gmail.com][mromang08+cosmoi@gmail.com]]
  - Mastodon: [[https://mastodon.social/@mroman42][@mroman42@mastodon.social]]

All the articles in this page are licensed under [[https://creativecommons.org/licenses/by-sa/2.0/][Creative Commons BY-SA 2.0]]
unless otherwise specified.

* Index
:PROPERTIES:
:TITLE:  Index
:EXPORT_FILE_NAME: index.html
:INDEX_DATE: <2018-05-25 Fri 18:12>
:END:

#+begin_src emacs-lisp :exports results :results output html :eval never-export
  (defun print-post-at-point () 
    (princ (concat  
      " <li><a href=" 
      (concat (org-entry-get (point) "EXPORT_FILE_NAME")  "> ") 
      (org-entry-get (point) "TITLE") "</a><em>"
      (format-time-string ", %d %B %Y" (date-to-time (org-entry-get (point) "INDEX_DATE"))) "</em><br></li>\n")))

  (defun print-index ()
    (progn 
      (princ "<ul>\n") 
      (org-map-entries (lambda () (print-post-at-point)) "+post" nil) 
      (princ "</ul>\n")))

  (print-index)
#+end_src
#+RESULTS:
#+BEGIN_EXPORT html
<ul>
 <li><a href=monoidescoloreadosbimonoidescoloreados.pdf> Monoides coloreados y bi(monoides coloreados)</a><em>, 13 April 2019</em><br></li>
 <li><a href=lawverefixedpoint.html> Lawvere's fixed point theorem</a><em>, 28 February 2019</em><br></li>
 <li><a href=apuntesdehaskell.html> Apuntes de Haskell</a><em>, 27 February 2019</em><br></li>
 <li><a href=diagramascategoriasmonoidales.pdf> Diagramas para categorías monoidales</a><em>, 21 January 2019</em><br></li>
 <li><a href=dotfilesinasingleorg.html> dotfiles in a single org-file</a><em>, 21 January 2019</em><br></li>
 <li><a href=everysurjectiontoprojectiveissplit.pdf> Every surjection to a projective R-module is split</a><em>, 24 December 2018</em><br></li>
 <li><a href=homcontinuous.pdf> Hom is continuous</a><em>, 23 December 2018</em><br></li>
 <li><a href=pastingpullbacks.pdf> Pasting pullbacks</a><em>, 23 December 2018</em><br></li>
 <li><a href=countinginlinearlogic.pdf> Linear logic is quantity-sensitive</a><em>, 23 December 2018</em><br></li>
 <li><a href=powersetalgebrascompletesemilattices.pdf> Powerset-algebras are complete semilattices</a><em>, 23 December 2018</em><br></li>
 <li><a href=picadolawvereinterview.html> Picado's Interview with Lawvere</a><em>, 08 September 2018</em><br></li>
 <li><a href=quoteampere.html> A quote by Ampère</a><em>, 03 September 2018</em><br></li>
 <li><a href=libreimquintoaniversario.html> LibreIM, casi cinco años después</a><em>, 03 September 2018</em><br></li>
 <li><a href=orgdrillspacedrepetition.html> Org-drill and spaced repetition</a><em>, 03 September 2018</em><br></li>
 <li><a href=uniquenessofidentityproofs.pdf> Uniqueness of identity proofs</a><em>, 25 August 2018</em><br></li>
 <li><a href=bachelorsthesisinorgmode.html> Writing a bachelor's thesis in org-mode</a><em>, 15 August 2018</em><br></li>
 <li><a href=bloggingwithasingleorgfile.html> Blogging with a single org-file</a><em>, 15 August 2018</em><br></li>
 <li><a href=coinduction.pdf> Coinduction</a><em>, 15 August 2018</em><br></li>
 <li><a href=cartesianclosedcategories.pdf> Cartesian closed categories</a><em>, 01 July 2018</em><br></li>
 <li><a href=categorytheoryandlambdacalculus.html> Category theory and lambda calculus</a><em>, 01 July 2018</em><br></li>
 <li><a href=evaluacionlambda.html> Evaluación en cálculo lambda</a><em>, 25 May 2018</em><br></li>
 <li><a href=mikrokosmos.html> Mikrokosmos</a><em>, 25 May 2018</em><br></li>
 <li><a href=aprendiendoemacs.html> Aprendiendo Emacs</a><em>, 25 May 2018</em><br></li>
 <li><a href=capturandolinksenorgmode.html> Capturando links en org-mode</a><em>, 23 March 2017</em><br></li>
 <li><a href=distribucionesmonadas.html> Distribuciones discretas con mónadas</a><em>, 25 May 2018</em><br></li>
 <li><a href=induccionestructural.html> Inducción estructural</a><em>, 14 March 2015</em><br></li>
 <li><a href=monadas.html> Mónadas</a><em>, 24 December 2016</em><br></li>
 <li><a href=matematicasemacs.html> Matemáticas en emacs</a><em>, 26 September 2016</em><br></li>
 <li><a href=ideasteoriatipos.html> Ideas de teoría de tipos</a><em>, 08 January 2016</em><br></li>
 <li><a href=informalcv.html> Informal CV</a><em>, 21 October 2018</em><br></li>
 <li><a href=wikipediacontributions.html> Wikipedia contributions</a><em>, 17 February 2018</em><br></li>
</ul>
#+END_EXPORT

* Publishing                                                                              :noexport:
The =cosmoi/publish= command exports all posts into HTML and PDF on the
main folder. You may want to regenerate the index first. Every post
must have the tag :post: and must have the properties

 - :TITLE:
 - :EXPORT_FILE_NAME:
 - :EXPORT_DATA:

#+BEGIN_SRC emacs-lisp
  ;; The exporter only works on the headers tagged as :post:. This tag
  ;; should not be inherited because we do not want subheaders to be
  ;; also exported independently.
  (setq org-tags-exclude-from-inheritance '("post"))

  ;; Format for the footer of each post.
  (setq org-html-postamble-format 
    '(("en" "<div id=\"footer\"><p class=\"postamble\">Last edited %d. Written by %c</p></div>")))

  ;; This function exports the header at point.  It checks if an HTML or
  ;; a PDF should be generated from the :EXPORT_FILE_NAME: extension and
  ;; acts accordingly.
  (defun cosmoi/export ()
    (interactive)
    (setq extension-name (file-name-extension (org-entry-get (point) "EXPORT_FILE_NAME")))
    (if (string-equal extension-name "html")
      (funcall 'org-html-export-to-html nil t)
      (funcall 'org-latex-export-to-pdf nil t)))

  ;; This function publishes the whole blog. It maps the exporter
  ;; function over all headers.
  (defun cosmoi/publish ()
    (interactive) 
    (org-map-entries
      (lambda () (if (org-entry-get (point) "EXPORT_FILE_NAME") 
           (cosmoi/export)))
      "-noexport" nil))

  (cosmoi/publish)


  ;;;;;;;;;;;;;;;;;;;;
  ;; RSS Feed
  ;;;;;;;;;;;;;;;;;;;;
  ;; Writes the header
  (setq xmlstring "<?xml version=\"1.0\" encoding=\"utf-8\"?>
  <rss version=\"2.0\" 	
    xmlns:atom=\"http://www.w3.org/2005/Atom\">
  <channel>

  <title>Cosmoi</title>
  <atom:link href=\"https://mroman42.github.io/cosmoi/rss\" rel=\"self\" type=\"application/rss+xml\" />
  <link>https://mroman42.github.io/cosmoi/</link>
  <description>
  Mathematics and computer science. 
  Categories, logic and types.
  </description>
  ")
  (write-region xmlstring nil "feed.xml")

  ;; Entries.
  (defun cosmoi/rssentry ()
    (interactive)
    (write-region (concat 
      "<item>\n"
      "<title>" (org-entry-get (point) "TITLE") "</title>\n"
      "<link>" (concat "https://mroman42.github.io/cosmoi/" (org-entry-get (point) "EXPORT_FILE_NAME")) "</link>\n"
      "<guid>" (concat "https://mroman42.github.io/cosmoi/" (org-entry-get (point) "EXPORT_FILE_NAME")) "</guid>\n"
      "<pubDate>" (format-time-string "%a, %d %b %Y %H:%M:%S GMT" (date-to-time (org-entry-get (point) "INDEX_DATE")))  "</pubDate>\n"
      "<description>" "</description>\n"
      "</item>\n"
      ) nil "feed.xml" 'append))

  (org-map-entries 
      (lambda () (if (org-entry-get (point) "EXPORT_FILE_NAME") 
        (funcall 'cosmoi/rssentry)))
      "+post" nil)

  ;; Closing tags
  (write-region "\n</channel>\n</rss>" nil "feed.xml" 'append)
#+END_SRC

#+RESULTS:

* Local variables                                                                         :noexport:
# Local Variables:
# eval: (defun cosmoi/publish () (interactive) (org-map-entries (lambda () (if (org-entry-get (point) "EXPORT_FILE_NAME") (funcall 'org-html-export-to-html nil t))) "-noexport" nil))
# eval: (setq org-tags-exclude-from-inheritance '("post"))
# eval: (setq org-html-postamble-format '(("en" "<div id=\"footer\"><p class=\"postamble\">Last edited %d. Written by %c</p></div>")))
# End:
