#+Title: Blog
#+Author: Mario Román
#+Email: mromang08@gmail.com
#+Date: 26 December 2019
#+Creator: <a href="https://mroman42.github.com">@mroman42</a>.
#+Options: toc:nil date:t num:nil html-style:nil html-postamble:t
#+export_file_name: docs/blog.html

* Blog index                                                                                :ignore:
:PROPERTIES:
:TITLE:  Blog
:EXPORT_FILE_NAME: docs/blog.html
:EXPORT_TITLE: Blog index
:INDEX_DATE: <2018-05-25 Fri 18:12>
:END:

#+begin_export html
<ul>
  {% for post in site.posts %}
    <li>
      <a href="{{ post.url }}">{{ post.title }}</a>
    </li>
  {% endfor %}
</ul>
#+end_export

* TODO Yoneda y ópticas
# A blog post on Yoneda lemma. Use the analogy of city travelling (@
# iceland jack) and give examples both in mathematics and optics.

** Bidireccionalidad y profuntores
# Por qué nos preocupa la bidireccionalidad.

** Fines y cofines
Nuestra herramienta principal será el cálculo de fines y cofines
cite:loregian15.

*** Definiciones                                                                          :ignore:
#+begin_definicion
Dado un profuntor $p \colon \mathbf{C}^{op} \times \mathbf{C} \to \mathbf{Set}$,
su *fin* es un objeto, que escribimos como una integral,
junto a una familia de proyecciones a la diagonal del profuntor,
\[
\pi_{a} \colon \left(  
\int_{x \in \mathbf{C}} p(x,x)
\right) \to p(a,a),
\mbox{ para cada }
a \in \mathbf{C}.
\]
Esta familia cumple una condición de coherencia, que dice que
para cualquier función $f \colon a \to b$, las dos formas posibles de llegar
desde la diagonal hasta $p(a,b)$ coinciden.
\[\begin{tikzcd}
& {\displaystyle \int_{x \in \mathbf{C}} p(x,x)} \dlar[swap]{\pi_{a}}\drar{\pi_{b}} & \\
p(a,a) \drar[swap]{p( \mathrm{id} ,f)} && p(b,b) \dlar{p(f , \mathrm{id})} \\
& p(a,b) &
\end{tikzcd}\]
Y además, es universal respecto a esta propiedad. Si tenemos cualquier
otro objeto con una familia coherente de proyecciones $z \to p(a,a)$
para todo $a \in \mathbf{C}$, entonces tenemos un único $z \to \int_{x \in \mathbf{C}} p(x,x)$ haciendo
los diagramas conmutar.
#+end_definicion

#+begin_definicion
Dado un profuntor $p \colon \mathbf{C}^{op} \times \mathbf{C} \to \mathbf{Set}$,
su *cofin* es un objeto, que escribimos como una integral (esta vez
con el índice arriba), junto a una familia de inclusiones a la
diagonal del profuntor,
\[
i_{a} \colon p(a,a) \to
\left(  
\int^{x \in \mathbf{C}} p(x,x)
\right),
\mbox{ para cada }
a \in \mathbf{C}.
\]
Esta familia cumple una condición de coherencia, que dice que
para cualquier función $f \colon a \to b$, las dos formas posibles de llegar
desde $p(a,b)$ hasta el cofin coinciden.
\[\begin{tikzcd}
& {\displaystyle \int^{x \in \mathbf{C}} p(x,x)} & \\
p(a,a) \urar  && p(b,b) \ular \\
& p(a,b) \urar[swap]{f}\ular{f} &
\end{tikzcd}\]
Y además, es universal respecto a esta propiedad. Si tenemos cualquier
otro objeto con una familia coherente de inclusiones $p(a,a) \to z$
para todo $a \in \mathbf{C}$, entonces tenemos un único $\int_{x \in \mathbf{C}} p(x,x) \to z$ haciendo
los diagramas conmutar.
#+end_definicion

*** Cuantificadores                                                                       :ignore:
Los fines son límites, parecidos a los productos (de hecho, son
ecualizadores); los cofines son colímites, parecidos a las sumas
(coecualizadores).  Una intuición es que los fines son cuantificadores
universales (=∀)= y los cofines son cuantificadores existenciales (=∃=).
¡Esta es sólo una notación!, pero será útil para simplificar cálculos
y para implementar las ideas en Haskell.

#+ATTR_LATEX: :options style=xcode
#+BEGIN_SRC haskell
    -- Fines.
    (∀ x . p x x)
    (∀ x . p x x) -> p a a
    (z -> p a a) -> (z -> (∀ x . p x x))
      
    -- Cofines
    (∃ x . p x x)
    p a a -> (∃ x . p x x)
    (p a a -> z) -> ((∃ x . p x x) -> z)
#+END_SRC

En este código, las proyecciones coinciden con instanciar el cuantificador.
Las propiedades universales se corresponden con reglas de deducción de los
cuantificadores. En todo el código usamos =a= como una variable de tipo, asumiendo
parametricidad.

*** Transformaciones naturales                                                            :ignore:
#+begin_ejemplo
Dados funtores $F,G \colon \mathbf{C} \to \mathbf{D}$, las transformaciones naturales entre ellos
vienen dadas por el siguiente fin.
\[
\mathrm{Nat}(F,G) = \int_{x \in \mathbf{C}} \mathbf{D}(Fx,Gx)
\]
Cuando la categoría de destino es $\mathbf{Sets}$ podemos escribir esto como sigue.
#+end_ejemplo
#+ATTR_LATEX: :options style=xcode
#+BEGIN_SRC haskell
    Nat f g  =  ∀ x . f x -> g x
#+END_SRC
#+begin_proof
Sea $z$ un conjunto con morfismos $z \to \mathbf{D}(Fx, Gx)$ para cada $x \in \mathbf{C}$.
Para cada $\alpha \in z$, los morfismos determinan una familia $\alpha_x \in \mathbf{D}(Fx,Gx)$.
Las condiciones de coherencia dicen que para cualquier $f \circ a \to b$
se tiene $Gf \circ\alpha_{a} = \alpha_{b} \circ Ff$. Eso quiere decir que $\alpha$ es una transformación
natural.
#+end_proof

** Lema de Yoneda
#+attr_latex: :options [Lema de Yoneda]
#+begin_theorem
Sea $\mathbf{C}$ una categoría y $F \colon \mathbf{C} \to \mathbf{Set}$ un funtor.  Para cualquier $a \in \mathbf{C}$,
el conjunto de transformaciones naturales del funtor $\mathbf{C}(a,-)$ al funtor $F$
es naturalmente isomorfo a $Fa$.
\[
\left(  \int_{x \in \mathbf{C}} \mathbf{C}(a,x) \to Fx \right) \cong F a
\]
En el caso de aplicarlo sobre la categoría de conjuntos obtenemos lo
siguiente.
#+BEGIN_verbatim 
∏    ∀ x . (a -> x) -> f x  ≅  f a
#+END_verbatim
#+end_theorem
#+begin_proof
Vamos a construir la biyección y demostrar que es una biyección.
Dado $u \in Fa$, tenemos un elemento de $\mathbf{C}(a,x) \to Fx$ para cualquier
$x \in \mathbf{C}$, dado por la acción del funtor.  En el otro sentido, dada
cualquier transformación natural $\mathbf{C}(a,x) \to Fx$, podemos aplicarla
sobre la identidad $\mathrm{id} \in \mathbf{C}(a,a)$ para obtener $Fa$.

Ahora debemos demostrar que esto es una biyección. En un sentido es
trivial, en el contrario, debemos demostrar que dos transformaciones
naturales con la misma acción en la identidad son iguales. Pero
precisamente por coherencia (o /naturalidad/) tenemos
$Ff(\eta_a( \mathrm{id})) =\eta_x(f)$.
#+end_proof

** TODO Isos
** TODO Tambara
#+begin_definicion
Un *módulo de Tambara* para un producto monoidal $\otimes$ es un profuntor
$p \colon \mathbf{C}^{op} \times \mathbf{C} \to \mathbf{Set}$ con una transformación
\[
p(x,y) \to p(c \otimes x , c \otimes y)
\]
natural en los tres argumentos y satisfaciendo cierta coherencia
que no detallamos.
#+end_definicion

#+begin_statement
Los módulos de Tambara forman una categoría con las transformaciones
naturales entre profuntores que respetan la estructura de módulo.
En particular, existe un funtor de olvido $U \colon \mathbf{Tamb}_{\otimes} \to \mathbf{Prof}$ y
tiene un adjunto izquierdo dado por
\[
\Phi(p)(s,t) = \int
\]
#+end_statement

** Drafts                                                                                :noexport:
*** Introducción
**** Funtor hom
Fijemos una categoría $\mathbf{C}$.  Dados cualesquiera dos objetos $a, b \in \mathbf{C}$, 
podemos considerar el conjunto de homomorfismos entre ellos,
$\mathbf{C}(a,b) \in \mathbf{Sets}$.  Además, dado un morfismo $f \colon b \to d$,
su /postcomposición/ $(f \circ -) \colon \mathbf{C}(a,b) \to \mathbf{C}(a,d)$ es una /función/,
un morfismo de conjuntos que transforma cada morfismo $u \colon a \to b$
en un morfismo $f \circ u \colon a \to d$. Y también, dado un mofismo $g \colon c \to a$,
su /precomposición/ $(- \circ g) \colon \mathbf{C}(a,b) \to \mathbf{C}(c,b)$ es otra función. Esto
determina un funtor.

#+begin_proposition
Fijado cualquier objeto $a \in \mathbf{C}$, podemos construir un funtor al que
llamaremos $\mathbf{C}(a,-) \colon \mathbf{C} \to \mathbf{Sets}$.  Su acción en morfismos viene dada
por la postcomposición.
#+end_proposition
#+begin_proof
Para demostrar que es un funtor, debemos demostrar que preserva
identidades y composiciones.  Para cualquier objeto $b \in \mathbf{C}$, sea
el morfismo identidad $\mathrm{id} \colon b \to b$.  Demostramos que la postcomposición
con la identidad, $(\mathrm{id} \circ -) \colon \mathbf{C}(a,b) \to \mathbf{C}(a,b)$ es a su vez la identidad en ese
conjunto: nótese que $( \mathrm{id}_b \circ -) h = \mathrm{id} \circ h = h = \mathrm{id}_{\mathbf{C}(a,b)}(h)$, luego
$(\mathrm{id}_{b} \circ -) = \mathrm{id}_{\mathbf{C}(a,b)}$.

Ahora demostraremos que también preserva composiciones. Dadas dos
funciones $f \colon b \to c$ y $g \colon c \to d$, queremos demostrar que la postcomposición
con $(g \circ f)$ es exactamente igual que la postcomposición $f$ /compuesta/
con la postcomposición con $g$. Tenemos que
\[\begin{aligned} ((g \circ -) \circ (f \circ -)) h &= (g \circ -) (f \circ h) & \mbox{ \textit{ (definición)}} \\&=
g \circ (f \circ h) & \mbox{ \textit{ (asociatividad)}}  \\&=
(g \circ f) \circ h & \mbox{ \textit{ (definición)}} \\&=
((g \circ f) \circ -) h,
\end{aligned}\]
luego $(g \circ -)\circ (f \circ -) = ((g \circ f) \circ -)$.
#+end_proof

/Nota:/ en las dos partes de esta demostración usamos dos veces el hecho
de que si dos funciones son iguales en cada punto, entonces son iguales.
Esto es, asumimos que $\forall x \in a, f(a) = g(a)$ implica $f = g$. Esto se
conoce como el principio de /extensionalidad de las funciones/, y es cierto
para morfismos de la categoría $\mathbf{Sets}$, pero no es cierto en general y podemos
encontrar contraejemplos en la categoría dada por los homomorfismos entre grafos.
Es decir, en esta demostración estamos usando crucialmente las propiedades de
los conjuntos. \\

Ahora podemos aplicar este mismo resultado a la categoría opuesta, para
tener que $\mathbf{C}(-,d) \cong \mathbf{C}^{op}(d,-) \colon \mathbf{C}^{op} \to \mathbf{Sets}$ también determina un funtor.
Nótese que este segundo funtor es contravariante, llevará cada morfismo
$f \colon a \to b$ a su /precomposición/ $(- \circ f) \colon \mathbf{C}(b,d) \to \mathbf{C}(a,d)$. \\

Todavía podemos ir más lejos, teniendo un funtor $\mathbf{C}(a,-) \colon \mathbf{C} \to \mathbf{Sets}$ y un funtor
$\mathbf{C}^{op} \to \mathbf{Sets}$, tenemos por la propiedad universal del producto un funtor
$\mathbf{C} \times \mathbf{C}^{op} \to \mathbf{Sets}$. Este funtor lleva pares de objetos $(a,b) \in \mathbf{C} \times \mathbf{C}^{op}$ de
forma covariante y contravariante respectivamente

#+begin_proposition
La asignación $\mathbf{C}(-,-) \colon \mathbf{C} \times \mathbf{C}^{op} \to \mathbf{Sets}$ que acabamos de describir
es funtorial.
#+end_proposition
#+begin_proof
#+end_proof

*** El lema de Yoneda
Fijemos una categoría $\mathbf{C}$.  Cada objeto $c \in \mathbf{C}$ determina un funtor contravariante
$\mathbf{C}(-,c) \in \mathbf{Cat}(\mathbf{C}^{op}, \mathbf{Sets})$. Los funtores de esta forma se llaman /representables/,
y decimos que $\mathbf{C}(-,c)$ está representado por $c$. Dada una función $f \colon c \to d$, su
postcomposición puede verse como una transformación natural
$(f \circ -) \colon \mathbf{C}(-,c) \tonat \mathbf{C}(-,d)$.  Esto induce un funtor.

#+begin_proposition
El *embebimiento de Yoneda* es un funtor $\hirayo \colon \mathbf{C} \to \mathbf{Cats}(\mathbf{C}^{op}, \mathbf{Sets})$ que está
determinado en objetos por $c \mapsto \mathbf{C}(-,c)$ y en morfismos por $f \mapsto (f \circ -)$.
#+end_proposition

#+attr_latex: :options [Lema de Yoneda]
#+begin_theorem
El *lema de Yoneda* dice que para toda categoría $\mathbf{C}$, existe una biyección
$[ \mathbf{C} , \mathbf{Set} ](\hirayo(A), F ) \cong FA$ natural en $F \in [ \mathbf{C} , \mathbf{Sets} ]$ y en $A \in \mathbf{C}$.
#+end_theorem
#+begin_proof

#+end_proof

*** Ópticas                                                                             :noexport:

**** Invariantes

**** Polimórficas

**** Composicionalmente
# Pickering. Compositionality fails.

*** Representación profuntorial de una óptica                                           :noexport:

*** En la práctica                                                                      :noexport:

*** Apéndice                                                                            :noexport:

**** Categoría producto
**** Categorías de funtores
*** TODO Van Laarhoven representation for lenses                                        :noexport:
# Derive it from Yoneda.
# Live code.
* TODO Diagonal arguments since Epimenides
** Epimenides
#+begin_quote
Epimenides the Cretan said that all Cretans were liars, and all other
statements made by Cretans were certainly lies. Was this a lie?
  -- /Mathematical logic as based on the theory of types/, Bertrand Russell.
#+end_quote

The first historical example of a diagonal argument is, in fact, not
an example. The negation of a universal quantifier is not an universal
quantifier; "not all Cretans are liars" is not the same as "all
Cretans are honest", and we can make the whole situation consistent by
simply assuming that *Epimenides* (a Cretan) is a liar, but not all
Cretans are.

A correct example would be the simpler "I am lying", which cannot be
neither true nor false without leading to contradiction. The example
presented by *Russell* is known as the [[https://en.wikipedia.org/wiki/Barber_paradox][Barber's paradox]].

** TODO Cantor's theorem
# http://www.goodmath.org/blog/category/bad-math/cantor-crankery/

** TODO Tarski-Gödel's theorem
#+BEGIN_corollary
A consistent theory cannot express its own truth. In particular, no
consistent formal system of arithmetic can encode the truth of
arithmetic statements.
#+END_corollary

** Lawvere
So, what is a diagonal argument? My intention here is to introduce you
to the *Lawvere's fixed-point theorem*, a result that captures all
these diagonal arguments.

First, let's consider some preliminary definitions.  Let $\mathbb{C}$
be a category with a terminal object. We say that any morphism
$a \colon 1 \to A$ from the terminal object to an arbitrary
object $A \in\mathbb{C}$ is an *element* of $A$, and we write this as $a : A$.
A morphism $g \colon A \to B$ is *point-surjective* if, for every element
$b : B$, there exists an element $a : A$ such that $g\ a = b$ (composition
of morphism is yuxtaposition here).  The name for these two definitions comes from their interpretation
in $\mathsf{Sets}$, where $1 \to A$ corresponds to an element of the set $A$ and
a point-surjective function is precisely a surjection. With these
definitions, the theorem can be stated in any [[id:3d52d110-822a-4f85-a1c4-57d868b527d5][cartesian closed
category]].

#+begin_theorem
(Lawvere's fixed point theorem). In any cartesian closed category, if
there exists a point-surjective morphism $d : A \to B^A$, then each
morphism $f : B \to B$ has a fixed point $b : B$, such that $f\ b = b$.
#+end_theorem
#+BEGIN_proof
As $d$ is point-surjective, there exists $x : A$ such that $d\ x \equiv \lambda a. f\ (d\ a\ a)$,
but then, $d\ x\ x \equiv (\lambda a.f\ (d\ a\ a))\ x \equiv f\ (d\ x\ x)$ is a fixed point.
#+END_proof

** Fixed points in untyped lambda calculus
#+BEGIN_corollary
Every term in untyped \lambda-calculus has a fixed point.
#+END_corollary

** References

 * http://math.andrej.com/2007/04/08/on-a-proof-of-cantors-theorem/
 * http://tac.mta.ca/tac/reprints/articles/15/tr15abs.html
* TODO A nice definition of "model of computation"
# Bauer's thesis
# Partial functions must appear in the definition anyway
# SKI happen to correspond to logical tautologies

* TODO The type-theoretic axiom of choice
* TODO Bach sonata
* TODO The natural example of natural transformation
Double dual of a vector space.
* TODO Categorical programming with CAP
* TODO A geodesic to Freyd-Mitchell
* TODO Etimología para Mikrokosmos
# Bartok
# Cosmoi -> Benabou
* TODO Media 2018
* TODO Three Emacs
* TODO Notes and spaced repetition cards in org-mode
* TODO Applicative functors
* TODO Recursion schemes
* TODO A quote by Conor McBride
#+begin_quote
  "The task of the academic is not to scale great intellectual
  mountains, but to flatten them." -- Conor McBride
#+end_quote

* TODO Readings for the ACT School 2019
* TODO Iosevka, ligatures, and box-drawing
https://github.com/be5invis/Iosevka/issues/227

#+BEGIN_SRC haskell
A B                                        Cin
║ ║                                         │
║ ╚═══╤════╤════╤════╤════╤════╤════╤════╕  │
╚════╤╪═══╤╪═══╤╪═══╤╪═══╤╪═══╤╪═══╤╪═══╕│  │
    ┌┴┴─┐┌┴┴─┐┌┴┴─┐┌┴┴─┐┌┴┴─┐┌┴┴─┐┌┴┴─┐┌┴┴─┐│
┌───┤ 7 ├┤ 6 ├┤ 5 ├┤ 4 ├┤ 3 ├┤ 2 ├┤ 1 ├┤ 0 ├┘
│   └──┬┘└──┬┘└──┬┘└──┬┘└──┬┘└──┬┘└──┬┘└──┬┘
│ ╔════╧════╧════╧════╧════╧════╧════╧════╛
│ ║
│ Y
│
Cout
#+END_SRC

* TODO Kaleidoscopes, or how to invent an optic

** TODO Definition of optic, profunctor representation
# Following Boisseau.

** TODO Kaleidoscope
# Applicative functors.

** TODO Composing with a classifying lens
** TODO Use case: the iris dataset

* TODO Combs and the Int construction                                                         :post:
:PROPERTIES:
:TITLE: Combs and the Int construction
:EXPORT_FILE_NAME: combsint.html
:EXPORT_DATE: 5th November 2019
:INDEX_DATE: <2019-11-05 Tue>
:END:

After seeing my MSc colleague Daphne Wang working on [[https://arxiv.org/pdf/1701.04732.pdf][Kissinger and
Uiljen]]'s /combs/ for the whole term, I realized at [[https://twitter.com/mroman42/status/1178776527279988736][some point]] that these
were lenses in a compact closed category.  The proof goes as follows.

#+BEGIN_SRC haskell
 ∫ᵂ (A → W ⊗ B)×(C ⊗ W → D)
≅ ⟨ Duals ⟩
 ∫ᵂ (A → W ⊗ B)×(W → C* ⊗ D)
≅ ⟨ Yoneda ⟩
 A → (C* ⊗ D) ⊗ B
≅ ⟨ Duals, Symmetry ⟩
 I → A* ⊗ B ⊗ C* ⊗ D
#+END_SRC

The same proof can be used to show that Int(C)≅Optic(C) when C is
compact closed. Here ~Int~ is the [[https://arxiv.org/abs/1904.11287][Int construction]].

In the general case, after a suggestion by Jules Hedges that came from a
tweet by Piedeleu; Elena Di Lavore and me wrote down an explicit
Optic(C)→Int(C) embedding.

 * [[./opticint.pdf][Optic embeds into the Int construction]].

* TODO Profunctor optics: a categorical update                                                :post:
:PROPERTIES:
:TITLE: Profunctor optics: a categorical update
:EXPORT_FILE_NAME: profunctoropticscategoricalupdate.html
:EXPORT_DATE: 5th July, 2019
:INDEX_DATE: <2019-07-05 Fri>
:END:

Being the slides for a presentation for the MFoCS at Oxford.  I
describe the motivation behind studying optics, study the general
definition of optic and provide an elementary derivation for the
traversal.

 * [[./mfocs-profunctoroptics-presentation.pdf][Link to the slides]].

* TODO Discokitty, an implementation                                                          :post:
:PROPERTIES:
:TITLE: Discokitty, an implementation
:EXPORT_FILE_NAME: discokittyimplementation.html
:EXPORT_DATE: 24th June, 2019
:INDEX_DATE: <2019-07-24 Mon>
:END:

As a part of the course on Distributional Models of Meaning by [[https://www.cs.ox.ac.uk/people/bob.coecke/][Coecke]]
and [[https://www.cs.ox.ac.uk/people/dan.marsden/][Marsden]], I wrote an educational implementation of the DisCoCat
framework (as described in 
/"[[https://arxiv.org/abs/1003.4394][Mathematical Foundations for a Compositional Distributional Model of Meaning]]"/).

*Discokitty* is written on Haskell and the code can be found [[https://github.com/mroman42/discokitty][on GitHub]].


* TODO Adjunciones (WIP)                                                                      :post:
:PROPERTIES:
:TITLE: Adjunciones (WIP)
:EXPORT_FILE_NAME: sobreadjunciones.html
:EXPORT_DATE: 21 de abril de 2019
:INDEX_DATE: <2019-04-21 Sun>
:EXPORT_OPTIONS: toc:1 num:t lang:es
:END:

/Este es un post en construcción que me gustaría expandir./
/No es una prioridad ahora mismo y no sé cuánto me llevará escribirlo./

*Introducción.* Las *adjunciones* son un concepto básico que no suele
aparecer en cursos de matemáticas hasta que se empieza a usar teoría
de categorías.  Muchas construcciones pueden expresarse como
adjunciones, y saber identificarlas y usarlas simplifica muchos
razonamientos.  La mayoría de estas notas vienen de traducir partes de
mi trabajo de fin de grado, pero pueden encontrarse (y bastante mejor
explicadas) en cualquier libro básico de teoría de categorías (/Awodey/,
/Riehl/ o /MacLane/), quizá con otra notación.  Especialmente la notación
como secuentes en lógica viene inspirada por teoría de tipos y no
parece especialmente común, pero aquí la usaremos en la mayoría de
demostraciones.

** Adjunciones
*Definición.* Una *adjunción* entre dos categorías *X* e *Y* es un par de
funtores F : *X* -> *Y* y G : *Y* -> *X*, junto a una biyección 
φ : hom(FX,Y) ≅ hom(X,GY) natural en X ∈ *X* y en Y ∈ *Y*.  Decimos que F
es /adjunto izquierdo/ a G y que G es /adjunto derecho/ a F, y escribimos eso
como F ⊣ G.

Decir que φ es natural significa para cualquier h : X -> X' y para cualquier
k : Y -> Y', los siguientes cuadrados conmutan.  Como además φ es una biyección,
podemos tomar φ⁻¹, darle la vuelta a las flechas, y seguir teniendo cuadrados
que conmutan.
#+BEGIN_SRC haskell
  hom(FX, Y)  -{φ}->  hom(X, GY)     hom(FX, Y)  -{φ}->  hom(X, GY)   
    |                   |              |                   |          
  {_∘Fh}              {_∘h}          {k∘_}              {Gk∘_}        
    ↓                   ↓              ↓                   ↓          
  hom(FX',Y) -{φ}->  hom(X',GY)      hom(FX,Y') -{φ}->  hom(X,GY')    
#+END_SRC

*Notación de Lawvere.* Una notación más sencilla para condensar toda
esta información es usando diagramas que simulan relaciones
lógicas. Aprendí esta notación en /Use of logical operators in Mathematics/,
unas notas de William Lawvere que me recomendó [[https://wpd.ugr.es/~bullejos/wordpress/][Manuel Bullejos]]. 
No he podido trazar cuál es el origen exacto, parece que es "folklore"
en teoría de categorías.

Una adjunción F ⊣ G puede escribirse como sigue.
#+BEGIN_SRC haskell
    F X -{f}-> Y
  ──────────────────
    X -{φ(f)}-> G Y
#+END_SRC

Esta notación enfatiza que a cada morfismo FX -> Y le corresponde un
morfismo X -> GY; y que esta es una relación biyectiva, yendo en ambas
direcciones.  La naturalidad se traduce en que la precomposición y la
poscomposición de morfismos son respetados por esta regla de inferencia.
Dados cualesquiera h : X' -> X y k : Y -> Y', sabemos por naturalidad
que las flechas compuestas en los siguientes diagramas son adjuntas entre
sí.

#+BEGIN_SRC haskell
    F X' -{Fh}-> F X -{f}-> Y        F X -{f}-> Y -{k}-> Y'
  ─────────────────────────────  ──────────────────────────────
    X' -{h}-> X -{φ(f)}-> G Y      X -{φ(f)}-> G Y -{Gk}-> G Y'
#+END_SRC

Es decir, φ(f) ∘ h = φ(f ∘ Fh) y Gk ∘ φ(f) = φ(k ∘ f).

*Definición.* Dada una adjunción F ⊣ G, la *unidad* y la *counidad* son las
familias de morfismos η : X -> GFX y ε : FGY -> Y, que se obtienen al
aplicar el isomorfismo a las identidades.

#+BEGIN_SRC haskell
    F X -{id}-> F X      F G Y -{ε}-> Y  
  ───────────────────   ───────────────────
     X -{η}-> G F X       G Y -{id}-> G Y
#+END_SRC

*** Unidad y counidad son transformaciones naturales                             :noexport:ignore:
#+begin_proposicion
La unidad y la counidad son transformaciones naturales.
#+end_proposicion
#+begin_proof
Sean $h \colon X \to X'$ y $k \colon Y \to Y'$. Comprobaremos que el
morfismo adjunto a $Fh$ es $GFh \circ \eta_X$ y $\eta_X' \circ h$ al
mismo tiempo, lo que implica que deben ser iguales. De
la misma forma, el adjunto a $Gk$ es $k \circ \varepsilon_Y$ pero
tambień $\varepsilon_{Y'} \circ FGk$.
\begin{prooftree}
\AXC{\begin{tikzcd}[fragile,ampersand replacement=\&] 
\phantom{Fx}\&
X \rar{h}\& 
Y \rar{\eta}\& 
GFY
\end{tikzcd}}
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&] 
FX \rar{\id}\& 
FX \rar{Fh}\& 
FY \rar{\id}\& 
FY 
\end{tikzcd}}
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&]
X \rar{\eta}\& 
GFX \rar{GFh}\&
GFY \&
\phantom{Gy}
\end{tikzcd}}
\AXC{\begin{tikzcd}[fragile,ampersand replacement=\&] 
FGX \rar{\varepsilon} \&
X \rar{k}\& 
Y \& 
\phantom{GFy}
\end{tikzcd}}
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&]
GX \rar{\id}\&
GX \rar{Gk}\&
GY \rar{\id} \&
GY
\end{tikzcd}}
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&]
\phantom{Gx}\&
FGx \rar{FGk}\&
FGy \rar{\varepsilon}\&
y \end{tikzcd}}
\noLine
\BIC{}
\end{prooftree}
#+end_proof

*** Unidad y counidad cumplen las ecuaciones de zig-zag                          :noexport:ignore:
#+begin_proposicion
La unidad y la counidad cumplen las ecuaciones dadas
en los siguientes diagramas, llamadas /ecuaciones triangulares/
o /ecuaciones de zig-zag/.
\[\begin{tikzcd}
G \drar[equal] \rar{\eta} & GFG \dar{G \varepsilon} &
FGF \dar[swap]{\varepsilon} & F \lar[swap]{F\eta} \dlar[equal] \\
& G & F &
\end{tikzcd}\]
Es decir, tenemos $G\varepsilon \circ \eta = \mathrm{id}$ y también $\varepsilon \circ F\eta = \mathrm{id}$.
#+end_proposicion
#+begin_proof
Probaremos algo todavía más general, que $Gf \circ \eta = \varphi(f)$ y que
también $\varepsilon \circ Fg = \varphi^{-1}(g)$ para cualesquiera $f \colon FX \to Y$ y
$g \colon X \to GY$.  En efecto, aplicando naturalidad en los diagramas
tenemos que deben coincidir.
\begin{prooftree}
\AXC{\begin{tikzcd}[fragile,ampersand replacement=\&] 
FX \ar[bend left=45]{rr}{\varepsilon_{Y} \circ Fg} \rar{Fg}\& 
FGY \rar{\varepsilon_Y}\& 
Y 
\end{tikzcd}}
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&]
X \ar[bend right=45]{rr}[swap]{g} \rar[swap]{g}\& 
GY \rar[swap]{\id}\&
GY 
\end{tikzcd}}
\AXC{\begin{tikzcd}[fragile,ampersand replacement=\&]
FX \ar[bend left=45]{rr}{f} \rar{\id}\&
FX \rar{f}\&
Y \end{tikzcd}}
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&]
X \ar[bend right=45]{rr}[swap]{Gf \circ \eta_X} \rar[swap]{\eta_X}\&
GFX \rar[swap]{Gf}\&
GY \end{tikzcd}}
\noLine
\BIC{}
\end{prooftree}
#+end_proof

** Caracterización y propiedades                                                         :noexport:
Las adjunciones contienen muchísima información.  Ahora mismo nos
sería muy difícil probar que dos funtores forman una adjunción. Lo que
necesitamos son formas de caracterizarlas.

*** Caracterización                                                                       :ignore:
#+attr_latex: :options [Caracterización de adjunciones]
#+begin_proposition
<<prop-characterize-adjunctions>>
Una adjunción $F \dashv G$ entre categorías $\mathbf{X}$ y $\mathbf{Y}$ 
viene determinada por cualesquiera de las siguientes opciones,

 1. funtores $F,G$ y $\eta\colon 1 \tonat GF$ donde $\eta_X\colon X \to GFX$ es universal sobre $G$.
 2. funtor $G$ y universales $\eta_X \colon X \to GF_0 X$; aquí $F_0X \in \mathbf{Y}$ crea un funtor $F$.
 3. funtores $F,G$ y $\varepsilon\colon FG \tonat 1$ donde $\varepsilon_Y\colon FGY \to Y$ es universal sobre $F$.
 4. funtor $F$ y universales $\varepsilon_Y\colon FG_0Y \to Y$; aquí $G_0Y \in \mathbf{X}$ crea un funtor $G$.
 5. funtores $F,G$, con transformaciones naturales satisfaciendo $G\varepsilon \circ \eta G = \id$ y $\varepsilon F \circ F\eta = \id$
    (zig-zag).
#+end_proposition
#+begin_proof
/1./ Universality of $\eta_X$ gives a isomorphism $\varphi \colon \hom(FX,Y) \cong \hom(X,GY)$ between 
the arrows in the following diagram
\[\begin{tikzcd}
& GY & Y \\
X \rar[swap]{\eta_x}\urar{f} & GFX \uar[swap,dashed]{Gg} & FX \uar[dashed,swap]{\exists! g}
\end{tikzcd}\]
defined as $\varphi(g) = Gg \circ \eta_X$. This isomorphism is natural in $X$; for every
$h \colon X' \to X$ we know by naturality of $\eta$ that $Gg \circ \eta \circ h = G(g \circ Fh) \circ \eta$.
The isomorphism is also natural in $Y$; for every $k \colon Y \to Y'$ we know by
functoriality of $G$ that $Gh\circ Gg \circ \eta = G(h \circ g) \circ \eta$.

/2./ We can define a functor $F$ on objects as $FX = F_0X$. Given any
$h \colon X \to X'$, we can use the universality of $\eta$ to define
$Fh$ as the unique arrow making this diagram commute
\[\begin{tikzcd}
& GFX' & FX' \\
X \rar[swap]{\eta_X}\urar{\eta_{X'} \circ h} & GFX \uar[swap,dashed]{GFh} &
FX \uar[dashed,swap]{\exists! Fh}
\end{tikzcd}\]
and this choice makes $F$ a functor and $\eta$ a natural transformation,
as it can be checked in the following diagrams using the existence
and uniqueness given by the universality of $\eta$ in both cases.
\[\begin{tikzcd}
&&& X'' \rar{\eta_{X''}}  & GFX''  & FX'' \\
& GFX & FX & X'  \uar{h'} \rar{\eta_{X'}}  & GFX'  \uar[swap]{GFh'}  & 
FX' \uar[dashed]{\exists! Fh'} \\
X \rar[swap]{\eta_X}\urar{\eta_{X}} & GFX \uar[swap,dashed]{\id} & 
FX \uar[dashed,swap]{\id} & 
X \rar{\eta_{X}}\uar{h} & GFX \uar[swap]{GFh} & 
FX \uar[dashed]{\exists! Fh'} \ar[dashed,swap,bend right]{uu}{\exists! F(h' \circ h)}
\end{tikzcd}\]

/3./ The proof is dual to that of /1/.

/4./ The proof is dual to that of /2/.

/5./ We can define two functions $\varphi(f) = Gf \circ \eta_X$ and $\theta(g) = \varepsilon_Y \circ Fg$.
We checked in 1 (and 3) that these functions are natural in both arguments;
now we will see that they are inverses of each other using naturality
and the triangle identities

 * $\varphi(\theta(g)) &= G\varepsilon \circ GFg \circ \eta = G\varepsilon \circ \eta \circ g = g$;
 * $\theta(\varphi(f)) = \varepsilon \circ FGf \circ F\eta = f \circ \varepsilon \circ F\eta = f$.\qedhere
#+end_proof

*** Unicidad                                                                              :ignore:
#+ATTR_LATEX: :options [Unicidad esencial de adjuntos]
#+BEGIN_proposition
Dos adjuntos al mismo funtor $F,F' \dashv G$ son naturalmente isomorfos.
#+END_proposition
#+BEGIN_proof
Construiremos un isomorfismo natural a partir de las dos unidades $\eta, \eta'$
que determinan las adjunciones. Para cada $X$, sabemos que $\eta_X \colon X \to GFX$
y $\eta_{X'} \colon X \to GF'X$ son universales desde $X$ hacia $G$.  Se puede ver que
en general los morfismos universales son únicos salvo isomorfismo, así que
existe un $\theta_X \colon FX \to F'X$ tal que $G\theta_X \circ \eta_X = \eta'_X$. \\

Sabemos que $\theta$ es natural porque para cualquier $f \colon X \to Y$ los morfismos
$\theta \circ Ff$ y $F'f \circ \theta$, hacen conmutar el siguiente diagrama.
\[\begin{tikzcd}
Y \rar{\eta'} & GF'Y & F'Y\\
X \rar{\eta}\uar{f} & GFX \uar[dashed,swap]{} & FX \uar[dashed]{\exists!}
\end{tikzcd}\]
En efecto,

 * $G(\theta \circ Ff) \circ \eta = G\theta \circ GFf \circ \eta = G\theta \circ \eta \circ f = \eta' \circ f$;
 * $G(F'f \circ \theta) \circ \eta = GF'f \circ G\theta \circ \eta = GF'f \circ \eta' = \eta' \circ f$.

Pero el morfismo haciendo conmutar el diagrama debería ser único, así
que $\theta \circ Ff = F'f \circ \theta$.
#+END_proof

*** Composición                                                                           :ignore:
#+ATTR_LATEX: :options [Composición de adjunciones]
#+BEGIN_theorem
Dadas dos adjunciones $\varphi \colon F \dashv G$ y $\theta \colon F' \dashv G'$ entre dos
pares de categorías ${\cal X},{\cal Y}$ y ${\cal Y},{\cal Z}$ respectivamente, los funtores
compuestos crean una adjunción $\varphi \cdot \theta \colon F'\circ F \dashv G\circ G'$. 
#+END_theorem
#+BEGIN_proof
La composición de isomorfismos naturales es de nuevo un isomorfismo natural,
así que lo único que hacemos es obtener el isomorfismo que buscamos por
composición.
\begin{prooftree}
\AXC{\begin{tikzcd}[fragile,ampersand replacement=\&]
F'FX \rar{f}\& Y
\end{tikzcd}}
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&]
FX \rar{\theta(f)}\& G'Y
\end{tikzcd}}
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&]
X \rar{\varphi\theta(f)}\& GG'Y
\end{tikzcd}}
\end{prooftree}
#+END_proof

Si además queremos conocer la unidad y counidad de esta adjunción, podemos
aplicar la biyección compuesta a las identidades, como sigue.
Si la unidad y la counidad de $\varphi$ son $\pair{\eta,\varepsilon}$ y las de
$\theta$ son $\pair{\eta',\varepsilon'}$, la unidad y la counidad de la adjunción
compuesta vienen dadas por $\pair{G \eta' F \circ \eta,\ \varepsilon' \circ F' \varepsilon G'}$.
\begin{prooftree}
\AXC{\begin{tikzcd}[fragile,ampersand replacement=\&] 
\phantom{FX}\&
F'FX \rar{\id}\& 
F'FX 
\end{tikzcd}}
\doubleLine
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&] 
FX \rar{\id}\& 
FX \rar{\eta'_{FX}}\& 
G'F'FX
\end{tikzcd}}
\doubleLine
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&]
X \rar[swap]{\eta}\& 
GFX \rar[swap]{G\eta'_{FX}}\&
GG'F'FX
\end{tikzcd}}

\AXC{\begin{tikzcd}[fragile,ampersand replacement=\&] 
GG'Z \rar{\id} \&
GG'Z \& 
\phantom{FFGy}
\end{tikzcd}}
\doubleLine
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&]
FGG'Z \rar{\varepsilon_{G'Z}}\&
G'Z \rar{\id}\&
G'Z \end{tikzcd}}
\doubleLine
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&]
F'FGG'Z  \rar[swap]{F'\varepsilon_{G'Z}}\&
F'G'Z \rar[swap]{\varepsilon'}\&
Z \end{tikzcd}}
\noLine
\BIC{}
\end{prooftree}

** Muchas adjunciones                                                                    :noexport:
Esta parte viene inspirada por la numerosísima cantidad de adjunciones que
pueden encontrarse al hacer categorías y por un hilo en [[https://math.stackexchange.com/questions/46708/a-bestiary-about-adjunctions][Math.SE]].

*** Monoides libres
#+begin_proposicion
Consideremos la categoría de los monoides con los homomorfismos de
monoide.  El funtor $F \colon \mathbf{Set} \to \mathbf{Mon}$ que envía cada conjunto a su
monoide libre es el adjunto izquierdo del funtor $U \colon \mathbf{Mon} \to \mathbf{Set}$
que a cada monoide le asocia su conjunto subyacente.
#+end_proposicion
#+begin_proof
Vamos a usar la caracterización de las adjunciones. Crearemos una
familia de funciones $\eta_X \colon X \to UFX$ y probaremos la universalidad
del siguiente diagrama.  Aquí $M$ es un monoide con unidad $e$ y multiplicación
$(\cdot)$.
\[\begin{tikzcd}
& UM & M \\
X \rar[swap]{\eta_x}\urar{f} & UFX \uar[swap,dashed]{Uh} & FX \uar[dashed,swap]{\exists! h}
\end{tikzcd}\]
Puede ayudar pensar que si $X$ es un conjunto, $FX$ es el conjunto de
las listas finitas sobre $X$.  Por el diagrama sabemos que $h[x] = f(x)$
está determinado; pero además, como $h$ debe ser un homomorfismo de
monoides, esto lo hace estar determinado sobre cualquier lista.
Concluimos que el único morfismo posible está definido como
$h[x_1,\dots,x_{n}] = f(x_1) \cdot \ldots \cdot f(x_{n})$.
#+end_proof

La mónada asociada a esta adjunción es la mónada lista.  Las álgebras
sobre esta mónada son precisamente los monoides.

*** Conexiones de Galois
#+begin_definicion
Los conjuntos parcialmente ordenados forman categorías en las que
hay un único morfismo $a \to b$ cuando $a \leq b$.  Un funtor entre dos
conjuntos parcialmente ordenados es una función monótona. Una
*conexión de Galois* es una adjunción entre conjuntos parcialmente
ordenados.
#+end_definicion

Es decir, una adjunción entre $P$ y $Q$ consiste en funciones monótonas
$f \colon P \to Q$ y $g \colon Q \to P$, con la siguiente doble implicación para
cualesquiera $x \in P$, $y \in Q$.
\begin{prooftree}
\AXC{\begin{tikzcd}[fragile,ampersand replacement=\&] f(x) \leq y \end{tikzcd}}
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&] x \leq g(y) \end{tikzcd}}
\end{prooftree}
Estos casos son especialmente fáciles de identificar y de demostrar
porque en ellos las condiciones de naturalidad se satisfacen
automáticamente. Esto es así porque hay a lo sumo un único morfismo
entre cualesquiera dos objetos, y por tanto, dos morfismos entre los
mismos objetos deben coincidir.

#+begin_ejemplo
Sea una topología en un conjunto $X$.  Los abiertos forman un conjunto
parcialmente ordenado con la inclusión ${\cal O}(X)$, pero de hecho todos los
elementos del conjunto potencia forman un conjunto parcialmente ordenado
con la inclusión, ${\cal P}(X)$.  Podemos ver un abierto como un elemento del
conjunto potencia $i \colon {\cal O}(X) \to {\cal P}(X)$.  El *interior* de un conjunto
$\mathsf{int} \colon {\cal P}(X) \to {\cal O}(X)$ es el adjunto derecho a esa inclusión, $i \dashv \mathsf{int}$.
\begin{prooftree}
\AXC{\begin{tikzcd}[fragile,ampersand replacement=\&] i(U) \subseteq A \end{tikzcd}}
\UIC{\begin{tikzcd}[fragile,ampersand replacement=\&] U \subseteq \textsf{int}(A) \end{tikzcd}}
\end{prooftree}
Nótese que ambos son equivalentes para cualquier $U \in {\cal O}(X)$ y cualquier
$A \in {\cal P}(X)$.  Esto también nos dice que el interior es comonádico; y sus
coálgebras son los conjuntos abiertos.
#+end_ejemplo

*** Distribuciones y símplices
Consideramos un funtor que envía un conjunto $X$ al conjunto de
distribuciones finitas sobre él, $DX$.  Las álgebras sobre la mónada
de esta adjunción son los conjuntos convexos; en particular las
álgebras libres sobre conjuntos finitos se llaman *símplices*.

*** Los cuantificadores son adjunciones
# Fibraciones de Grothendieck
** Mónadas y álgebras                                                                    :noexport:

*** Mónadas                                                                               :ignore:
#+begin_definicion
Una *mónada* es un funtor $T\colon X \to X$ con una transformación natural
$\eta\colon \Id \tonat T$ llamada *unidad* y una transformación natural $\mu \colon T^2 \tonat T$,
llamada /multiplicación/; tales que los siguientes diagramas conmutan.
\[\begin{tikzcd}
T^3 \rar{T\mu}\dar{\mu T} & T^2\dar{\mu} \\
T^2 \rar{\mu} & T
\end{tikzcd}
\qquad
\begin{tikzcd}
\Id \circ T \rar{\eta T}\drar[swap]{\cong} & T^2\dar{\mu} & \lar[swap]{T\eta}\dlar{\cong} T\circ \Id \\
& T &
\end{tikzcd}\]
Una *comónada* es el dual a una mónada, con una *counidad* $\varepsilon \colon T \tonat \Id$
y una comultiplicación $T \tonat T^2$.
#+end_definicion

#+begin_ejemplo
Las mónadas en un preorden son funciones idempotentes crecientes.
#+end_ejemplo

*** Cada adjunción da lugar a una mónada                                                  :ignore:
#+begin_proposicion
Dada una adjunción $G \dashv F$, la composición $G \circ F$ es una mónada.
#+end_proposicion
#+begin_proof
La unidad de la adjunción es la unidad de la mónada. El producto
será $\mu = G\varepsilon$.  La asociatividad es el siguiente diagrama, que se
obtiene primero por naturalidad y luego aplicando funtores.
\[\begin{tikzcd}
FGFG\rar{FG\varepsilon} \dar[swap]{\varepsilon} & FG \dar{\varepsilon} \\
FG\rar{\varepsilon} & I
\end{tikzcd}
\qquad
\begin{tikzcd}
GFGFGF\rar{GFG\varepsilon} \dar[swap]{G\varepsilon} & GFGF \dar{G\varepsilon} \\
GFGF\rar{G\varepsilon} & GF
\end{tikzcd}\]
La unitalidad viene dada precisamente por las ecuaciones de zigzag.
#+end_proof

** Álgebras                                                                              :noexport:

*** Álgebras                                                                              :ignore:
#+begin_definicion
Un *álgebra* sobre un funtor $F \colon \mathbf{C} \to \mathbf{C}$ viene dada por un objeto
$X \in \mathbf{C}$ equipado con un morfismo $FX \to X$ llamado /morfismo/ /de/
/estructura/.
#+end_definicion

Un morfismo entre dos álgebras dadas por $FX \to X$ y por $FY \to Y$
viene dado por un $h \colon X \to Y$ haciendo conmutar el siguiente
diagrama.
\[\begin{tikzcd}
FX \rar{Fh}\dar{\mu} & FY\dar{\nu} \\
X \rar{h} & Y
\end{tikzcd}\]
Con estos morfismos, las álgebras sobre un funtor forman una
categoría.  El objeto inicial de esta categoría no necesita existir,
pero cuando lo hace es único salvo isomorfismo.

*** Lambek                                                                                :ignore:
#+ATTR_LATEX: :options [Lambek]
#+begin_teorema
El morfismo de estructura de un álgebra inicial es un isomorfismo.
Es decir, si $X$ es un álgebra inicial, entonces $\mu \colon FX \cong X$ (véase cite:awodey10).
#+end_teorema
#+begin_proof
Consideremos el siguiente diagrama conmutativo, donde $l \colon X \to FX$ 
viene dado por la inicialidad de $X$.
\[\begin{tikzcd}
FX\rar{Fl} \dar[swap]{\mu} &
FFX \dar{F\mu} \rar{F\mu} &
FX \dar{\mu} \\
X\rar{l} &
FX\rar{\mu} &
X
\end{tikzcd}\]
Por inicialidad de $X$ sabemos que $\mu \circ l = \id$, y por conmutatividad
de la parte izquierda,  $l \circ \mu = F(\mu \circ l) = \id$.
#+end_proof

*** Catamorfismos, anamorfismos e hilomorfismos                                           :ignore:
Podemos usar el punto fijo de los funtores para definir catamorfismos
y anamorfismos. Hay un problema y es que =Fix= encontrará /un/ punto fijo
si lo hay (teorema de reducción a izquierda para el cálculo lambda),
pero no tenemos forma de fijar el que queremos.

#+BEGIN_SRC haskell
    -- Declaramos el punto fijo de un funtor.  Si nos da el álgebra
    -- o la coálgebra inicial, 'In' y 'out' serán isomorfismos por
    -- el teorema de Lambek.
    newtype Fix f = In { out :: f (Fix f) }
    
    type Algebra f a = f a -> a
    type Coalgebra f a = a -> f a
    
    -- Usando el teorema de Lambek.
    cata :: (Functor f) => Algebra f a -> Fix f -> a
    cata alg = alg . fmap (cata alg) . out
    
    ana :: (Functor f) => Coalgebra f b -> b -> Fix f
    ana coalg = In . fmap (ana coalg) . coalg
#+END_SRC

*** Catamorfismo: listas                                                                  :ignore:
#+begin_ejemplo
El funtor polinómico $1+A \times (-)$ tiene como álgebra inicial
las listas de tipo $A$.
#+end_ejemplo
#+BEGIN_SRC haskell
    -- Listas, monoides libres.
    data ListF a f = NilF | ConsF a f deriving (Functor)
    type List a = Fix (ListF a)
    
    nil = In NilF
    cons = ((In .) . ConsF)
    
    algsum :: (Num a) => Algebra (ListF a) a
    algsum NilF        = 0
    algsum (ConsF a b) = a + b
    
    sumlist :: (Num a) => List a -> a
    sumlist = cata algsum
#+END_SRC


*** Los números naturales son un álgebra inicial                                          :ignore:
#+ATTR_LATEX: :options [Objeto de números naturales]
#+BEGIN_exampleth
<<example-naturalnumbersobj>>
Consider the functor $F(X) = 1 + X$ in a category ${\cal C}$ with coproducts
and a terminal object. Its initial algebra is called a *natural numbers object*
due to the fact that, in $\Set$, this initial algebra is precisely the
set of natural numbers $\mathbb{N}$ with the successor function $\mathrm{succ}\colon \mathbb{N} \to \mathbb{N}$
and the zero element given as a morphism from the terminal object, $0 \colon 1 \to \mathbb{N}$.
\[\begin{tikzcd}
1+\mathbb{N}\rar{} \dar[swap]{\pair{0,\mathrm{succ}}} & 1+X\dar{\pair{x,f}} \\
\mathbb{N}\rar{\varphi} & X
\end{tikzcd}\]
Let $X$ be an $F\text{-algebra}$ given by $x \colon 1 \to X$ and $f \colon X \to X$; by induction over
the natural numbers we can show that a morphism of algebras $\varphi$ making that diagram
commute must follow $\varphi(0) = x$ and $\varphi(\mathrm{succ}(n)) = f(\varphi(n))$. Thus, in a certain sense, 
initiality captures the principle of induction.

For instance, we can define addition $+ \colon \mathbb{N} \times \mathbb{N} \to \mathbb{N}$, interpreted
as a unary operation $+ \colon \mathbb{N} \to \hom(\mathbb{N},\mathbb{N})$, as the unique morphism $\varphi$
from the initial algebra to the algebra given by $\hom(\mathbb{N},\mathbb{N})$ with $\id$
and postcomposition with $\mathrm{succ}$.
\[\begin{tikzcd}
1+\mathbb{N}\rar{} \dar[swap]{\pair{0,\mathrm{succ}}} & 
1+\hom(\mathbb{N},\mathbb{N}) \dar{\pair{\id, \mathrm{succ}\,\circ\, -}} \\
\mathbb{N}\rar{+} &
\hom(\mathbb{N},\mathbb{N})
\end{tikzcd}\]
This definition immediately implies the equalities $0+m = \id(m) = m$
and $\mathrm{succ}(n) + m = (\mathrm{succ}\circ (n+\_))(m) = \mathrm{succ}(n+m)$.
#+END_exampleth

** Los adjuntos derechos preservan límites                                               :noexport:
*** Límites                                                                               :ignore:
#+begin_definicion
Dada una categoría $\mathbf{C}$ y cualquier categoría $n$ podemos considerar un *funtor diagonal*
$\Delta_n \colon \mathbf{C} \to \mathbf{C}^n$ que se define constante como $\Delta(X,k) = X$ en objetos y $\Delta(f,k) = f$ 
en morfismos.  Un *límite* es un adjunto derecho al funtor diagonal; un *colímite* es
un adjunto izquierdo al funtor diagonal. [fn:deflimite]
#+end_definicion

El funtor diagonal tiene una propiedad interesante, es una /comultiplicación/ que
preserva cualquier funtor. Esto quiere decir que para cualquier $F \colon \mathbf{C} \to \mathbf{C}$,
podemos considerar $F_{(n)} \colon \mathbf{C}^n \to \mathbf{C}^{n}$ como el funtor que resulta de aplicar $F$ en
cada uno de los índices. Tenemos entonces $\Delta \circ F = F_{(n)} \circ \Delta$. 

#+begin_teorema
Los adjuntos derechos son continuos. Los adjuntos izquierdos son
cocontinuos.
#+end_teorema
#+begin_proof
Sea un límite $\Delta^n \dashv \mathsf{lim}$. Si tenemos una adjunción $L \dashv R$, podemos componerlas
para obtener $\Delta^n \circ L \dashv R \circ \mathsf{lim}$. Por otro lado, podemos ver que $L^{(n)} \dashv R^{(n)}$ y
podemos componer la adjunción $L^{(n)} \circ \Delta^{(n)} \dashv \mathsf{lim} \circ R^{(n)}$.  Pero sabemos que
$\Delta^n \circ L = L^{(n)} \circ \Delta^{n}$ y que las adjunciones son únicas salvo isomorfismo, así
que $\mathsf{lim} \circ R^{(n)} \cong R \circ \mathsf{lim}$.
#+end_proof

#+begin_corolario
Para cualesquiera conjuntos $A,B,C \in \mathbf{Set}$, se tiene $(A + B) \times C \cong A \times C + B \times C$.
#+end_corolario

[fn:deflimite] Los límites suelen considerarse en más generalidad, permitiendo que
no formen un funtor sino que sólo se den determinados casos.  Esta presentación va
a ayudar a simplificar mucho la próxima demostración y no perdemos nada que nos
importe especialmente ahora.  Para una definición estándar de límite se puede
usar cite:maclane78.

** references                                                                     :ignore:noexport:
bibliographystyle:alpha
bibliography:Math.bib


* TODO Lawvere's fixed point theorem                                                          :post:
:PROPERTIES:
:TITLE: Lawvere's fixed point theorem
:EXPORT_FILE_NAME: lawverefixedpoint.html
:INDEX_DATE: <2019-02-28 Mon 10:23>
:END:

This is a note stating the main result 
from [[http://tac.mta.ca/tac/reprints/articles/15/tr15.pdf][Diagonal arguments and Cartesian Closed Categories]] by
William Lawvere.

*Definition.* A morphism s : X -> Y is /point-surjective/ if for each y : 1
-> Y, there exists some x : 1 -> X such that sx = y.

*Theorem* (Lawvere, 1969). In any cartesian closed category, if there exists a
point-surjective morphism d : A -> (A -> B), then each morphism f : B ->
B has a fixed point, that is, some b : B such that f b = b.

*Proof.* As d is point-surjective, there exists x : A such that dx =
λa.f(daa), but then, dxx = (λa.f(daa)) x = f(dxx) is a fixed point.

* TODO The GranaSAT client                                                                    :post:
:PROPERTIES:
:TITLE: The GranaSAT client
:EXPORT_FILE_NAME: granasatclient.html
:INDEX_DATE: <2019-07-03 Wed>
:END:

Some time ago I wrote a GTK+ app in C for the [[https://github.com/mroman42/granasatClient][GranaSAT project]]. I did
not know anything about GUI design but I was eager to learn.  The only
requirement was that it had to be written in C (or Java) and using
Eclipse (that should set your alarm bells ringing); but the rest of
the specifications were changing every day, making this a very
challenging /software engineering/ project. The code is licensed under
GPLv3 and you can browse it in [[https://github.com/mroman42/granasatClient][its repository]], the correspoding server
was written by [[https://github.com/agarciamontoro/granasatServer][@agarciamontoro]].

/Bonus track:/ the team ended up capturing an [[https://www.youtube.com/watch?v=YUlWg6wuCxo][aurora borealis]]!

* TODO Apuntes de Haskell                                                                     :post:
:PROPERTIES:
:TITLE: Apuntes de Haskell
:EXPORT_FILE_NAME: apuntesdehaskell.html
:INDEX_DATE: <2019-02-27 Mon 21:00>
:END:

Hace ya un tiempo, [[https://github.com/mx-psi][@mx-psi]] y yo escribimos estos 
[[https://github.com/libreim/haskell][apuntes de introducción a Haskell]].  Los hemos usado varias veces
en los seminarios de LibreIM, [[https://github.com/pedritomelenas][Pedro García-Sánchez]] añadió un 
[[https://github.com/libreim/haskell/blob/3acbc2f7088483d3ba69ecdc00891c8419341aaf/PrimeraParte/PrimeraParte.ipynb][cuaderno de Jupyter]] para acompañarlos, y finalmente [[https://github.com/mx-psi][@mx-psi]] ha vuelto a revisarlos
y dejarlos listos para otro seminario este año. 

* TODO Right adjoints are continuous                                                          :post:
:PROPERTIES:
:TITLE: Right adjoints are continuous
:EXPORT_FILE_NAME: homcontinuous.html
:INDEX_DATE: <2018-12-23 Sun>
:EXPORT_DATE: 23th December 2018
:END:

/This is an exercise on Abramsky and Tzevelekos' notes/
/on the course [[https://arxiv.org/pdf/1102.1313.pdf][Categories, Proofs and Processes]]./

*Proposition.* Let A be an object in the category *C*. Show that the covariant hom functor
C(A,-), preserves all limits.

/Proof./ Let *I* be a small category,  F : *I* -> *C* a functor and let L with the
morphisms lᵢ be the limit of that functor. We know that for every
morphism  ϕ : i -> j  in *I*, we have lⱼ = Fϕ ∘ lᵢ.

Let Z be a set with a family of morphisms fᵢ : Z -> C(a,Fi) determining
a cone to C(a,F-) : *I* -> *Sets*; that is, such that for each  ϕ : i -> j in *I*, we 
have that  fⱼ = (Fϕ ∘ -) ∘ fᵢ; or, in other words, for each z ∈ Z we have
fⱼ(z) = Fϕ ∘ fᵢ(z). Thus, fixing any  z ∈ Z gives as a family of morphisms
fᵢ(z) ∈ C(a,Fi) defining a cone.  This implies that there exists some
unique morphism ψ(z) : A -> L  such that  lᵢ ∘ a(z) = fᵢ(z).

Repeating this for every z ∈ Z we have obtained a function  a : Z -> C(A,L)
with the property lᵢ ∘ a = fᵢ. This function must be the unique one with this
property, because for any other  a' : Z -> C(A,L), for each z ∈  
we would have lᵢ ∘ a'(z) = fᵢ(z) and that would imply that a'(z) = a(z).

\\

*Proposition.* Right adjoints preserve limits.

/Proof./ (From Awodey 2010) Let  L : *C* -> *D*  and  R : *D* -> *C* be a pair of adjoints
L ⊣ R. Let Xᵢ be objects determining any diagram and Y an arbitrary object.
We have the following chain of natural transformations between
hom-sets.

#+BEGIN_SRC haskell
  hom(Y , R lim Xᵢ) ≅
  hom(L Y , lim Xᵢ) ≅
  lim hom(L Y , Xᵢ) ≅
  lim hom(Y , R Xᵢ) ≅
  hom(Y , lim R Xᵢ)
#+END_SRC

By Yoneda Lemma, this means R lim Xᵢ ≅ lim RXᵢ.

* TODO dotfiles in a single org-file                                                          :post:
:PROPERTIES:
:TITLE: dotfiles in a single org-file
:EXPORT_FILE_NAME: dotfilesinasingleorg.html
:INDEX_DATE: <2019-01-21 Mon 19:01>
:END:

I was thinking that it would be nice to have all your configuration
files on a single, literate, org-mode file... and actually it should
be really easy to make it work: take an org file and create an org-babel block 
for the contents of each configuration file. They can be tangled
back into the filesystem using the property =:tangle /path/tofile=,
where =/path/tofile= is the desired location of the config file.
If =sudo= is needed, =tramp= can be used with =:tangle /sudo::/path/tofile=.

For instance, this is how =.Xresources= looks now inside my org file.
Highlighting works perfectly thanks to org-babel.

#+BEGIN_EXAMPLE
    ** X resources
    
    Configuration parameters for X client applications.
   
    #+BEGIN_SOURCE conf /home/mario/.Xresources
    xterm*font: *-fixed-*-*-*-24-*
    Xft.dpi:    192
    #+END_SOURCE
#+END_EXAMPLE

This file can be put under version control and a /dotfiles repository/
can be created without having to use hard links (yep, I was doing that
until now).

As always with Emacs, this use case is obvious in retrospect, but /why
didn't anyone tell me?/

* TODO Picado's Interview with Lawvere                                                        :post:
:PROPERTIES:
:TITLE: Picado's Interview with Lawvere
:EXPORT_FILE_NAME: picadolawvereinterview.html
:INDEX_DATE: <2018-09-08 Sat 17:20>
:END:

[[http://www.mat.uc.pt/~picado/][Jorge Picado]] (who is also coauthor of the book on [[https://www.maa.org/press/maa-reviews/frames-and-locales-topology-without-points][locales]] I am reading) has
many nice 'popularisation of mathematics' articles on his webpage. I
have enjoyed a lot his interview with William Lawvere.

 * http://www.mat.uc.pt/~picado/lawvere/interview.pdf

Specially interesting is this criticism to the extra-mathematical
publicity around Gödel's theorem. However, I cannot locate exactly
what 'organized attempts' is he referring to.

#+BEGIN_QUOTE
In Diagonal arguments and Cartesian closed categories we demystified
the incompleteness theorem of Gödel and the truth-definition theory of
Tarski by showing that both are consequences of some very simple
algebra in the Cartesian-closed setting. It was always hard for many
to comprehend how Cantor’s mathematical theorem could be re-christened
as a “paradox” by Russell and how Gödel’s theorem could be so often
declared to be the most significant result of the 20th century.  There
was always the suspicion among scientists that such extra-mathematical
publicity movements concealed an agenda for re-establishing belief as
a substitute for science. Now, one hundred years after Gödel’s birth,
the organized attempts to harness his great mathematical work to such
an agenda have become explicit.
#+END_QUOTE


* TODO A quote by Ampère                                                                      :post:
:PROPERTIES:
:TITLE: A quote by Ampère
:EXPORT_FILE_NAME: quoteampere.html
:INDEX_DATE: <2018-09-03 Mon 21:55>
:END:

/[Les langues] commencent par être una musique, et finissent par être une algèbre./ 
  -- [[https://fr.wikisource.org/wiki/Essai_sur_l%25E2%2580%2599histoire_de_la_langue_bretonne][M. Ampère]].

I am having a bit of trouble locating the exact source of this
sentence and I am also not sure in which sense should be interpreted;
but I somehow imagined that the idea of languages as algebras would
be more modern than this.

* TODO LibreIM, casi cinco años después                                                       :post:
:PROPERTIES:
:TITLE: LibreIM, casi cinco años después
:EXPORT_FILE_NAME: libreimquintoaniversario.html
:INDEX_DATE: <2018-09-03 Mon 21:54>
:END:

Tengo un correo de diciembre de 2013 en el que David Charte consiguió
meter un foro de Moot en una página de Github. En julio de 2014 entre
Nacho Cordón, David Charte y yo perfilamos la idea de reunirnos en la
facultad; tuvimos mucha ayuda del departamento de álgebra; y el 27 de
septiembre de 2014 a las 10:00 en el A13 de Ciencias empezamos el
primer seminario, sobre teoría de categorías y Haskell, con Pablo
Baeyens en la segunda parte.

Llevamos 48 seminarios, y la asistencia ha ido creciendo poco a poco.
Me hace cierta ilusión que, aun con algún problema que otro, haya
funcionado.  Mientras sirvan para seguir poniendo ideas en común y
siga habiendo gente dispuesta a ir y a prepararlos, son una
herramienta muy útil para tener en un grado.  Han servido para
conocer un montón de gente con ganas de explorar y compartir las
matemáticas y la informática.  Y la comunidad motiva mucho; el doble
grado hubiera sido muy árido de otra forma.

No sé muy bien cómo hemos llegado a este equilibrio en el que el
comportamiento por defecto es compartir, pero creo que se ha arraigado
bien en el doble grado y merece mucho la pena cuidarlo.  Estaría muy
orgulloso de todo esto si colectivamente conseguimos mantenerlo en un
futuro.


* TODO Writing a bachelor's thesis in org-mode                                                :post:
:PROPERTIES:
:TITLE: Writing a bachelor's thesis in org-mode
:EXPORT_FILE_NAME: bachelorsthesisinorgmode.html
:INDEX_DATE: <2018-08-15 Wed 23:37>
:END:

My [[https://github.com/mroman42/ctlc/][bachelor's thesis]] has been completely written in org-mode
format. At first, I supposed that org-mode would not be powerful
enough for a really long document with templates and lots of latex
customizations, but I stand corrected. You can insert arbitrary latex
code when needed and there is nothing preventing you to create a complex
header for your org-mode document.

After the experience, I would recommend using org-mode. You can manage
your tasks, your references and your text in a single file; and the
org-mode format is much more pleasant to read and write than the usual
tex format. The only problem I had was compilation: Emacs is really
slow and freezes while compiling. My solution was to use a second
Emacs instance which compiles on the background while I continue to
use the first one; the relevant line on the makefile looks as follows
(thanks to [[https://github.com/ncordon][@ncordon]] for the idea!).

#+BEGIN_SRC bash
  emacs thesis.org --batch -u `id -un` \
    --eval '(load user-init-file)' \
    -f org-latex-export-to-pdf
#+END_SRC

* TODO Blogging with a single org-file                                                        :post:
:PROPERTIES:
:TITLE: Blogging with a single org-file
:EXPORT_FILE_NAME: bloggingwithasingleorgfile.html
:INDEX_DATE: <2018-08-15 Wed 23:19>
:ID:       64a920ed-1914-4e64-997d-837f14815cdd
:END:

This blog is generated by a single org-file that can be found
[[https://github.com/mroman42/cosmoi/blob/master/cosmoi.org][here]]. The file contains some org-babel elisp blocks that export the
HTML files, create the index and populate the RSS feed. This is
possible using [[https://orgmode.org/manual/Tags.html#Tags][tags]] that signal whether any specific header is a post,
[[https://orgmode.org/manual/Property-syntax.html][properties]] that store the name and the html direction of the articles,
and the =org-map-entries= function, which maps a function over all
headers.



* TODO Category theory and lambda calculus                                                    :post:
:PROPERTIES:
:TITLE: Category theory and lambda calculus
:EXPORT_FILE_NAME: categorytheoryandlambdacalculus.html
:INDEX_DATE: <2018-07-01 Sun 11:00>
:END:

*Category theory and lambda calculus* is the title of my bachelor's
thesis.  It discusses the implementation of [[./mikrokosmos.html][Mikrokosmos]] and
categorical semantics for the simply typed lambda calculus in its
first half. It later extends these notions to dependently typed
programming languages (Agda is used as an example) and locally closed
cartesian categories.  It must be seen as a summary of my study during
these months and as a literature review: there is no claim of
originality more than the way the ideas are presented.

The complete thesis was written with Emacs in [[https://orgmode.org/][org-mode format]] (highly
recommended) and the source code is publicly available [[https://github.com/mroman42/ctlc][at GitHub]]. The
final [[https://mroman42.github.io/ctlc/ctlc.pdf][PDF]] is also available, but if you are not that interested on the
details, you may prefer to simply read the [[https://mroman42.github.io/ctlc-slides/slides.pdf][commented slides]] (in
Spanish), which are a reasonable summary of the ideas presented there.

* TODO Evaluación en cálculo lambda                                                           :post:
:PROPERTIES:
:TITLE: Evaluación en cálculo lambda
:EXPORT_FILE_NAME: evaluacionlambda.html
:INDEX_DATE: <2018-05-25 Fri 18:02>
:END:
Esta es una recopilación de los enunciados que nos llevan a usar la
evaluación mediante \beta-reducciones del cálculo lambda como un
lenguaje de programación.  Los obtuve principalmente del libro de
Barendregt y de las notas de Peter Selinger cuando buscaba la base
teórica para implementar [[file:mikrokosmos.html][Mikrokosmos]] Detallo estos mismos
enunciados recopilando sus demostraciones en [[https://github.com/M42/lambda.notes][M42/lambda.notes]].

** Forma normal
Una expresión está en /forma normal/ si no se le pueden aplicar más
\beta-reducciones. La forma normal es /única/ como consecuencia del
teorema de Church-Rosser.

*Teorema de Chuch-Rosser.* Si a un mismo término se le aplican dos
cadenas de reducciones distintas, los términos que se obtienen pueden
a su vez reducirse a un término común. Es decir,

 * si A puede reducirse mediante β-reducciones a otro término
   B, lo que se nota por  A -{β}-> B,
 * y A puede reducirse también mediante otras β-reducciones,
   posiblemente distintas o en distinto orden, a C, como A -{β}-> C,
 * entonces existe un término D tal que ambos se pueden reducir
   mediante β-reducciones a él; es decir, tal que B -{β}-> D
   y C -{β}-> D.

En particular, esto implica que si un término tuviera dos formas
normales, debería existir otro término al cual se pudieran reducir
ambas; como son formas normales y no pueden reducirse, esto debe
implicar que son iguales.

** Divergencia
Hemos visto que la forma normal es única, pero no que exista o que
sepamos encontrarla de alguna forma. Puede ocurrir que un término no
esté en forma normal y sin embargo las reducciones no lo lleven a
ella.  Por ejemplo, el término Ω = (λ x.x x)(λ x.x x)
es invariante a β-reducciones y *no llega a forma normal*. O por 
ejemplo, el término (λ x.x x x)(λ x.x x x) se hace cada vez más grande
al aplicarle reducciones, decimos que /diverge/.

** Evaluación a izquierda
Hay expresiones que llegarán a una forma normal o no dependiendo de
cómo los evaluemos. Por ejemplo, el término =(const id Ω)= llega a
la forma normal =id= si evaluamos primero la aplicación de =const=,
pero diverge si empezamos intentando evaluar Ω. 
Sin embargo, existe una estrategia de reducción que siempre encuentra
una forma normal si esta existe. Tenemos el siguiente teorema.

 * Si existe una forma normal, la estrategia que reduce a cada paso
   la aplicación más a la izquierda posible la encuentra.

Y quizá sorprendentemente, existe otra estrategia de reducción que siempre
encuentra la forma de *no* llegar a la forma normal si esta existiera.

 * Si existe alguna sucesión que no llega a forma normal, la
   estrategia que reduce a cada paso la aplicación más a la derecha
   posible la encuentra.

Estas dos formas de evaluación se suelen llamar /call-by-value/ y
/call-by-name/.

* TODO Cartesian closed categories                                                            :post:
:PROPERTIES:
:TITLE: Cartesian closed categories
:EXPORT_FILE_NAME: cartesianclosedcategories.html
:INDEX_DATE: <2018-07-01 Sun 11:30>
:ID:       3d52d110-822a-4f85-a1c4-57d868b527d5
:END:

A /cartesian closed category/ *C* can be defined as a category having a right adjoint
of the unique functor to the terminal category * : *C* -> 1, a right adjoint of the
diagonal functor  Δ : *C* -> *C* × *C*, and a right adjoint of (_ × c) : *C* -> *C* for
each c ∈ *C*. These three adjoints correspond to the existence of a /terminal/ object,
binary /products/ and /exponentials/.

#+BEGIN_SRC haskell
  * -> *     c,c ->  a,b      a × c -> b
 --------   --------------  --------------
  c -> 1     c  -> a × b     a -> (c -> b)
#+END_SRC

These three rules match the three introduction rules for the simply
typed lambda calculus. We interpret c as a context Γ and each morphism
x : c -> a as a term  Γ ⊢ x : a.

#+BEGIN_SRC haskell
                Γ ⊢ a : A   Γ ⊢ b : B     Γ , a : A ⊢ b : B
 -----------   ------------------------  ---------------------
  Γ ⊢ * : 1       Γ ⊢ ⟨a,b⟩ : A × B       Γ ⊢ (λa.b) : A -> B
#+END_SRC

Now, we should discuss if \beta-equivalence corresponds to the equality between morphisms.

* TODO Ideas de teoría de tipos                                                               :post:
:PROPERTIES:
:TITLE:    Ideas de teoría de tipos
:EXPORT_FILE_NAME: ideasteoriatipos.html
:INDEX_DATE: <2016-01-08 Fri 15:13>
:END:

/Una recopilación de algunas ideas y enlaces después de haber empezado
a leer sobre teoría de tipos./

Los sistemas de tipos tienen su utilidad en las matemáticas. Sirven para
modelar una fundamentación de las matemáticas distinta de la usual
fundamentación conjuntista; y tienen varias aplicaciones interesantes en
lenguajes funcionales y asistentes de demostración. En particular, sobre
los tipos se puede definir un álgebra y se pueden representar sistemas
lógicos. Vamos a tratar esas aplicaciones referenciando en cada caso
artículos donde se exponen en profundidad.

** Inducción estructural
La inducción estructural es una generalización de la inducción usual
sobre los naturales que la extiende a otras estructuras representables
como tipos de un lenguaje funcional. Sobre la inducción estructural
hemos escrito previamente en el blog una introducción:

-  [[http://tux.ugr.es/dgiim/blog/2015/03/14/induccion-estructural/][Inducción Estructural - Blog LibreIM]]

En ese post se escriben ejemplos sobre los naturales y los árboles. El
artículo sobre el que se basa es:

-  [[http://math.blogoverflow.com/2015/03/10/when-can-we-do-induction/][When can we do induction? - math.blogoverflow]]

Ejemplos y más detalles sobre inducción estructural y sus usos pueden
encontrarse en:

-  [[http://www.cs.cmu.edu/~me/212/handouts/structural.pdf][Some notes on Structural Induction - Michael Erdmann]]
-  [[http://arxiv.org/pdf/1312.2696.pdf][Structural Induction Principles for Functional Programmers - James Caldwell]]

Y varias demostraciones por inducción estructural implementadas en Coq
en este repositorio sobre [[https://github.com/mroman42/recorridosArboles][*recorridos en árboles*]].

** Álgebra de tipos
En un post anterior del blog de *LibreIM* hemos tratado el álgebra de
tipos. Ese post se basó sobre otros tres publicados en el blog de Chris
Taylor:

-  [[http://tux.ugr.es/dgiim/blog/2015/03/24/algebra-tipos/][Álgebra de tipos - Blog LibreIM]]
-  [[http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/][The algebra of algebraic data types, Part I - Chris Taylor]]
-  [[http://chris-taylor.github.io/blog/2013/02/11/the-algebra-of-algebraic-data-types-part-ii/][The algebra of algebraic data types, Part II - Chris Taylor]]
-  [[http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/][The algebra of algebraic data types, Part III - Chris Taylor]]

En el segundo de los artículos se usan funciones generadoras para probar
resultados sobre los números de Catalan y los árboles binarios. La
teoría de funciones generadoras necesaria para entender el tratamiento
de los árboles binarios la explica Mike Spivey en
/[[https://mikespivey.wordpress.com/2013/03/19/the-catalan-numbers-from-their-generating-function/][The catalan numbers from their generating function]]/.

Además, existe un resultado de *Fiore y Leinster* que afirma que si
demostramos una relacion polinómica para números complejos, también será
válida para cualquier
[[https://en.wikipedia.org/wiki/Semiring][semianillo]]. Y por tanto,
para los tipos. Esto quiere decir que, en la mayoría de las ocasiones,
podemos usar la resta o la división de tipos como si existieran. La
demostración excluye algunos casos particulares y se expone aquí:

-  [[http://arxiv.org/pdf/math/0212377v1.pdf][Objects of categories as
   complex numbers - Marcelo Fiore y Tom Leinster]]

Sobre el uso de las derivadas en el álgebra de tipos existe un resultado
de *Conor McBride* que relaciona las derivadas parciales con los
[[http://learnyouahaskell.com/zippers][/zippers/]] de Haskell usados
para representar contextos. Puede leerse aquí:

-  [[http://strictlypositive.org/diff.pdf][The derivative of a regular
   type is its type of one-hole contexts - Conor McBride]].

** Lógica con tipos
La aplicación de los tipos a la lógica y las demostraciones parte del
isomorfismo de Curry-Howard, que relaciona los sistemas de tipos con
sistemas lógicos. El sistema más simple donde puede apreciarse el
isomorfismo es el
[[https://en.wikipedia.org/wiki/Typed_lambda_calculus][*cálculo lambda tipado*]], que es isomorfo a la
[[https://en.wikipedia.org/wiki/Natural_deduction][*deducción natural*]]. La deducción natural es un ejemplo de lógica intuicionista,
lo que en la práctica quiere decir que /no/ (!) se tienen el /tercio
excluso/ y la /doble negación/ como axiomas:

$$ A \vee \neg A$$

$$ \neg \neg A \implies A $$

Los apuntes sobre [[https://github.com/libreim/curryHoward/blob/master/CurryHoward.pdf][*Curry-Howard*]]
de los repositorios del doble grado explican el isomorfismo sobre la
deducción natural y el cálculo lambda tipado. El
[[https://github.com/libreim/curryHoward/tree/master/src][código fuente]] acompañando los apuntes está escrito en Coq y Haskell.

La idea de tratar las proposiciones como tipos la expone *Philip Wadler*
en los dos siguientes artículos: primero de manera didáctica, con una
introducción histórica y sobre el sistema de la deducción natural, y
luego de forma más compleja, exponiendo el isomorfismo sobre el sistema
de tipos de Haskell.

-  [[http://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf][Propositions
   as Types - Philip Wadler]]
-  [[http://homepages.inf.ed.ac.uk/wadler/papers/gr2/gr2.pdf][The
   Girard-Reynolds Isomorphism - Philip Wadler]]

** Parametricidad
La parametricidad limita las instancias posibles de los tipos de la
forma =forall a. p(a)=, y nos permite obtener teoremas sobre todas las
instancias de esos tipos. Se explica a nivel intuitivo en el siguiente
post de Bartosz Milewski y más formalmente en este paper de Philip
Wadler:

-  [[http://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/][Parametricity:
   Money for Nothing and Theorems for Free - Bartosz Milewski]]
-  [[http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf][Theorems
   for free! - Philip Wadler]]

** Teoría de tipos
Los tipos pueden usarse para fundamentar las matemáticas, del mismo modo
que lo hacen los conjuntos (en sistemas axiomáticos como [[https://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory][ZFC]])
o las categorías (en sistemas como [[https://ncatlab.org/nlab/show/ETCS][ETCS]]). En el siguiente artículo
se discuten las diferencias de ambos con la *teoría de tipos
dependientes de Martin-Löf*, que se expone por completo en las notas de
Nordström, Petersson y Smith:

-  [[https://golem.ph.utexas.edu/category/2013/01/from_set_theory_to_type_theory.html][From Set Theory to Type Theory - The n-Category Café]]
-  [[http://www.cse.chalmers.se/~bengt/papers/hlcs.pdf][Martin-Löf Type Theory - B. Nordström, K. Petersson, J.M. Smith]]

Esto nos da una fundamentación de las matemáticas con una interpretación
computacional clara.

Una refinación de esas teorías para producir una fundamentación
también constructivista de las matemáticas es el Cálculo de
Construcciones (Calculus of constructions, COC) desarrollado por
*Thierry Coquand* y *Gérard Huet*, que finalmente dará lugar al
asistente de demostraciones *COQ*, desarrollado por el INRIA. El
[[https://en.wikipedia.org/wiki/Lambda_cube][*\lambda-cubo*]] es un diagrama para exponer cómo este sistema amplía al
/cálculo lambda tipado/ y al /Sistema $F_\omega$/ que usa Haskell.

-  [[http://ac.els-cdn.com/0890540188900053/1-s2.0-0890540188900053-main.pdf?_tid=3846e956-b301-11e5-8e78-00000aab0f02&acdnat=1451925532_87ac5a8e6a7bd6477746a55c17130f43][Calculus of Constructions - T. Coquand, G. Huet]].
-  [[https://coq.inria.fr/][The Coq proof assistant - INRIA]]

* TODO Informal CV                                                                            :post:
:PROPERTIES:
:TITLE:    Informal CV
:EXPORT_FILE_NAME: informalcv.html
:INDEX_DATE: <2018-10-21 Sun>
:END:

 * December 2018. Attended [[http://events.cs.bham.ac.uk/syco/2/][SYCO2]]. (University of Strathclyde)
 * October 2018. Started a [[https://www.ox.ac.uk/admissions/graduate/courses/msc-mathematics-and-foundations-computer-science?wssl=1][MSc in Mathematics and Foundations of Computer Science]]. (University of Oxford)
 * August 2018. Participant [[https://homalg-project.github.io/capdays-2018/][CAP days]]. (Universität Siegen)
 * June 2018. Finished the double degree on Mathematics and Computer Engineering. (University of Granada)
 * June 2018. Presented my bachelor's thesis. [[https://mroman42.github.io/ctlc/ctlc.pdf][Category theory and lambda calculus]]. (University of Granada)
 * December 2017. [[https://unimath.github.io/bham2017/][School and Workshop on Univalent Mathematics]]. (University of Birmingham)
 * July 2017. [[https://sites.google.com/view/summerschool2017-eutypes/][EUTypes Summer School]]. (Ohrid, Macedonia)
 * March 2017. [[https://sites.google.com/unizar.es/affine-group-schemes-seminar/inicio][Seminar. Affine group schemes, an introduction]]. (University of Zaragoza)
 * October 2012. Attended the XXVII Olimpiada Iberoamericana de Matemática. (Cochabamba, Bolivia)
 * September 2012. Started a double degree in [[http://grados.ugr.es/informaticaymatematicas/][Mathematics and Computer Engineering]]. (University of Granada)
 * July 2012. Attended the [[http://oma.org.ar/imo2012/][53rd International Mathematical Olympiad]]. (Mar del Plata, Argentina)

* TODO Projective, injective and flat modules
:PROPERTIES:
:TITLE:    Projective, injective and flat modules
:HUGO_TAGS: math
:HUGO_TOPICS: math
:HUGO_FILE: post/projectivemodules.md
:HUGO_DATE: [2017-02-18 Sat 15:10]
:END:

** Definitions
An R-module $D$ is:

 1. *Projective* if $Hom(D, -)$ is an exact functor.
 2. *Injective* if $Hom(-,D)$ is an exact functor.
 3. *Flat* if $D \otimes -$ is an exact functor.

** Characterization
We know that $Hom(D,-)$ and $Hom(-,D)$ are left-exact and that
$D\otimes -$ is right-exact; so for them to be exact, we only need:

- A module $D$ is *projective* when every $f : B \longrightarrow C$ surjective induces
  $(f\circ\_) :Hom(D,B) \longrightarrow Hom(D,C)$ surjective.
  #+attr_html: :width 300px
  https://raw.githubusercontent.com/mroman42/mroman42.github.io/images/projective.jpeg

- A module $D$ is *injective* when $f : A \longrightarrow B$ surjective induces
  $(\_\circ f) : Hom(B,D) \longrightarrow Hom(A,D)$ surjective.
  #+attr_html: :width 300px
  https://raw.githubusercontent.com/mroman42/mroman42.github.io/images/injective.jpeg
   
- A module $D$ is *flat* when $f : A \longrightarrow B$ injective induces 
  $f' : D\otimes A \longrightarrow D \otimes B$ injective.
* TODO Wikipedia contributions                                                                :post:
:PROPERTIES:
:TITLE:    Wikipedia contributions
:EXPORT_FILE_NAME: wikipediacontributions.html
:INDEX_DATE: <2018-02-17 Tue 12:00>
:END:

The majority of my math-related contributions to Wikipedia are
translations from the English language Wikipedia to the Spanish one
in math-related areas.  There are also some minor contributions to
other articles. There I keep a (not-that-updated) list of articles
I have contributed to.

 * [[https://es.wikipedia.org/wiki/Lema_de_escisi%25C3%25B3n][Lema de escisión]].
 * [[https://es.wikipedia.org/wiki/Compleci%25C3%25B3n_(%25C3%25A1lgebra)][Compleción (Álgebra)]].
 * [[https://es.wikipedia.org/wiki/Lema_de_la_serpiente][Lema de la serpiente]].
 * [[https://es.wikipedia.org/wiki/M%25C3%25B3nada_(teor%25C3%25ADa_de_categor%25C3%25ADas)][Mónada (teoría de categorías)]].
 * [[https://es.wikipedia.org/wiki/Funtor_Tor][Funtor Tor]].
 * [[https://es.wikipedia.org/wiki/M%25C3%25B3dulo_simple][Módulo simple]].
 * [[https://es.wikipedia.org/wiki/Teor%25C3%25ADa_de_dominios][Teoría de dominios]].
 * [[https://es.wikipedia.org/wiki/L%25C3%25ADmite_(teor%25C3%25ADa_de_categor%25C3%25ADas)][Límite]].
 * [[https://es.wikipedia.org/wiki/Extensi%25C3%25B3n_de_Kan][Extensión de Kan]].
 * Espacio de Cantor.
 * [[https://es.wikipedia.org/wiki/Categor%25C3%25ADa_de_espacios_topol%25C3%25B3gicos][Categoría de espacios topológicos]].
 * [[https://es.wikipedia.org/wiki/Categor%25C3%25ADa_cartesiana_cerrada][Categoría cartesiana cerrada]].
 * [[https://es.wikipedia.org/wiki/Teor%25C3%25ADa_de_tipos_homot%25C3%25B3pica][Teoría de tipos homotópica]].
 * [[https://es.wikipedia.org/wiki/C%25C3%25A1lculo_lambda_simplemente_tipado][Cálculo lambda simplemente tipado]].
 * [[https://es.wikipedia.org/wiki/Bloqueo_del_card%25C3%25A1n][Bloqueo del cardán]].
 * [[https://es.wikipedia.org/wiki/Fibraci%25C3%25B3n_de_Grothendieck][Fibración de Grothendieck]].


* TODO Yoneda lemma                                                                           :post:
:PROPERTIES:
:TITLE:    Yoneda lemma
:EXPORT_FILE_NAME: yonedalemma.html
:INDEX_DATE: <2019-06-25 Tue>
:END:

For any covariant  K : D → *Sets*  and r ∈ D, there is a bijection
#+BEGIN_SRC haskell
   y  :  Nat(D(r,-), K) ≅ Kr
#+END_SRC
sending any natural transformation α : D(r,-) => K to its image on the
identity, αᵣ(idᵣ).  If we call よ : C -> Cat(Cᵒᵖ, Sets) to the *Yoneda*
*embedding* that sends each object to its representable presheaf, we can
also write
#+BEGIN_SRC haskell
   Nat(よ(r), K) ≅ K r
#+END_SRC

The formulation in terms of ends and coends is often called the
*Ninja Yoneda lemma* (see Loregian's /[[https://arxiv.org/abs/1501.02503][This is the (co)end, my only (co)friend]]/). 
It can be seen as a sort of Dirac's rule for coend calculus.

For any functor K : *Cᵒᵖ* -> *Sets* (any presheaf), we have
#+BEGIN_SRC haskell
  K  ≅  ∀ c ∈ C .  C(c,_) -> K c
  K  ≅  ∃ c ∈ C .  K c × C(_,c)
#+END_SRC

For any functor H : *C* -> *Sets* (any copresheaf), we have
#+BEGIN_SRC haskell
  H  ≅  ∀ c ∈ C .  C(_,c) -> H c 
  H  ≅  ∃ c ∈ C .  H c × C(c,_)
#+END_SRC

* TODO Yoneda lemma
:PROPERTIES:
:TITLE:    Yoneda lemma
:EXPORT_FILE_NAME: yonedalemma.pdf
:INDEX_DATE: <2018-02-17 Tue 12:00>
:END:

** Lema de Yoneda
Sea $G : {\cal C} \longrightarrow \mathtt{Set}$ un funtor covariante. Fijado $A \in obj({\cal C})$, tenemos una
biyección entre las transformaciones naturales del funtor $Hom(A,-)$ a
$G$ y los elementos del conjunto $G(A)$:

\[
y : Nat(Hom_{\cal C}(A,-),G) \longrightarrow G(A)
\]

Que viene dada por $y(\tau) = \tau_A(1_A)$, la imagen de la identidad por la
transformación natural.

*** Demostración
Dado cualquier $p$ crearemos la única transformación natural que cumple
$\eta_A(1_A) = p$. Por definición de transformación natural, sabemos que debe
cumplir el siguiente diagrama conmutativo:

#+attr_html: :width 500px
https://raw.githubusercontent.com/mroman42/mroman42.github.io/images/yonedaproof1.jpeg

Lo que deja determinado a cualquier $\eta_B(f)$, y por tanto a toda la función:

\[\eta_B(f) = \eta_B(f\circ id) = Gf(\eta_A(id_A)) = Gf(p) \]

Nos falta comprobar que la función así construida es de hecho una 
transformación natural. Es decir, que cumple el siguiente diagrama
conmutativo:

#+attr_html: :width 500px
https://raw.githubusercontent.com/mroman42/mroman42.github.io/images/yonedaproof2.jpeg

Y de hecho, dado cualquier elemento $f \in Hom(A,B)$ tenemos:

\[Gg\circ \eta(f) = Gg \circ Gf(p) = G(g\circ f)(p) = \eta(g\circ f)\]

** Lema de Yoneda (caso contravariante)
Si aplicamos Yoneda sobre $\mathcal{C}^{op}$, dado $G : {\cal C} \longrightarrow \mathtt{Set}$ *contravariante*
y fijado $A \in obj({\cal C})$; existe una biyección entre las transformaciones naturales
del funtor $Hom(-,A)$ a $G$ y los elementos del conjunto $G(A)$:

\[
y : Nat(Hom_{\cal C}(-,A),G) \longrightarrow G(A)
\]

Que viene de nuevo dada por $y(\tau) = \tau_A(1_A)$.

** Referencias y enlaces
[1] J. Rotman, An Introduction to Homological Algebra.

[2] Bartosz Milewski's Programming Cafe.
    [[https://bartoszmilewski.com/2015/09/01/the-yoneda-lemma/][The Yoneda Lemma]]

[3] The Catsters.
    [[https://www.youtube.com/watch?v=TLMxHB19khE][Representables and Yoneda 3]]

* html-header                                                                               :ignore:
#+HTML_HEAD: <link rel="stylesheet" href="../default.css" />
#+HTML_HEAD: <link rel="stylesheet" href="../mathjax_fonts.css" />
#+HTML_HEAD: <link rel="stylesheet" href="../syntax.css" />

#+HTML_HEAD: <div id="header">
#+HTML_HEAD:     <div id="logo">
#+HTML_HEAD:         <a hrwef="blog.html">Mario Román</a>
#+HTML_HEAD:     </div>
#+HTML_HEAD:     <div id="navigation">
#+HTML_HEAD:         <a href="index.html">About</a>
#+HTML_HEAD:         <a href="blog.html">Blog</a>
#+HTML_HEAD:         <a href="https://github.com/mroman42/">Github</a>
#+HTML_HEAD:     </div>
#+HTML_HEAD: </div>
