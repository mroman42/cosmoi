<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-12-27 Fri 15:49 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Inducción estructural</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Mario Román" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="../css/default.css" />
<link rel="stylesheet" href="../css/mathjax_fonts.css" />
<link rel="stylesheet" href="../css/syntax.css" />
<div id="header">
<div id="logo">
<a hrwef="../index.html">Mario Román</a>
</div>
<div id="navigation">
<a href="../index.html">About</a>
<a href="../posts/index.html">Blog</a>
<a href="https://github.com/mroman42/">Github</a>
</div>
</div>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Inducción estructural</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org197da78">Conjuntos bien fundados</a></li>
<li><a href="#org1ac7fa7">Inducción sobre tipos</a></li>
<li><a href="#org2679706">Ejemplo 1: Naturales</a></li>
<li><a href="#org28e0de8">Ejemplo 2: Árboles binarios</a></li>
</ul>
</div>
</div>
<p>
Normalmente aplicamos inducción sobre los números naturales, y cuando
necesitamos aplicar inducción en otro contexto lo hacemos corresponder con los 
números naturales. Por ejemplo, si queremos demostrar una propiedad sobre los
árboles binarios, la demostraríamos por inducción sobre la altura del
árbol. Pero el proceso de llevar todo a los naturales puede ser
incómodo, tedioso y puede complicar la demostración innecesariamente. En
este post vamos a desarrollar una forma de ampliar la inducción a la
estructura de los tipos de datos para simplificar todas esas
demostraciones.
</p>

<div id="outline-container-org197da78" class="outline-2">
<h2 id="org197da78">Conjuntos bien fundados</h2>
<div class="outline-text-2" id="text-org197da78">
<p>
Vamos a definir las relaciones bien fundadas, que nos permitirán definir
una inducción generalizada. [1]
</p>

<ul class="org-ul">
<li><b>Relación bien fundada:</b> una relación en un conjunto de elementos
es bien fundada si todo subconjunto no vacío tiene un elemento
minimal. Dado un orden parcial, es bien fundado si todo subconjunto
no vacío tiene un elemento tal que ninguno es menor que él.</li>
</ul>

<p>
Y podemos realizar inducción sobre cualquier conjunto con una relación
bien fundada.
</p>

<ul class="org-ul">
<li><p>
<b>Inducción noetheriana:</b> sea X un conjunto bien fundado con
A ⊂ X. Si se cumple:
</p>

<p>
(y &lt; x =&gt; y ∈ A) =&gt; x ∈ A
</p>

<p>
Entonces A = X.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org1ac7fa7" class="outline-2">
<h2 id="org1ac7fa7">Inducción sobre tipos</h2>
<div class="outline-text-2" id="text-org1ac7fa7">
<p>
Ahora vamos a aplicar esto a teoría de tipos. Sea un tipo con sus
constructores. Para todas las instancias constructibles del tipo (es decir,
aquellas que pueden
generarse en un número finito de pasos desde sus constructores),
definimos un orden parcial:
</p>

<ul class="org-ul">
<li><p>
<b>Orden constructivo:</b> para dos instancias del tipo: a, b : A,
b <i>se construye con</i> a si el constructor de b toma a
como argumento. La clausura transitiva de esta relación forma un
orden parcial:
</p>

<p>
a ≤ b  =&gt;  a  se usa en la construcción de  b 
</p></li>
</ul>

<p>
Y ahora tenemos una inducción sobre los constructores de los tipos, que
describimos ahora.
</p>

<ul class="org-ul">
<li><p>
<b>Inducción sobre tipos</b>: sea un tipo A con constructores y sea
P : A -&gt; Bool una propiedad. Siendo
a₁, a₂ &#x2026; aᵢ : A argumentos del constructor, si se cumple
la condición de inducción para cada constructor Cᵢ:
</p>

<p>
P(a₁) ∧ P(a₂) ∧ &#x2026; ∧ P(aᵢ)  =&gt;  P(Cᵢ(a₁,a₂,&#x2026;,b₀,b₁,&#x2026;))
</p></li>
</ul>

<p>
Entonces a : A =&gt; P(a).
</p>
</div>
</div>

<div id="outline-container-org2679706" class="outline-2">
<h2 id="org2679706">Ejemplo 1: Naturales</h2>
<div class="outline-text-2" id="text-org2679706">
<p>
Nuestro primer ejemplo va a ser obtener la inducción sobre los naturales
como caso particular. Damos una definición de los naturales en lenguaje
Haskell, con los axiomas de Peano, un natural es 0 o el siguiente de un
natural:
</p>

<div class="org-src-container">
<pre class="src src-haskell">    <span style="color: #4f97d7; font-weight: bold;">data</span> <span style="color: #ce537a; font-weight: bold;">Nat</span> <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">O</span>
             <span style="color: #7590db;">|</span> <span style="color: #ce537a; font-weight: bold;">S</span> <span style="color: #ce537a; font-weight: bold;">Nat</span>
</pre>
</div>

<p>
Que equivale a la definición en Coq:
</p>

<pre class="example">
    Inductive nat : Type :=
      | O : nat
      | S : nat -&gt; nat
</pre>

<p>
Es decir, si lo demostramos para <code>0</code> y para <code>S n</code> sabiéndolo para <code>n</code>,
lo hemos demostrado para todos los naturales.
</p>
</div>
</div>

<div id="outline-container-org28e0de8" class="outline-2">
<h2 id="org28e0de8">Ejemplo 2: Árboles binarios</h2>
<div class="outline-text-2" id="text-org28e0de8">
<p>
Ahora vamos a intentar el ejemplo que motivó esta búsqueda. Definimos un
árbol binario como un árbol vacío o como un nodo del que surgen dos
árboles binarios, en Haskell:
</p>

<div class="org-src-container">
<pre class="src src-haskell">    <span style="color: #4f97d7; font-weight: bold;">data</span> <span style="color: #ce537a; font-weight: bold;">Tree</span> a <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">Empty</span>
                <span style="color: #7590db;">|</span> <span style="color: #ce537a; font-weight: bold;">Node</span> a <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Tree</span> a<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Tree</span> a<span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
Que equivale a la definición en Coq:
</p>

<pre class="example">
    Inductive tree (X:Type) : Type :=
      | nilt : tree X
      | node : X -&gt; tree X -&gt; tree X -&gt; tree X.
</pre>

<p>
Es decir, si demostramos una propiedad para el árbol vacío y para un
árbol sabiendo que la cumplen sus subárboles derecho e izquierdo, la
hemos demostrado para todos los árboles binarios.
</p>

<p>
En el repositorio <a href="https://github.com/MROMAN42/recorridosArboles">mroman42/recorridosArboles</a> hay
varias demostraciones por inducción sobre árboles binarios, explicados
en lenguaje natural y demostrados luego sobre el asistente de
demostraciones Coq.
</p>

<p>
[1] Post sobre generalizaciones de la inducción <a href="http://math.blogoverflow.com/2015/03/10/when-can-we-do-induction/">en Stack Overflow</a>.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<hr><p class="date">Last edited 2019-12-27 15:49:41 by Mario Román (<a href="https://github.com/mroman42/cosmoi">code</a>).</p>
</div>
</body>
</html>
